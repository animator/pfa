\documentclass{article}
\usepackage{fullpage}
\usepackage[]{hyperref}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{xcolor}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}

\newcommand{\PFAc}{\ttfamily\bfseries}
\newcommand{\PFAp}{\ttfamily\bfseries}
\newcommand{\PFAt}{\ttfamily\bfseries}
\newcommand{\PFAtp}{\ttfamily\bfseries}
\newcommand{\PFApf}{\ttfamily\bfseries}
\newcommand{\PFAf}{\ttfamily\bfseries}

\newenvironment{description*}%
  {\vspace{-0.15 cm}\begin{description}%
    \setlength{\itemsep}{3pt}%
    \setlength{\parskip}{0pt}}%
  {\vspace{-0.25 cm}\end{description}}

\newenvironment{allowedfields}%
  {\begin{center} \begin{minipage}{0.9\linewidth} \begin{description}}%
  {\end{description} \end{minipage} \end{center}}

\hypersetup{colorlinks=true, allcolors=blue}

\theoremstyle{definition}
\newtheorem{example}{Example}[section]

\newenvironment{json}{
  \VerbatimEnvironment
  \begin{Verbatim}[xleftmargin=0.5cm,formatcom=\ttfamily\bfseries]}{\end{Verbatim}}

\renewcommand{\arraystretch}{1.4}

\title{PFA: Portable Format for Analytics (version 0.8.0)}
\author{Jim Pivarski}
\date{\today}

\input{libfcns}

\setlength{\parskip}{0.15 cm}
\begin{document}
\maketitle

{\large \bf Abstract}
\vspace{0.25 cm}

This specification defines the syntax and semantics of the Portable Format for Analytics (PFA).

PFA is a mini-language for mathematical calculations that is usually generated programmatically, rather than by hand.  A PFA document is a string of JSON-formatted text that describes an executable called a scoring engine.  Each engine has a well-defined input, a well-defined output, and functions for combining inputs to construct the output in an expression-centric syntax tree.  In addition, it has centralized facilities for maintaining state, with well-defined semantics for sharing state among scoring engines in a thread-safe way.  The specification defines a suite of mathematical and statistical functions for transforming data, but it does not define any means of communication with an operating system, file system, or network.  A PFA engine must be embedded in a larger system that has these capabilities, and thus an analytic workflow is decoupled into a part that manages data pipelines (such as Hadoop, Storm, or Akka), and a part that describes the algorithm to be performed on data (PFA).  

PFA is similar to the Predictive Model Markup Language (PMML), an XML-based specification for statistical models, but whereas PMML's focus is on statistical models in the abstract, PFA's focus is on the scoring procedure itself.  The same input given to two PFA-enabled systems must yield the same output, regardless of platform (e.g.\ a JVM in Hadoop, a client's web browser, a GPU kernel function, or even an IP core directly embedded in an integrated circuit).  Unlike PMML, the PFA specification defines the exact bit-for-bit behavior of any well-formed document, the semantics of data types and data structures, including behavior in concurrent systems, and all cases in which an exception should be raised.  Like PMML, PFA is a specification, not an implementation, it defines a suite of statistical algorithms for analyzing data, and it is usually generated programmatically, as the output of a machine learning algorithm, for instance.

\vspace{0.5 cm}
{\large \bf Status of this document}
\vspace{0.25 cm}

{\it This section describes the status of this document at the time of the current draft.  Other documents may supersede this document.}

This document is an early draft that has not been endorsed for recommendation by any organization.  It describes a proposed specification that could, in the future, become a standard.

\pagebreak

\tableofcontents

\pagebreak

\section{Introduction}

\subsection{Motivation for PFA}

The Portable Format for Analytics (PFA) is a mini-language for mathematical calculations.  It differs from most programming languages in that it is optimized for automatic code generation, rather than writing programs by hand.  The primary use-case is to represent the output of machine learning algorithms, such that they can be freely moved between systems.  Traditionally, this field has been dominated by special-purpose file formats, each representing only one type of statistical model.  The Predictive Model Markup Language (PMML) provides a means of unifying the most common model types into one file format.  However, PMML can only express a fixed set of pre-defined model types; new model types must be agreed upon by the Data Mining Group (DMG) and integrated into a new version of PMML, then that new version must be adopted by the community before it is widely usable.

PFA represents models and analytic procedures more generally by providing generic programming constructs, such as conditionals, loops, persistent state, and callback functions, in addition to a basic suite of statistical tools.  Conventional models like regression, decision trees, and clustering are expressed by referencing the appropriate library function, just as in PMML, but new models can be expressed by composing library functions or passing user-defined callbacks.  Most new statistical techniques are variants of old techniques, so a small number of functions with the appropriate hooks for inserting user code can represent a wide variety of methods, many of which have not been discovered yet.

Given that flexibility is important, one might consider using a general purpose programming language, such as C, Java, Python, or especially R, which is specifically designed for statistics.  While this is often the easiest method for small problems that are explored, formulated, and solved on an analyst's computer, it is difficult to scale up to network-sized solutions or to deploy on production systems that need to be more carefully controlled than a personal laptop.  The special-purpose code may depend on libraries that cannot be deployed, or may even be hard to identify exhaustively.  In some cases, the custom code might be regarded as a stability or security threat that must be thoroughly reviewed before deployment.  If the analytic algorithm needs to be deployed multiple times before it is satisfactory and each deployment is reviewed for reasons unrelated to its analytic content, development would be delayed unnecessarily.  This problem is solved by decoupling the analytic workflow into a part that deals exclusively with mathematics (the PFA scoring engine) and the rest of the infrastructure (the PFA host).  A mathematical algorithm implemented in PFA can be updated frequently with minimal review, since PFA is incapable of raising most stability or security issues, due to its limited access.

PFA is restricted to the following operations: mathematical functions on numbers, strings, raw bytes, homogeneous lists, homogeneous maps (also known as hash-tables, associative arrays, or dictionaries), heterogeneous records, and unions of the above, where mathematical functions include basic operations, special functions, data structure manipulations, missing data handling, descriptive statistics, and common model types such as regression, decision trees, and clustering, parameterized for flexibility.  PFA does not include any means of accessing the operating system, the file system, or the network, so a rouge PFA engine cannot expose or manipulate data other than that which is intentionally funneled into it by the host system.  The full PFA specification allows recursion and unterminated loops, but execution time is limited by a timeout.  PFA documents may need to be reviewed for mathematical correctness, but they do not need to be reviewed for safety.

Another reason to use PFA as an intermediate model representation is for simplicity of code generation.  A machine learning algorithm generates an executable procedure, usually a simple, parameterized decider algorithm that categorizes or makes predictions based on new data.  Although the parameters might be encoded in a static file, some component must be executable.  A PFA document bundles the executable with its parameters, simplifying version control.

The syntax of PFA is better suited to automatic code generation than most programming languages.  Many languages have complex syntax to accommodate the way people think while programming, including infix operators, a distinction between statements and expressions, and in some cases even meaningful whitespace.  Though useful when writing programs by hand, these features only complicate automatic code generation.  A PFA document is an expression tree rendered in JSON, and trees are easy to programmatically compose into larger trees without introducing syntax errors in the generated code.  This is well-known in the Lisp community, since the ease of writing code-modifying macros in Lisp is often credited to its exclusive use of expression trees, rendered as parenthesized lists (known as S-expressions).  PFA uses JSON, rather than S-expressions, because libraries for manipulating JSON objects are more widely available and JSON provides a convenient syntax for maps, but the transliteration between JSON and S-expressions is straight-forward.

Another benefit of PFA's simplicity relative to general programming languages is that it is more amenable to static analysis.  A PFA host can more thoroughly examine an incoming PFA document for undesirable features.  Although PFA makes use of callback functions to provide generic algorithms, functions are not first-class objects in the language, meaning that they cannot be dynamically assigned to variables.  The identity of every function call can be determined without running the engine, which makes it possible to statically generate a graph of function calls and identify recursive loops.  In very limited runtime environments, such as some GPUs, the compiler implicitly inlines all function calls, so recursion is not possible.  In cases like these, static analysis of the PFA document is a necessary step in generating the executable.

A PFA document can also be statically type-checked.  This allows for faster execution times, since types do not need to be checked at runtime, but it also provides additional safety to the PFA host.

PFA uses Apache Avro schemae for type annotations.  Avro is an open-source serialization protocol, widely used in Hadoop and related projects, whose type schemae are expressed as JSON objects and whose data structures can be expressed as JSON objects.  Therefore, all parts of the PFA engine, including control structures, type annotations, and embedded data are all expressed in one seamless JSON object.  Avro additionally has well-defined rules to resolve different but possibly compatible schemae, which PFA reinterprets as type promotion (allowing integers to be passed to a function that expects floating-point numbers, for instance).  When interpreted this way, Avro also has a type-safe null, which PFA uses to ensure that missing data are always explicitly handled.  Finally, the input and output of every PFA engine can always be readily (de)serialized into Avro's binary format or JSON representation, since Avro libraries are available on a wide variety of platforms.

\subsection{Terminology used in this specification}

Within this specification, the key words ``MUST'', ``MUST NOT'', ``REQUIRED'', ``SHALL'', ``SHALL NOT'', ``SHOULD'', ``SHOULD NOT'', ``RECOMMENDED'', ``MAY'', and ``OPTIONAL'' are to be interpreted as described in RFC 2119 (see \href{http://www.ietf.org/rfc/rfc2119.txt}{RFC2119}).  However, for readability, these words do not appear in all uppercase letters in this specification.

At times, this specification provides hints and suggestions for implementation.  These suggestions are not normative and conformance with this specification does not depend on their realization.  These hints contain the expression ``We suggest\ldots'', ``Specific implementations may\ldots'', or similar wording.

This specification uses the terms ``JSON object'', ``JSON object member name'', ``JSON object member value'', ``JSON array'', ``JSON array value'', ``number'', ``integer'', ``string'', ``boolean'', and ``null'' as defined in the JSON specification (\href{http://tools.ietf.org/html/rfc4627}{RFC-4627}), sections 2.2 through 2.5.  It also references and quotes sections of the Avro 1.7.6 specification (\url{http://avro.apache.org/docs/1.7.6/spec.html}).

\subsection{PFA MIME type and file name extension}

The recommended MIME type for PFA is ``application/pfa+json'', though this is not yet in the process of standardization.

It is recommended that PFA files have the extension ``.pfa'' (all lowercase) on all platforms.  It is recommended that gzip-compressed PFA files have the extension ``.pfaz'' (all lowercase) on all platforms.

\hypertarget{hsec:conformance}{}
\subsection{Levels of PFA conformance and PFA subsets}
\label{sec:conformance}

PFA is a large specification with many modules, so some projects or vendors may wish to implement some but not all of the specification.  However, interoperability is the reason PFA exists; if an implementation does not adhere to the standard, it has limited value.  It is therefore useful to explicitly define what it means for a system to partially implement the standard.

JSON subtrees of a PFA document are interpreted in the following six contexts.
\begin{itemize}
\item Top-level fields are JSON object member name, value pairs in the outermost JSON object of the PFA document.  They have unique member names and describe global aspects of the scoring engine.
\item Special forms are JSON objects that specify executable expressions and function definitions.  Each is associated with a unique name.
\item Library functions are strings that specify routines not defined in the PFA document itself.  Each is associated with a unique name that does not conflict with any of the special forms' names.
\item Avro type schemae are JSON objects and strings that describe data types.  The syntax and meaning of Avro types are specified in \href{http://avro.apache.org/docs/1.7.6/spec.html}{the Avro 1.7.6 specification}.
\item Embedded data are JSON objects, JSON arrays, numbers, integers, strings, booleans, and nulls that describe data structures.  The syntax and meaning of these objects are also defined by Avro, as the format used by the {\PFAc JSONEncoder} and {\PFAc JSONDecoder}.
\item Options are JSON object member values of the {\PFAc options} top-level field and may be overridden by the PFA system.  They all have well-defined defaults and unique, hierarchical names.
\end{itemize}

A system may be partially PFA compliant if it implements some but not all top-level fields, some but not all special forms, or some but not all library functions.  Its coverage may be specified by listing the object member names of the top-level fields that it does implement, the names of the special forms that it does implement, and the names of the library functions that it does implement.  Those top-level fields, special forms, and library functions that it does implement must be completely and correctly implemented.  The coverage is therefore atomic and one can immediately determine if a particular system can execute a particular PFA document by checking the set of names used by the document against the set of names implemented by the system.

Some special forms and library functions make use of some top-level fields.  For example, library functions that generate random numbers use the {\PFAc randseed} field for configuration.  These special forms and library functions cannot be considered implemented unless the corresponding top-level fields are also implemented.  The dependencies are explicitly defined in this specification.

Avro type schemae and JSON-encoded data should be completely implemented, to the extent defined by the Avro specification.  We suggest that implementations use language-specific Avro libraries as much as possible, rather than implementing Avro-related features in a PFA system.

Options may also be implemented atomically by name.  If a named option is not implemented, the system should behave as though that option had its default value, regardless of whether the option is explicitly set in the PFA document.  Options can in general be overridden by a host system, so if a host system doesn't implement an option, it is as though the system enforces the default.

The PFA standard is defined so that a PFA-compliant system can verify that the JSON types of a PFA document are correctly composed (syntax check), verify that the PFA invariants are maintained and Avro data types are correctly composed (semantic check), and impose additional constraints on the set of top-level fields, special forms, and library functions used (optional checks).  A PFA-compliant system should perform the syntax and semantic checks, including all type inference and type checking, though it is not strictly required.  A PFA document that does not satisfy these invariants and type constraints is not valid and its behavior is not defined by this specification.  The third set of checks, however, is completely optional and different systems may apply different constraints on the kinds of scoring engines they are willing to execute.  For instance, an implementation targeting a limited environment in which recursion is not possible may analyze the document and reject it if any recursive loops are found.

This specification does not define any standardized subsets of PFA.  As stated above, partial conformance is defined by ad hoc subsets of atomic units.  However, as experience develops, the community may define industry-standard subsets of PFA for specific purposes or special environments.  Conforming to a standardized subset would provide better interoperability than defining ad hoc subsets, and we would recommend such a standard when it exists.  At present, we can only recommend a carefully chosen ad hoc subset or complete conformance.

\subsection{Updates to the specification}

Updates to the PFA specification are labeled with version numbers. The version numbers have the strict form {\PFAc [1-9][0-9]*\textbackslash.[1-9][0-9]*\textbackslash.[1-9][0-9]*} where the first number is the major release number (major changes to the specification, such as new special forms, behavior, or top-level fields), the second is the minor release number (new features, such as new functions or function signatures), and the third is the bug-fix release number (rectifying errors in intention). Version numbers have a strict lexicographic order. {\bf FIXME: Should the first and second numbers be year and month of release, respectively? In that case, the major revision number would not necessarily imply major changes.}

Any changes in which previously valid PFA becomes invalid must go through a deprecation phase for several versions. When a PFA model uses a deprecated special form, function signature, or top-level field, the PFA implementation should issue a warning but accept the model until the cut-off version.

Changes in which previously invalid PFA becomes valid can become effective immediately.

Other backward-incompatible changes, such as valid PFA changing its behavior, are not allowed. New behaviors must introduce new function names, function signatures, special form structures, or top-level field names and deprecate the old ones.

\subsection{Open-source implementations}

The following open-source implementations can help clarify this specification.
\begin{description}
\item[Hadrian:] A PFA system written in Scala for the Java Virtual Machine (JVM).  It performs all necessary checks and dynamically compiles PFA documents into JVM bytecode for fast execution. Available from \url{https://github.com/opendatagroup/hadrian}.
\item[Titus:] A PFA system written in Python.  It performs all necessary checks, interprets PFA documents for testing, and transforms Python-based machine learning outputs into PFA. Available from \url{https://github.com/opendatagroup/hadrian}.
\end{description}

Although these implementations can help clarify the intent of the specification for future implementations, they are not normative definitions of the standard.  Only this document (and those that may supersede it) are normative.  All versions of this document, including the latest version, can be found on the websites listed above.

If you have a PFA implementation that you would like to see listed here, send an e-mail to \url{info@dmg.org}.

\pagebreak

\section{PFA document structure}

\subsection{Top-level fields}

A PFA document is a serialized JSON object representing an executable scoring engine.  Only the following JSON object member names may appear at this JSON nesting level.  These are the top-level fields referred to in the \hyperlink{hsec:conformance}{conformance section} of this specification.  Three fields, {\PFAc action}, {\PFAc input}, and {\PFAc output}, are required for every PFA document and are therefore required for every PFA implementation.  The rest are optional for PFA documents and not strictly required for PFA implementations.  As explained in the conformance section, not implementing some top-level fields can make some special forms and functions unimplementable.

\begin{allowedfields}
\item[\PFAc name:] A string used to identify the scoring engine.
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc method:] A string that may be ``map'', ``emit'', or ``fold'' (\hyperlink{hsec:method}{see Sec.~\ref{sec:method}}).  If absent, the default value is ``map''.
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc input:] An Avro schema representing the data type of data provided to the scoring engine (\hyperlink{hsec:input-output}{see Sec.~\ref{sec:input-output}}).
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc output:] An Avro schema representing the data type of data produced by the scoring engine (\hyperlink{hsec:input-output}{see Sec.~\ref{sec:input-output}}).  The way that output is returned to the host system depends on the {\PFAc method}.
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc begin:] An \hyperlink{hsec:expressions}{expression} or JSON array of \hyperlink{hsec:expressions}{expressions} that are executed in the begin phase of the scoring engine's run (\hyperlink{hsec:phases}{see Sec.~\ref{sec:phases}}).
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc action:] An \hyperlink{hsec:expressions}{expression} or JSON array of \hyperlink{hsec:expressions}{expressions} that are executed for each input datum in the active phase of the scoring engine's run (\hyperlink{hsec:phases}{see Sec.~\ref{sec:phases}}).
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc end:] An \hyperlink{hsec:expressions}{expression} or JSON array of \hyperlink{hsec:expressions}{expressions} that are executed in the end phase of the scoring engine's run (\hyperlink{hsec:phases}{see Sec.~\ref{sec:phases}}).
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc fcns:] A JSON object whose member values are \hyperlink{hsec:fcndef}{function definitions}, defining routines that may be called by expressions in {\PFAc begin}, {\PFAc action}, {\PFAc end}, or by expressions in other functions.
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc zero:] Embedded JSON data whose type must match the {\PFAc output} type of the engine.  This must be present in the ``fold'' {\PFAc method} initialize the fold aggregation, and it must not be present in the ``map'' or ``emit'' {\PFAc method}.
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc merge:] An \hyperlink{hsec:expressions}{expression} or JSON array of \hyperlink{hsec:expressions}{expressions} that may be executed if the scoring engine container needs to combine partial results from independent ``fold'' engines.  It must be present with the ``fold'' {\PFAc method} and it must not be present with the ``map'' or ``emit'' {\PFAc method}.
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc cells:] A JSON object whose member values specify statically allocated, named, typed units of persistent state or embedded data (\hyperlink{hsec:state}{see Sec.~\ref{sec:state}}).  The format of this JSON object is restricted: \hyperlink{hsec:cells-pools}{see Sec.~\ref{sec:cells-pools}}.
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc pools:] A JSON object whose member values specify dynamically allocated namespaces of typed persistent state (\hyperlink{hsec:state}{see Sec.~\ref{sec:state}}).  The format of this JSON object is restricted: \hyperlink{hsec:cells-pools}{see Sec.~\ref{sec:cells-pools}}.
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc randseed:] An integer which, if present, sets the seed for pseudorandom number generation (\hyperlink{hsec:method}{see Sec.~\ref{sec:random}}).
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc doc:] A string used to describe the scoring engine or its provenance (has no effect on calculations).
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc version:] An optional integer to use in model-version bookkeeping.
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc metadata:] A JSON object mapping strings to strings; used to describe the scoring engine or its provenance.
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc options:] A JSON object of JSON objects, arrays, strings, numbers, booleans, or nulls used to control execution.
\end{allowedfields}

\noindent \begin{minipage}{\linewidth}
\begin{example}
This is the simplest possible PFA document.  It only reads {\PFAc null} values, returns {\PFAc null} values, and performs no calculations.
\begin{json}
{"input": "null", "output": "null", "action": null}
\end{json}
\end{example}
\end{minipage}

\begin{example}
This is a simple yet non-degenerate PFA document.  It increments numerical input by 1.
\begin{json}
{"input": "double", "output": "double", "action": {"+": ["input", 1]}}
\end{json}
\end{example}

\begin{example}
This example implements a small decision tree.  Input data are records with three fields: ``one'' (integer), ``two'' (double), and ``three'' (string).  The decision tree is stored in a cell named ``tree'' with type ``TreeNode''.  The tree has three binary splits (four leaves).  The scoring engine walks from the root to a leaf for each input datum, choosing a path based on values found in the record's fields, and returns the string it finds at the tree's leaf.  (See the definitions of the \hyperlink{model.tree.simpleWalk}{model.tree.simpleWalk} and \hyperlink{model.tree.simpleTest}{model.tree.simpleTest} functions.)
\begin{json}
{"input": {"type": "record", "name": "Datum", "fields":
   [{"name": "one", "type": "int"},
    {"name": "two", "type": "double"},
    {"name": "three", "type": "string"}]},
 "output": "string",
 "cells": {"tree":
             {"type":
               {"type": "record",
                "name": "TreeNode",
                "fields": [
                  {"name": "field", "type":
                    {"type": "enum", "name": "TreeFields", "symbols":
                      ["one", "two", "three"]}}
                  {"name": "operator", "type": "string"},
                  {"name": "value", "type": ["double", "string"]},
                  {"name": "pass", "type": ["string", "TreeNode"]},
                  {"name": "fail", "type": ["string", "TreeNode"]}]},
              "init":
                {"field": "one",
                 "operator": "<",
                 "value": {"double": 12},
                 "pass":
                   {"TreeNode":
                     {"field": "two",
                      "operator": ">",
                      "value": {"double": 3.5},
                      "pass": {"string": "yes-yes"},
                      "fail": {"string": "yes-no"}}},
                 "fail":
                   {"TreeNode":
                     {"field": "three",
                      "operator": "==",
                      "value": {"string": "TEST"},
                      "pass": {"string": "no-yes"},
                      "fail": {"string": "no-no"}}}}}},
\end{json}
\begin{json}
 "action":
   {"model.tree.simpleWalk": [
     "input",
     {"cell": "tree"},
     {"params": [{"d": "Datum"}, {"t": "TreeNode"}],
      "ret": "boolean",
      "do": {"model.tree.simpleTest": ["d", "t"]}}
   ]}}
\end{json}
\end{example}

\hypertarget{hsec:cells-pools}{}
\subsection{Cells and Pools}
\label{sec:cells-pools}

The {\PFAc cells} and {\PFAc pools} top-level fields, if present, are JSON objects whose member values are cell-specifications or pool-specifications, respectively.  A cell is a mutable, global data store that holds a single value with a specific type, and a pool is a mutable map from dynamically allocated names to values of a specific type (\hyperlink{hsec:state}{see Sec.~\ref{sec:state}}).

A cell-specification is a JSON object with the following fields.
\begin{allowedfields}
\item[\PFAc type:] {\it (required)} An Avro schema representing the data type of this cell.
\item[\PFAc init:] {\it (required)} If {\PFAc source} (below) is ``embedded'' or not provided, then this is the initial value of the cell as embedded JSON, matching {\PFAc type}. If {\PFAc source} is ``json'' or ``avro'', this is a file name or URL pointing to the initial value of the cell. The file name may be relative or absolute and is formatted for the target operating system (e.g. UNIX-formatted with forward slashes or Windows-formatted with backslashes). It is interpreted as a URL if the whole string matches the following pattern: {\PFAc [a-zA-Z][a-zA-Z0-9\textbackslash+\textbackslash-\textbackslash.]*://.*} (the first character is a letter, followed by letters or plus, hyphen, or dot, followed by colon-slash-slash and arbitrary text until the end of the string).
\item[\PFAc shared:] An optional boolean specifying whether this cell is thread-local to one scoring engine or shared among a battery of similar engines (\hyperlink{hsec:concurrent}{see Sec.~\ref{sec:concurrent}}).  The default is {\PFAc false}.
\item[\PFAc rollback:] An optional boolean specifying whether this cell should be rolled back to the state it had at the beginning of an {\PFAc action} if an \hyperlink{hsec:exceptions}{exception} occurs during the {\PFAc action}.  The default is {\PFAc false}, and {\PFAc shared} and {\PFAc rollback} are mutually incompatible: they cannot both be {\PFAc true}.
\item[\PFAc source:] An optional string specifying whether the {\PFAc init} data is ``embedded'' (the default), ``json'' (formatted exactly like ``embedded'', but in an external file or resource), or ``avro'' (Avro formatted in an external file or resource). The data, once retrieved, must have a type that matches {\PFAc type}.
\end{allowedfields}

A pool-specification is a JSON object with the following fields.
\begin{allowedfields}
\item[\PFAc type:] {\it (required)} An Avro schema representing the data type of an item within this pool. The whole pool is effectively a map of this type.
\item[\PFAc init:] Same as {\PFAc init} for cells, but it is not required for pools. If omitted, a value of \PFAc{\{\}} is assumed.
\item[\PFAc shared:] Same as {\PFAc shared} for cells.
\item[\PFAc rollback:] Same as {\PFAc rollback} for cells.
\item[\PFAc source:] Same as {\PFAc source} for cells.
\end{allowedfields}

Cell and pool names must match the following pattern: {\PFAc [A-Za-z\_][A-Za-z0-9\_]*} (the first character must be a letter or underscore; subsequent characters, if they exist, may also be numbers).  Cells and pools do not share a namespace with each other or with symbols or functions.

A complete explanation of cells and pools is given in \hyperlink{hsec:state}{Sec.~\ref{sec:state}}.

\subsection{Locator marks}

PFA documents are usually generated by an automated process, such as by encoding a machine learning decider into a scoring engine or by transforming user functions from an easily readable language into the terse PFA representation.  In the latter case, there can be a cognitive disconnect between the language in which the user writes code, for instance a regression fit function written in Python, and the auto-generated PFA.  In particular, if there is an error in the generated PFA due to an error in the original source code, reporting the error at the line and column number of the generated PFA would not be useful for the Python programmer.  It would be much better if a PFA system could report such an error at the location of the offending line in the original source code.

To allow individual PFA systems to do this, the PFA specification allows for ``@'' as a JSON member name in any JSON object in the PFA document.  The associated member value must be a string, and would ordinarily be a description of the line number of the original source that generated that JSON object in the PFA document.  These ``@'' key-value pairs can appear in any object at any level, including Avro type schemae and embedded JSON data.  If the library that interprets Avro type schemae and embedded JSON data does not ignore object members named ``@'', then the PFA system must strip these objects before passing the JSON objects for interpretation.

The generation of and meaning of these locator marks are beyond the scope of the PFA specification--- different PFA systems can generate and interpret them differently, or not at all.  However, to ensure that the locator marks made by one system do not cause unnecessary errors in another system, the locator marks must abide by the following rules.
\begin{itemize}
\item JSON object members named ``@'' must not cause errors in any PFA system, even if they appear in Avro type schemae or embedded JSON objects.
\item The value associated with this key must be a string.
\item The system that generates these marks should place them at the beginning of each JSON object--- that is, in the serialized form of the JSON data, the ``@'' member name should appear immediately after the ``\{`` character that starts the JSON object (apart from any whitespace).  This is because some PFA readers may interpret the JSON data as it streams into a buffer, and they may encounter an error before reaching the last JSON object member.  If the locator mark is not first, PFA systems cannot be expected to use it.
\end{itemize}

\pagebreak

\section{Scoring engine execution model}

A PFA document (string of JSON-formatted text) describes a PFA scoring engine (executable routine) or a battery of initially identical engines.  An engine behaves as a single-threaded executable with global state (cells and pools) and local variables.  A battery of scoring engines may run in parallel and only share data if some cells or pools are explicitly marked as {\PFAc shared}.  Although a battery of scoring engines generated by a single PFA document start in exactly the same state, they may evolve into different states if they have any unshared cells or pools.

PFA engines are units of work that may fit into a pipeline system like Hadoop, Storm, or Akka.  In a map-reduce framework such as Hadoop, for instance, one PFA document could describe the calculation performed by all of the mappers and another could describe the calculation performed by all of the reducers.  The mappers are a battery of independent PFA engines, as are the reducers.  In pure map-reduce, the mappers would not communicate with each other and the reducers would not communicate with each other, so none of the cells or pools should be marked as {\PFAc shared}.  With this separation of concerns, issues of transferring data, interpreting input file types, and formatting output should be handled by the pipeline system (Hadoop in this case) while the mathematical procedure is handled by PFA.  Changing file formats would require an update to the pipeline code (and possibly a code review), but changing details of the analytic would only require a new PFA document (a JSON configuration file).

\hypertarget{hsec:phases}{}
\subsection{Execution phases of a PFA scoring engine}
\label{sec:phases}

A PFA engine has a 7 phase lifecycle.  These phases are the following, executed in this order:

\begin{enumerate}
\item reading the PFA document and performing a syntax check;
\item verifying PFA invariants and checking type consistency;
\item additional checks, constraints required by a particular PFA system;
\item initialization of the engine;
\item execution of the {\PFAc begin} routine;
\item execution of the {\PFAc action} routine for each input datum;
\item execution of the {\PFAc end} routine.
\end{enumerate}

In phase 1, JSON is decoded and may be used to build an abstract syntax tree of the whole document.  At this stage, JSON types must be correctly matched (e.g.\ if a number is expected, a string cannot be provided instead) to build the syntax tree.  Incorrectly formatted JSON should also be rejected, though we recommend that a dedicated JSON decoder is used for this task.  Avro schemae should also be interpreted in this phase (see \hyperlink{hsec:avro-types}{Sec.~\ref{sec:avro-types}}).

In phase 2, the loaded PFA document is interpreted as an executable.  If the specific PFA implementation builds code with macros, compiles bytecode, or synthesizes a circuit for execution, that work should happen in this phase.  Data types should be inferred and checked (see \hyperlink{hsec:type-inference}{Sec.~\ref{sec:type-inference}}), especially if the executable is compiled.

Phase 3 is provided for optional checks.  Due to limitations of a particular environment, some PFA systems may need to be more restrictive than the general specification and reject what would otherwise be a valid PFA document.  Reasons include unimplemented function calls, inability to implement recursion, or data structures that are too large.  The phase 3 checks may need to be performed concurrently with the phase 2 checks to build the executable.

Phase 4, initialization, is when data structures such as cells and pools are allocated and filled, network connections are established (if relevant for a particular PFA implementation), pseudorandom number generators are seeded, etc.  These are actions that the engine must perform to work properly but are not a part of the {\PFAc begin}, {\PFAc action}, or {\PFAc end} routines.

The actions performed in the last three phases, {\PFAc begin}, {\PFAc action}, and {\PFAc end}, are explicitly defined in the PFA document.  A PFA system must implement the {\PFAc action} phase, since every PFA document must define an {\PFAc action}.  The {\PFAc action} accepts input and returns output, though the way it does so depends on the {\PFAc method} (\hyperlink{hsec:method}{Sec.~\ref{sec:method}}).

The {\PFAc begin} and {\PFAc end} phases do not accept input and do not return output: they can only modify cells and pools, emit log messages, or raise exceptions.  A PFA system is not required to implement {\PFAc begin} and {\PFAc end}.  If a system that does not implement {\PFAc begin} encounters a document that has a {\PFAc begin} routine, it must fail with an error.  If a system that does not implement {\PFAc end} encounters a document that has an {\PFAc end} routine, it need not fail with an error, though it may.  This is because some PFA documents may use {\PFAc begin} to initialize essential data structures and the {\PFAc action} would only function properly if {\PFAc begin} has been executed, but the {\PFAc end} routine can only affect the state of a completed scoring engine whose interpretation is implementation-specific.  Moreover, some data pipelines do not even have a concept of completion, such as Storm.

After all input data have been passed to the scoring engine and the last {\PFAc action} or {\PFAc end} routine has finished, the scoring engine is said to be completed.  This may be considered an eighth phase of the engine, though its behavior at this point is not defined by this specification.  A particular PFA system may extract aggregated results from a completed engine's state and it may even call functions defined in the document's {\PFAc fcn} field, but this is beyond the scope of the standard PFA lifecycle.  (Note: if the primary purpose of a scoring engine is to aggregate data, consider using the ``fold'' {\PFAc method} instead of extracting from the engine's internal state.)

A completed scoring engine may be used to create a new PFA document, in which the final state of the cells and pools are used to define the {\PFAc cell} {\PFAc init} or {\PFAc pool} {\PFAc init} of the new document, such that a new scoring engine would start where the old one left off.  A PFA system may even re-use an old scoring engine as a new scoring engine (repeating phase 4 onward), but a re-used engine must behave exactly like a new engine with copied state, such that the re-use is an implementation detail and does not affect behavior.

A PFA system may call functions defined in the document's {\PFAc fcn} field at any time, but if the function modifies state (a ``cell-to'', ``pool-to'', or ``pool-del'' special form is reachable in its call graph) and the engine is not complete, the function call must not be allowed because it could affect the engine's behavior.  A PFA system must not execute {\PFAc begin}, {\PFAc action}, or {\PFAc end} outside of its lifecycle.

\hypertarget{hsec:method}{}
\subsection{Scoring method: map, emit, and fold}
\label{sec:method}

PFA defines the following three methods for calling the {\PFAc action} routine of a scoring engine.
\begin{allowedfields}
\item[``map'':] The {\PFAc action} routine is given an {\PFAc input} value, which it uses to construct and return an output.  Barring \hyperlink{hsec:exceptions}{exceptions}, the output dataset would have exactly as many values as the input dataset.
\end{allowedfields}
\begin{allowedfields}
\item[``emit'':] The {\PFAc action} routine is given an {\PFAc input} value and an {\PFAc emit} callback function, and the functional return value is ignored.  The scoring engine returns results to the host system by calling {\PFAc emit}.  It can call {\PFAc emit} any number of times, and thus the output dataset may be smaller or larger than the input dataset.  For example, a filter would call {\PFAc emit} zero or one times for each input.
\end{allowedfields}
\begin{allowedfields}
\item[``fold'':] The {\PFAc action} routine is given an {\PFAc input} value and a {\PFAc tally} value, which it uses to construct and return an output.  The first time {\PFAc action} is invoked, {\PFAc tally} is equal to {\PFAc zero} (the top-level field).  On the $N^{\mbox{\scriptsize th}}$ time {\PFAc action} is invoked, {\PFAc tally} is equal to the $(N - 1)^{\mbox{\scriptsize th}}$ return value.  Thus, a ``fold'' scoring engine is an aggregator: transformed inputs may be counted, summed, maximized, or otherwise accumulated in the {\PFAc tally}.  The aggregate of the entire dataset seen by one scoring engine instance is the last return value of {\PFAc action}.  The host system may then combine partial results from these instances using the {\PFAc merge} method.  The {\PFAc merge} method must be present for ``fold'' scoring engines, though it might not be used.
\end{allowedfields}

For all three methods, the {\PFAc input} is available to expressions as a read-only symbol that can be accessed in an expression as the JSON string {\PFAc "input"} (see \hyperlink{hsec:symbol-ref}{Sec.~\ref{sec:symbol-ref}}).  The {\PFAc input} symbol's scope is limited to the {\PFAc action} routine: it is not accessible in user-defined functions unless explicitly passed.  The {\PFAc input} symbol's data type is specified by the top-level field named {\PFAc input}.

For the ``map'' and ``fold'' methods, the data type of the last expression in the {\PFAc action} routine must be the type specified by the top-level field named {\PFAc output}.  For the ``emit'' method, there is no constraint on the type of the last expression in {\PFAc action}, but the argument passed to the {\PFAc emit} function must have {\PFAc output} type.

For the ``emit'' method, the {\PFAc emit} function is a globally accessible function.  It may be \hyperlink{hsec:function-call}{called} or \hyperlink{hsec:fcnref}{referenced} without qualification by any user-defined function or even in the {\PFAc begin} and {\PFAc end} routines.

For the ``fold'' method, the {\PFAc tally} is available to expressions as a read-only symbol that can be accessed in an expression as the JSON string {\PFAc "tally"} (see \hyperlink{hsec:symbol-ref}{Sec.~\ref{sec:symbol-ref}}).  The {\PFAc tally} symbol's scope is limited to the {\PFAc action} routine: it is not accessible in user-defined functions unless explicitly passed.  The {\PFAc tally} symbol's data type is specified by the {\PFAc output} top-level field.  The top-level field named {\PFAc zero} must also have {\PFAc output} type.

In the {\PFAc merge} method, available only to ``fold'' engines, the symbols {\PFAc tallyOne} and {\PFAc tallyTwo} are read-only symbols that can be accessed in the expression.  They have {\PFAc output} type, and usually come from independent runs of the scoring engine on subsamples.  Just as calling a scoring engine's {\PFAc action} method replaces its {\PFAc tally} with the {\PFAc action} output, calling a scoring engine's {\PFAc merge} method replaces its {\PFAc tally} with the {\PFAc merge} result.

The means by which input values are provided to the scoring engine, output values are retrieved, and the {\PFAc emit} function is set or changed are all unspecified.  A PFA system may change the {\PFAc emit} function at any time, even while an {\PFAc action} is being processed (though we do not recommend this).  However, the {\PFAc emit} function must be defined and callable at all times during the {\PFAc begin}, {\PFAc action}, and {\PFAc end} phases of the scoring engine's lifecycle.

\hypertarget{hsec:predefs}{}
\subsection{Predefined symbols}
\label{sec:predefs}

A small set of symbols are already defined when a {\PFAc begin}, {\PFAc action}, or {\PFAc end} method starts.  These symbols cannot be changed by the method; it is as though the method is executed in a sealed scope within the scope in which the predefined symbols are defined (\hyperlink{hsec:symbol-scope}{see Sec.~\ref{sec:symbol-scope}}).

\noindent The predefined symbols in the {\PFAc begin} method are the following.
\begin{itemize}
\item {\PFAc name} (string): If the {\PFAc name} top-level field is present, this is that string; otherwise, it is the name that the host system has assigned.
\item {\PFAc instance} (int): The 0-based instance number of the scoring engine.  For example, if $N$ engines are generated from a PFA document, they will be numbered from $0$ to $N-1$, inclusive.
\item {\PFAc version} (int): If the {\PFAc version} top-level field is present, this symbol is defined and is equal to the top-level field; otherwise, it is not defined.
\item {\PFAc metadata} (map of string): If the {\PFAc metadata} top-level field is present, this symbol is that string-to-string map; otherwise, it is an empty string-to-string map.
\end{itemize}

\noindent The predefined symbols in the {\PFAc action} method are the following.
\begin{itemize}
\item {\PFAc input} (type defined by top-level field {\PFAc input}): The input datum on which the {\PFAc action} method acts.
\item {\PFAc tally} (type defined by top-level field {\PFAc output}): If the {\PFAc method} is ``fold'', this is the result of applying all actions to date for this scoring engine instance; otherwise, it is not defined.
\item {\PFAc name}, {\PFAc instance}, {\PFAc version}, {\PFAc metadata}: As above.
\item {\PFAc actionsStarted} (long): The number of times this scoring engine instance has {\it started} to process an input record.  It is always greater than or equal to 1 and it includes action attempts that have failed due to exceptions.
\item {\PFAc actionsFinished} (long): The number of times this scoring engine instance has {\it successfully finished} processing an input record.  It is always greater than or equal to 0 and it does not include action attempts that have failed due to exceptions.
\end{itemize}

\noindent The predefined symbols in the {\PFAc end} method are the following.
\begin{itemize}
\item {\PFAc tally}, {\PFAc name}, {\PFAc instance}, {\PFAc version}, {\PFAc metadata}, {\PFAc actionsStarted}, {\PFAc actionsFinished}: As above.
\end{itemize}

\hypertarget{hsec:input-output}{}
\subsection{Input and output type specification}
\label{sec:input-output}

The member values of the top-level fields {\PFAc input} and {\PFAc output} are Avro schemae (see \hyperlink{hsec:avro-types}{Sec.~\ref{sec:avro-types}}).  The way that these types constrain the input and output of scoring engines depends on the {\PFAc method} and is described in \hyperlink{hsec:method}{Sec.~\ref{sec:method}}.

The input data provided to the scoring engine must conform to the {\PFAc input} type in the sense that there must be an unambiguous way to generate it from Avro-encoded data, though this conversion need not actually take place.  For example, if the {\PFAc input} is {\PFAc \{"type":$\!$ "array", "items":$\!$ "int"\}}, then the values passed to the scoring engine must be ordered lists of integers, though they may be implemented as arrays, linked lists, immutable vectors, or any other functionally equivalent data structure that the PFA implementation is capable of using in calculations.  The data source need not be Avro-encoded; the Avro schema is only used to specify the type, not to perform conversions.  Similarly, the output data must conform to the {\PFAc output} type in the sense that there must be an unambiguous way to convert it to Avro-encoded data, though this conversion need not actually take place.

Given that the input and output types are described by Avro schemae, the Avro binary and JSON data formats would be particularly convenient ways to read and write data.  However, there is no requirement that a PFA system should have this capability.  Data conversion and internal data format are both outside the scope of the PFA specification.

\hypertarget{hsec:state}{}
\subsection{Persistent state: cells and pools}
\label{sec:state}

PFA defines two mechanisms to maintain state: cells and pools.  Cells are global variables with a fixed name and type that must be initialized before the scoring engine's run begins.  A cell's value can change to a new value of the same type, but the cell cannot be deleted and new cells cannot be created during the scoring engine's run.  Pools are global namespaces with a fixed type.  New named values can be created within a pool at runtime, as long as they have the correct type, and old values can be deleted at runtime.

A pool of type ``{\PFAtp X}'' would be equivalent to a cell whose type is ``map of {\PFAtp X}'' except for performance and concurrency issues.  All special forms and library functions in the PFA specification treat data structures as immutable objects (\hyperlink{hsec:immutable}{see Sec.~\ref{sec:immutable}}), but scoring engines often need to maintain very large key-value tables.  If pools were not available, a PFA implementation would either incur a performance penalty if it maintained a large map in a cell as an immutable object or if it maintained all temporary variables as mutable objects.  With both cells and pools, a PFA implementation may maintain all values as immutable objects, including cells, and maintain pools as mutable maps of immutable objects.  \hyperlink{hsec:concurrent}{See Sec.~\ref{sec:concurrent}} for a discussion of concurrency issues in cells and pools.

Cells can only be accessed through the ``cell'' special form and can only be modified through the ``cell-to'' special form.  Pools can only be accessed through the ``pool'' special form and modified through the ``pool-to'' and ``pool-del'' special forms (\hyperlink{hsec:cell-pool-forms}{see Sec.~\ref{sec:cell-pool-forms}}).

One common use of persistent state is to represent a complex statistical model, such as a large decision tree.  In most cases, such a model is constant during the scoring engine's run, and this constraint may be enforced through static analysis if the model is stored in a cell.  Another common use is to represent recent or accumulated data in a table, indexed by key.  In most cases, this table is updated frequently and new table entries may be added at any time.  Furthermore, it is often useful to distribute the table-fill operation among a battery of concurrent scoring engines, with different engines modifying different keys at the same time.  These cases are more easily implemented as pools or shared pools.

\hypertarget{hsec:concurrent}{}
\subsection{Concurrent access to shared state}
\label{sec:concurrent}

If the {\PFAc shared} member of a cell or pool's specification is {\PFAc true}, the cell or pool is not assumed to be thread-local (\hyperlink{hsec:cells-pools}{see Sec.~\ref{sec:cells-pools}}).  It may be shared among a battery of identical scoring engines in a multi-threaded process, shared among identical scoring engines distributed across a network, shared in a database among different types of processes, or shared among components of an integrated circuit, etc.  In any case, some rules must be followed to avoid simultaneous attempts to modify the data, and these rules must be standardized to ensure that the same scoring engine has the same behavior on different systems.

Shared cells and pools in PFA follow a read-copy-update rule for concurrent access: attempts to read the shared resource (through the ``cell'' or ``pool'' special forms) always succeed without blocking and attempts to write (through the ``cell-to'', ``pool-to'', and ``pool-del'' special forms) lock the resource or wait until another writer's lock is released.  The writers must operate on a copy of the cell or pool's data (or on immutable data) so that readers can access the old version during the update process.  The new value must be updated atomically at the end of the update process.

Although an update operation may only modify a part of the cell's structure (one value in an array, for instance), the granularity of the writers' lock is the entire cell: two writers must not be able to modify different parts of the same cell at the same time.  The granularity of the writers' lock on pools is limited to a single named entity within the pool: two writers must be able to modify different entities in the pool at the same time, but not different parts of the same named entity.

The ``cell-to'' and ``pool-to'' special forms accept user-defined update functions (\hyperlink{hsec:cell-pool-forms}{see Sec.~\ref{sec:cell-pool-forms}}) but these functions must not directly or indirectly call ``cell-to'', ``pool-to'', or ``pool-del'' because such a situation could lead to deadlock.  This rule can be enforced by examining the call graph.

\hypertarget{hsec:exceptions}{}
\subsection{Exceptions}
\label{sec:exceptions}

As much as is reasonably possible, PFA documents can be statically analyzed to avoid errors at runtime.  However, some error states cannot be predicted without runtime information.  These error states, their exact messages, and numerical codes are explicitly defined for each susceptible special form and library function.  If the specified error conditions are met in the {\PFAc begin} routine of a scoring engine, processing stops and should not continue to the {\PFAc action} routine.  If error conditions occur when the {\PFAc action} routine is processing an input datum, processing of that datum stops and may either continue to the next datum or stop the scoring engine entirely.  The PFA host may choose to stop or continue on the basis of the error message or code.  If error conditions occur in the {\PFAc end} routine, processing stops.

This abrupt end of processing may occur deep in an \hyperlink{hsec:expressions}{expression} or array of \hyperlink{hsec:expressions}{expressions} and behaves like an exception: control flow exits the routine immediately upon encountering the error condition and is either caught by the host system or it halts the process.  In environments where this is difficult to implement, control flow may continue to the end of the routine, but side-effects such as modifications to persistent state and \hyperlink{hsec:logs}{log messages} must be avoided.

If the host system catches an exception in {\PFAc action} and continues to the next datum, and if a cell or pool's {\PFAc rollback} member is {\PFAc true}, then that cell or pool should be reverted to the value that it had at the beginning of the {\PFAc action} (\hyperlink{hsec:cells-pools}{see Sec.~\ref{sec:cells-pools}}).  If the {\PFAc rollback} member is absent or {\PFAc false}, then the cell or pool's value at the start of the next {\PFAc action} should be the value it had at the time of the exception.

In addition to exceptions raised by special forms and library functions, a PFA document can raise custom exceptions with the ``error'' special form (\hyperlink{hsec:exception-form}{see Sec.~\ref{sec:exception-form}}).  The rules described above apply equally to custom exceptions, though we recommend that PFA systems differentiate between built-in exceptions (whose error messages are explicitly defined by this specification) and custom exceptions (whose error messages are free-form).  Code numbers for user-defined errors must be negative.

If a {\PFAc timeout} is defined in the PFA document's {\PFAc options} or is imposed by the PFA system, a {\PFAc begin}, {\PFAc action}, or {\PFAc end} routine that exceeds this timeout raises an exception with the message ``exceeded timeout of $N$ milliseconds'' where $N$ is the relevant timeout.  Timeout exceptions follow the same rules as built-in and custom exceptions.

If possible in a given system, no exceptions other than PFA exceptions should ever be raised while executing a {\PFAc begin}, {\PFAc action}, or {\PFAc end} routine.

\hypertarget{hsec:options}{}
\subsection{Execution options}
\label{sec:options}

The {\PFAc options} top-level field allows PFA documents to request that they are executed in a particular way.  However, the PFA system may override any of these options with its own values, or with the defaults.  When overriding an option, the PFA system should somehow indicate that this is the case, possibly through a log message.

Example options, their JSON types, and their default values are given below.  If a PFA document attempts to set an option with the wrong type, it is a semantic error (phase 2 in \hyperlink{hsec:phases}{see Sec.~\ref{sec:phases}}) and the scoring engine should not be started. Unrecognized options are ignored.

\noindent\begin{longtable}{p{0.23\linewidth} p{0.12\linewidth} p{0.14\linewidth} p{0.4\linewidth}}
{\bf Option name} & {\bf JSON type} & {\bf Default value} & {\bf Description} \\\hline\endhead
{\PFAc timeout} & integer & $-1$ & Number of milliseconds to let the {\PFAc begin}, {\PFAc action}, or {\PFAc end} routine run; at or after this time, the PFA system may stop the routine with an exception (\hyperlink{hsec:exceptions}{see Sec.~\ref{sec:exceptions}}).  If negative, the execution has no timeout. \\
{\PFAc timeout.begin} & integer & {\PFAc timeout} & A specific timeout for the {\PFAc begin} routine that overrides the general {\PFAc timeout}. \\
{\PFAc timeout.action} & integer & {\PFAc timeout} & A specific timeout for the {\PFAc action} routine that overrides the general {\PFAc timeout}. \\
{\PFAc timeout.end} & integer & {\PFAc timeout} & A specific timeout for the {\PFAc end} routine that overrides the general {\PFAc timeout}. \\
\end{longtable}

\hypertarget{hsec:random}{}
\subsection{Pseudorandom number management}
\label{sec:random}

The {\PFAc randseed} top-level field specifies a seed for library functions that generate pseudorandom numbers.  If the {\PFAc randseed} is absent, the random number generator should be unpredictable: multiple runs of the same PFA document would yield different results if the output depends on pseudorandom numbers.  If a {\PFAc randseed} is provided, the random number generator should be predictable: multiple runs of the same PFA document would yield the same results on the same system.  Explicitly setting a {\PFAc randseed} is useful for tests.

The pseudorandom number generator maintains state between {\PFAc begin}, {\PFAc action}, and {\PFAc end} invocations: the generator is not reseeded with each call.  If a PFA document is used to create a battery of identical scoring engines, the {\PFAc randseed} is used to generate different seeds for all of the scoring engines: they are not guaranteed to produce identical results.

The algorithm for generating pseudorandom numbers is not specified, so different PFA implementations may use different algorithms.  Therefore, a PFA document with an explicit {\PFAc randseed} is only guaranteed to yield identical results when rerun on the same system.  On different systems, it may yield different results.

Every library function that depends on pseudorandom numbers should be seeded by the {\PFAc randseed}.  Pseudorandom functions are explicitly denoted by this specification.

\pagebreak

\section{Type system}

Rather than invent a new type system, PFA uses Avro type schemae to describe its data types.  Avro is a serialization format, but it also describes the types (sets of possible values) that are to be serialized or unserialized with JSON-based schemae.  Feeding Avro-formatted data into and out of a PFA scoring engine is particularly easy, since the sets of possible values that can be Avro-serialized perfectly align with the sets of possible values that PFA can use in its calculations.

However, Avro serialization is by no means necessary to use with PFA: data that can be described by Avro types can be serialized many different ways.  In fact, the Avro project provides two: a binary format and a JSON format.  With the appropriate translations, CSV can be converted to and from a subset of Avro types, XML can be fully and reversibly transformed, as can many popular data formats.  The transformation of data formats and the internal representation of data in a PFA implementation are beyond the scope of this specification and should be handled in any way that the designer of a PFA system sees fit.

\hypertarget{hsec:avro-types}{}
\subsection{Avro types}
\label{sec:avro-types}

The normative definition of Avro 1.7.6 types and type schemae is \href{http://avro.apache.org/docs/1.7.6/spec.html}{provided online}.  However, the basics are duplicated here for convenience.  This section is non-normative.

The set of all expressible types is the closure under the following primitives and parameterized types.
\begin{allowedfields}
\item[null:] A type with only one value, {\PFAc null}.  This is a unit type, and is usually only useful when combined with other types in a union (see below) or as a return type for functions that do not have a meaningful value to return.
\item[boolean:] A type with only two values, {\PFAc true} and {\PFAc false}.
\item[int:] Signed whole numbers with a 32-bit range: from $-2147483648$ to $2147483647$ inclusive.
\item[long:] Signed whole numbers with a 64-bit range: from $-9223372036854775808$ to $9223372036854775807$ inclusive.
\item[float:] Signed fractional numbers with 32-bit binary precision as defined by \href{http://dx.doi.org/10.1109%2FIEEESTD.2008.4610935}{IEEE 754}.
\item[double:] Signed fractional numbers with 64-bit binary precision according to the same standard.
\item[string:] Strings of text characters that can be encoded in \href{http://www.unicode.org/standard/standard.html}{Unicode}.
\item[bytes:] Arrays of uninterpreted bytes with any length.
\item[fixed({\PFAtp L}, {\PFAtp N}, {\PFAtp NS}):] Named arrays of uninterpreted bytes with length {\PFAtp L} (integer), name {\PFAtp N} (string), and optional namespace {\PFAtp NS} (string).
\item[enum({\PFAtp S}, {\PFAtp N}, {\PFAtp NS}):] Named enumeration of a finite set of symbols {\PFAtp S} (ordered list of strings), name {\PFAtp N} (string), and optional namespace {\PFAtp NS} (string).
\item[array({\PFAtp X}):] Homogeneous array of type {\PFAtp X} (Avro type) with any length.
\item[map({\PFAtp X}):] Homogeneous map from strings to type {\PFAtp X} (Avro type).  The keys of all maps must be strings (just like JSON).
\item[record({\PFAtp F}, {\PFAtp N}, {\PFAtp NS}):] Heterogeneous record of fields {\PFAtp F} (named slots with Avro types) with name {\PFAtp N} (string) and optional namespace {\PFAtp NS} (string).  This is a product type; the possible values that it can have is the Cartesian product of the possible values that each field can have.
\end{allowedfields}
\begin{allowedfields}
\item[union({\PFAtp T}):] Union of types {\PFAtp T} (array of Avro types).  This is a sum type; the possible values that it can have is union of the values of each type in {\PFAtp T}.
\end{allowedfields}

\noindent\begin{minipage}{\linewidth}
\indent This type system has the following limitations and remediations.
\begin{itemize}
\item Arrays and maps must be homogeneous (all elements have the same, specified type).  This is sufficient for most mathematical applications and the restriction helps to eliminate common mistakes.  Also, it makes some significant optimizations possible that are difficult or impossible in dynamic languages.
\end{itemize}
\end{minipage}

\vspace{-0.15 cm}
\begin{itemize}
\item Map keys must be strings.  If an application must represent a map whose keys are not strings, one can define a unique string representation for each key and look up items by first transforming to the string representation.

\item There is no set or multiset type.  This can be emulated with arrays and PFA's \hyperlink{hsec:set-like}{set-like functions} or a map from string-valued keys to {\PFAc null}.

\item Circular references are not possible, as there are no pointers or references.  However, data structures with conceptual loops can be emulated through weak references in a map.  For example, an arbitrary directed graph can be described as a map of arrays of strings: each key is a node and each element of an array is a link to another node.  These references are weak because there is no guarantee that a key exists for every array element.

The lack of circular references is, in some ways, an advantage.  Non-circular data can be more easily serialized without the possibility of infinite loops.  Immutable data can take advantage of more structural sharing since data structures are purely tree-like.

Note that recursively defined types {\it are} possible.  A record {\PFAtp X} could have one or more fields that are unions of {\PFAtp X} and {\PFAtp Y}, or it could have a field that is an array or map of {\PFAtp X}.  The first case would describe a tree of nodes {\PFAtp X} with a fixed number of named branches, terminating in leaves of type {\PFAtp Y}.  (This is how decision trees are described in PFA; the scores have type {\PFAtp Y}.)  The second case would describe a tree of nodes {\PFAtp X} with arbitrarily many branches at each node, terminating in empty arrays or maps.

\item To make a type such as {\bf string} nullable, one must construct a union of {\bf string} and {\bf null}.  This union type cannot be passed into functions that expect a {\bf string}.

Again, this restriction can be an advantage.  It is often known as a type-safe null: in the example above, string functions can still be used, but only after explicitly handling the {\bf null} case.  In PFA, one would use a \hyperlink{hsec:casting}{cast-cases} special form to split the program flow into a branch that handles the {\bf string} case and a branch that handles the {\bf null} case, usually by specifying a rule that replaces {\PFAc null} with a string.  This restriction eliminates the possibility of null pointer exceptions at runtime.

Most library functions in PFA interpret {\PFAc null} as a missing value.  Missing value handling is an important consideration in many statistical analyses, so PFA has a \hyperlink{hsec:impute}{suite of functions} for addressing this case.
\end{itemize}

The advantages of this type system are that (1) it aligns well with types already used by major data pipeline tools (binary Avro and, with some transformation, Thrift and Protocol Buffers), (2) it is easy to represent as JSON or XML (the lack of circular references is particularly helpful), (3) any type is nullable, including primitives, (4) Avro's rules for schema resolution can be reinterpreted as type promotion for type inference (\hyperlink{hsec:type-inference}{see Sec.~\ref{sec:type-inference}}), (5) all types have a strict ordering (see \href{http://avro.apache.org/docs/1.7.6/spec.html#order}{Avro sort order specification}), and (6) the type schemae are JSON objects and strings, which fit seamlessly into a PFA document.

\subsection{Type schemae in the PFA document}

An Avro type schema can be a JSON object or a string.  JSON objects construct parameterized types, while strings specify type primitives or reference previously defined types.  Some PFA top-level fields and member values of special forms must be Avro schemae: these schema are simply included inline with the JSON representing the rest of the PFA document.

Below is a summary of the schema syntax that is relevant for PFA.  All \hyperlink{http://avro.apache.org/docs/1.7.6/spec.html}{Avro schema elements} must be accepted by a PFA reader, but these are the only ones that influence PFA.

The following strings are type primitives: ``null'', ``boolean'', ``int'', ``long'', ``float'', ``double'', ``string'', ``bytes''.  Other strings are either previously defined named types or they are invalid.  The form {\PFAc \{"type":$\!$ "X"\}} for string {\PFAtp X} is equivalent to the string on its own.

A byte array with name {\PFAtp N} and fixed length {\PFAtp L} is specified by the form {\PFAc \{"type":$\!$ "fixed", "name":$\!$ "N", "namespace":$\!$ "NS", "size":$\!$ L\}}.  The namespace is optional, but the name is not.  The length {\PFAtp L} must be a JSON integer.  Avro fixed types have additional object members, but they are not relevant for PFA.

An enumeration with name {\PFAtp N} and symbols {\PFAtp S} is specified by the form {\PFAc \{"type":$\!$ "enum", "name":$\!$ "N", "namespace":$\!$ "NS", "symbols":$\!$ S\}}.  The namespace is optional, but the name is not.  The symbols {\PFAtp S} must be a JSON array of strings.  Avro enumeration types have additional object members, but they are not relevant for PFA.

An array with elements of type {\PFAtp X} is specified by the form {\PFAc \{"type":$\!$ "array", "items":$\!$ X\}}.  An array does not accept a name or any other member values.

An map with values of type {\PFAtp X} is specified by the form {\PFAc \{"type":$\!$ "map", "values":$\!$ X\}}.  A map does not accept a name or any other member values.

A record with name {\PFAtp N} and fields {\PFAtp F} is specified by the form {\PFAc \{"type":$\!$ "record", "name":$\!$ "N", "namespace":$\!$ "NS", "fields":$\!$ F\}}.  The namespace is optional, but the name is not.  The fields {\PFAtp F} must be JSON objects with the following form: {\PFAc \{"name":$\!$ "FN", "type":$\!$ "FT", "default":$\!$ D, "order":$\!$ O\}} where {\PFAc name} and {\PFAc type} are required and {\PFAc default} and {\PFAc order} are not.  The default {\PFAtp D} is encoded in the Avro-JSON format and provides a default value if the input data stream is missing one.  The order {\PFAc O} is one of these strings: ``ascending'', ``descending'', and ``ignore'', and it defines the sort order for the record.  Avro record types and field types have additional object members, but they are not relevant for PFA.

A union of types {\PFAtp T1} \ldots {\PFAtp TN} is specified by a JSON array form {\PFAc [T \ldots\ TN]}.

If the Avro implementation used by a PFA system supports \href{http://avro.apache.org/docs/1.7.6/spec.html#Aliases}{aliases} for schema resolution, the aliases should be used for type inference (\hyperlink{hsec:type-inference}{see Sec.~\ref{sec:type-inference}}).  Aliases only apply to named types and record fields.

Avro schema parsing is usually implemented as a stateful process, in which the parser remembers previously named types and recognizes its namespace-qualified name in a JSON string as representing the type.  This is especially important for recursively defined types.  A PFA document may have many type schemae embedded within it, often as member values of JSON objects.  Systems that load JSON objects into hash-tables cannot guarantee that the order of JSON object members is preserved, which could cause schemae to be read in any order.

Therefore, PFA implementations must pass Avro schemae to be parsed in an order that resolves dependencies or PFA implementations must parse the schemae themselves in an order that resolves dependencies.  PFA documents must define named types (as a JSON object) exactly once and reference them (as a string) elsewhere.

\hypertarget{hsec:type-inference}{}
\subsection{Type inference}
\label{sec:type-inference}

PFA uses a near-minimum of type annotations for static type analysis.  Only the inputs to every calculation, which are function parameters, literal constants, inline arrays/maps/records, the symbols {\PFAc input} and {\PFAc tally}, and cell/pool definitions, and the outputs of every calculation, which are function return values and the scoring engine {\PFAc output}, need to be specified.  Unlike traditional languages (e.g.\ C or Java), the types of new variables are not specified: they are inferred through their initialization expressions (and would have been redundant if supplied).

With these annotations, the type check algorithm is simple.  Every expression is a tree of subexpressions, whose leaves are either references to previously defined symbols, function parameters, cells, or pools (with known type) or constants (with specified type).  Every function and special form has a type signature that may accept its arguments, in which case type-checking continues toward the root of the tree, or reject its arguments, in which case the PFA document fails with a semantic error.  Every function and special form has a return type, which may depend on the types of its arguments (but not the values of its arguments, which are only known at runtime).  Arguments and return types should be recursively checked until the root of the tree (the type of the expression as a whole) is reached.  This derived type is checked against the declared function return type or {\PFAc output}.  If the declared type does not accept the derived type, the PFA document is rejected with a semantic error.

Some special forms take a JSON array of expressions and either apply no return type constraint or only constrain the last expression, which is used as a return value.  Each case is explicitly specified in \hyperlink{hsec:expressions}{Sec.~\ref{sec:expressions}}.

In passing, we note that the type annotations could have been more minimal if return types were not required, and some input types could, in principle, be inferred from their position in a function argument list.  However, an explicit {\PFAc output} allows a PFA system or casual observer to quickly determine if a scoring engine will fit into a given workflow, in which the input types and output types are constrained by data pipelines.  Moreover, function return types cannot always be omitted, even in theory: recursive functions cannot determine their return type from parameters only, for instance.  Also, inferring input types from parents or siblings in the expression tree unnecessarily complicates the type-check algorithm.  The algorithm chosen for PFA is strictly local--- only subexpressions and previously defined symbols are needed to infer an expression type--- and uniform--- the same rules apply regardless of the function's call graph.

\subsection{Type resolution, promotion, and covariance}

At each step in the type inference algorithm, the expected type or type pattern is checked against the actual or derived type.  All types have a non-commutative, binary ``accepts'' relation, for which ``A accepts B'' means that B is an acceptable observed type for expected type A.  For example, ``{\bf double} accepts {\bf int}'' because integers are a subset of double-precision floating point numbers, and any function that needs a {\bf double} must be able to use an {\bf int} instead.

Even though Avro is a serialization protocol, it defines a suite of type promotion rules for the sake of schema resolution.  In Avro, these rules are used to determine if an old version of a schema is compatible with a new version of a schema: for instance, if the old schema defines a variable as an int and the new schema defines it as a double, the old serialized dataset is forward-compatible--- it can be used in an application as though it had the new schema.  PFA uses the same rules to promote data through an expression.

These rules are described in the \href{http://avro.apache.org/docs/1.7.6/spec.html#Schema+Resolution}{Schema Resolution section} of the Avro specification, but they are reviewed here with an emphasis on how the rules are used in PFA type inference.

\noindent\begin{longtable}{p{0.2\linewidth} p{0.75\linewidth}}
{\bf Expected type} & {\bf Accepts} \\\hline\endhead
{\bf null} & Only {\bf null} or a {\bf union} of only {\bf null} (union of exactly one type, which is not a useful union). \\
{\bf boolean} & Only {\bf boolean} or a {\bf union} of only {\bf boolean}. \\
{\bf int} & Only {\bf int} or a {\bf union} of only {\bf int}. \\
{\bf long} & {\bf int} or {\bf long} or a {\bf union} of any subset of \{{\bf int}, {\bf long}\}. \\
{\bf float} & {\bf int}, {\bf long}, or {\bf float} or a {\bf union} of any subset of \{{\bf int}, {\bf long}, {\bf float}\}. \\
{\bf double} & {\bf int}, {\bf long}, {\bf float} or {\bf double} (all numeric types are promoted).  Also accepts a {\bf union} of any subset of \{{\bf int}, {\bf long}, {\bf float}, {\bf double}\}. \\
{\bf string} & Only {\bf string} or a {\bf union} of only {\bf string}. \\
{\bf bytes} & Only {\bf bytes} or a {\bf union} of only {\bf bytes}. \\
{\bf fixed({\PFAtp L}, {\PFAtp N}, {\PFAtp NS})} & Only a {\bf fixed} with the same length {\PFAtp L} and fully-qualified name given by {\PFAtp NS} and {\PFAtp N}.  Also accepts a {\bf union} of only this {\bf fixed} type. \\
{\bf enum({\PFAtp S}, {\PFAtp N}, {\PFAtp NS})} & An {\bf enum} whose symbols {\PFAc S} are a subset of the expected {\bf enum}'s symbols with fully-qualified name given by {\PFAtp NS} and {\PFAtp N}.  For example, if an {\bf enum} with symbols ``one'', ``two'', and ``three'' is expected, it will accept an {\bf enum} of the same name with symbols ``two'' and ``one''.  Also accepts a {\bf union} of only these {\bf enum} types. \\
{\bf array({\PFAtp X})} & An {\bf array} with items {\PFAc Y} for which {\PFAc X} accepts {\PFAc Y} (arrays are covariant).  For example, an {\bf array} of {\bf double} accepts an {\bf array} of {\bf int}, but an an {\bf array} of {\bf int} does not accept an an {\bf array} of {\bf double}.  Also accepts a {\bf union} of only these {\bf array} types. \\
{\bf map({\PFAtp X})} & A {\bf map} with values {\PFAc Y} for which {\PFAc X} accepts {\PFAc Y} (maps are covariant).  Also accepts a {\bf union} of only these {\bf map} types. \\
{\bf record({\PFAtp F}, {\PFAtp N}, {\PFAtp NS})} & A {\bf record} whose fields are a superset of fields {\PFAc F} (in any order) with corresponding field types such that the expected field accepts the observed field (records are covariant).  For example, an expected record with fields \{``one'': {\bf double} and ``two'': {\bf string}\} accepts an observed record with fields \{``one'': {\bf double}, ``two'': {\bf string}, and ``three'': {\bf bytes}\}.  It also accepts an observed record with fields \{``one'': {\bf int} and ``two'': {\bf string}\}.  The observed record must also have the same fully-qualified name given by {\PFAc NS} and {\PFAc N}.  Also accepts a {\bf union} of only these {\bf record} types. \\
{\bf union({\PFAtp T})} & Either a {\bf union({\PFAtp T$'$})} such that for all {\PFAc t$'$} in {\PFAc T$'$}, there exists a {\PFAc t} in {\PFAc T} for which {\PFAc t} accepts {\PFAc t$'$}, or a single type {\PFAc t$''$} such that there exists a {\PFAc t} in {\PFAc T} for which {\PFAc t} accepts {\PFAc t$''$}.  For example, a {\bf union} of \{{\bf string}, {\bf bytes}, and {\bf null}\} accepts a {\bf union} of \{{\bf string} and {\bf bytes}\}, and it also accepts a {\bf string}.  However, the reverse is not true: a narrow type or union cannot accept a wider union.
\end{longtable}

\hypertarget{hsec:narrowest-supertype}{}
\subsection{Narrowest supertype of a collection of types}
\label{sec:narrowest-supertype}

Some circumstances (return type of a special form, solution of a generic type pattern) require a single type that accepts a given set of types.  For example, an ``if'' conditional with both a ``then'' and an ``else'' clause returns a value that might have the type of the ``then'' clause or might have the type of the ``else'' clause.  If both clauses have the same type {\PFAtp X}, then the return type of the ``if'' special form is {\PFAtp X}, but if ``then'' has type {\PFAtp Y} and ``else'' has type {\PFAtp Z}, the type of the ``if'' special form is something that could be (accepts) {\PFAtp Y} or {\PFAtp Z}.  In these situations, the resultant type is the narrowest supertype of the possibilities.

The following rules define the narrowest supertype of a collection of at least one type.  In cases where more than one rule matches, the first matching rule is applied.
\noindent\begin{longtable}{p{0.02\linewidth} p{0.3\linewidth} p{0.6\linewidth}}
\# & {\bf Collection of types} & {\bf Narrowest supertype} \\\hline\endhead
1. & all {\bf null} & {\bf null} \\
2. & all {\bf boolean} & {\bf boolean} \\
3. & all {\bf int} & {\bf int} \\
4. & all {\bf int} or {\bf long} & {\bf long} \\
5. & all {\bf int}, {\bf long}, or {\bf float} & {\bf float} \\
6. & all {\bf int}, {\bf long}, {\bf float}, or {\bf double} & {\bf double} \\
7. & all {\bf string} & {\bf string} \\
8. & all {\bf bytes} & {\bf bytes} \\
9. & all {\bf fixed} with the same length and fully-qualified name & that {\bf fixed} type \\
10. & all {\bf enum} types with the same symbols and fully-qualified name & that {\bf enum} type \\
11. & all {\bf arrays} & an {\bf array} of the narrowest supertype of the items of each {\bf array} \\
12. & all {\bf maps} & a {\bf map} of the narrowest supertype of the values of each {\bf map} \\
13. & all {\bf records} with the same fields and fully-qualified name & that {\bf record} type \\
14. & any other collection of types, excluding those containing {\bf fixed} and {\bf enum} & a union of those types, merging any unions contained in the collection (e.g.\ {\bf union({\PFAtp X}, {\PFAtp Y})} and {\bf union({\PFAtp Y}, {\PFAtp Z})} combine into {\bf union({\PFAtp X}, {\PFAtp Y}, {\PFAtp Z})}) and combining any types that can be combined with the rules above (e.g.\ {\bf int} and {\bf double} become {\bf double}, rather than {\bf union(int, double)}). \\
15. & any other case & is a type error.
\end{longtable}

In summary, any cases that cannot be promoted to the same type are combined into a union except for collections containing {\bf fixed} or {\bf enum}.  These cases, had they been allowed, would introduce the need for PFA implementations to perform runtime type conversions: values of different {\bf fixed} types would need to be converted into raw {\bf bytes} and values of different {\bf enum} types would need to be converted into {\bf string} or an {\bf enum} with a superset of symbols.  These new, anonymous types would have potentially unexpected properties: the broadening of {\bf enums} cannot maintain the order of a collection of symbols, which are used in some statistical applications as a finite ordinal set.  It is better to raise a type error and force the PFA author to explicitly convert these types to {\bf bytes}, {\bf string}, or explicitly define an {\bf enum} with a superset of symbols.

Distinct {\bf records} are combined into a union of those {\bf records}, however (rule 13 falls through to rule 14 when the {\bf records} are not exactly the same).

\hypertarget{hsec:generic-signatures}{}
\subsection{Generic library function signatures}
\label{sec:generic-signatures}

User-defined functions in the {\PFAc fcns} top-level field have parameter lists and return types specified strictly by Avro type schemae (\hyperlink{hsec:user-defined-fcns}{see Sec.~\ref{sec:user-defined-fcns}}).  However, some library functions have more general type signatures so that they can be more broadly applied.

Library functions are never declared in a PFA document, and thus they are not bound to the same restrictions.  It would be possible to define a JSON format for expressing generic function signatures, but that format would not be an Avro schema.  Moreover, PFA documents are not intended for generic programming, but for auto-generated code.  Since every PFA document is a specific solution to a specific problem, it should be written in terms of ungeneric functions.  (The generality can be in the routine that generates the PFA document.)  The PFA library functions, however, are intended for a wide variety of problems, and thus should be generic.

Library function type patterns are a superset of Avro types.  They include the same primitives:
\begin{itemize}
\item null, boolean, int, long, float, double, string, bytes
\end{itemize}
and the same parameterized, product, and sum types, though names are optional:
\begin{itemize}
\item fixed ({\it size:} {\PFAtp L})
\item fixed ({\it size:} {\PFAtp L}, {\it name:} {\PFAtp N})
\item enum ({\it symbols:} {\PFAtp S})
\item enum ({\it symbols:} {\PFAtp S}, {\it name:} {\PFAtp N})
\item array of {\PFAtp X}
\item map of {\PFAtp X}
\item record ({\it fields:} \{{\PFApf name$_1$:} {\it type$_1$,} {\PFApf name$_2$:} {\it type$_2$,} \ldots\ {\PFApf name$_n$:} {\it type$_n$}\})
\item record ({\it fields:} \{{\PFApf name$_1$:} {\it type$_1$,} {\PFApf name$_2$:} {\it type$_2$,} \ldots\ {\PFApf name$_n$:} {\it type$_n$}\}, {\it name:} {\PFAtp N})
\item union of \{{\PFAtp T}\}
\end{itemize}
When present, names are fully-qualified, rather than being split into namespace-name pairs.  A type pattern of fixed, enum, or record without a name matches any fixed, enum, or record with the specified structure (structural typing, rather than nominative).  For instance, a library function could require a record with integer, double, and string fields named ``one'', ``two'', and ``three'' like this:
\begin{center}
\begin{minipage}{0.9\linewidth}
record ({\it fields:} \{{\PFApf one:} int, {\PFApf two:} double, {\PFApf three:} string\})
\end{minipage}
\end{center}
Since this pattern has no {\it name,} it would match any record that has exactly these fields with these types.

Unlike Avro types, the parameters of type patterns can be specified by wildcards.  Wildcards are labeled and may be restricted to a set of Avro types (not patterns):
\begin{itemize}
\item any {\PFAp A}
\item any {\PFAp A} of \{{\it type$_1$, type$_2$, \ldots\ type$_n$}\}
\end{itemize}
Wildcards can appear anywhere that a pattern is expected.  For instance,
\begin{center}
\begin{minipage}{0.9\linewidth}
array of any {\PFAp A}
\end{minipage}
\end{center}
is an array with unspecified item type.

Wildcards with repeated labels constrain two types to be the same type.  For instance,
\begin{center}
\begin{minipage}{0.9\linewidth}
record ({\it fields:} \{{\PFApf one:} any {\PFAp A}, {\PFApf two:} any {\PFAp B}, {\PFApf three:} any {\PFAp B}\})
\end{minipage}
\end{center}
is a record with three fields of unspecified type, though fields ``two'' and ``three'' have the same.  If they are not exactly the same, they are promoted to the \hyperlink{hsec:narrowest-supertype}{narrowest supertype} of the matches.  The following are examples of Avro types that would match this pattern.
\begin{example}
{\PFAc R1} matches because ``two'' and ``three'' are both {\bf string}.
\begin{json}
{"type": "record", "name": "R1", "fields": [
    {"name": "one", "type": "int"},
    {"name": "two", "type": "string"},
    {"name": "three", "type": "string"}]}
\end{json}
\vspace{0.2 cm}
\end{example}

\begin{example}
{\PFAc R2} matches because ``two'' and ``three'' are both {\bf int}.  The type that matches wildcard {\PFAp B} does not need to be different from the type that matches wildcard {\PFAp A} (also ``int'').
\begin{json}
{"type": "record", "name": "R2", "fields": [
    {"name": "one", "type": "int"},
    {"name": "two", "type": "int"},
    {"name": "three", "type": "int"}]}
\end{json}
\vspace{0.2 cm}
\end{example}

\begin{example}
{\PFAc R3} matches because ``two'' and ``three'' can both be promoted to {\bf double}.
\begin{json}
{"type": "record", "name": "R3", "fields": [
    {"name": "one", "type": "string"},
    {"name": "two", "type": "int"},
    {"name": "three", "type": "double"}]}
\end{json}
\end{example}

The scope of wildcard labels is the entire function signature, including all parameters and return type.

\begin{example}
As an example, the signature of ``+'' (the library function that adds two numbers) is
\begin{center}
\begin{minipage}{0.9\linewidth}
\mbox{\PFAc \{"+":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular}
\end{minipage}
\end{center}
The two parameters, {\PFAp x} and {\PFAp y}, can be any type in the set \{int, long, float, double\} and the return type is the narrowest supertype of {\PFAp x} and {\PFAp y}.  Thus, int $+$ int $\to$ int, int $+$ double $\to$ double, etc.  The restriction on {\PFAtp A} in the pattern for {\PFAp x} applies equally to {\PFAp y} because all constraints must be satisfied for a pattern to match.
\end{example}

\begin{example}
Shared labels are primarily used to carry types from a parameter to the return type.  They allow a function like ``a.subseq'' (extract a subsequence of an array) to be defined once for any type of items.
\begin{center}
\begin{minipage}{0.9\linewidth}
\mbox{\PFAc \{"a.subseq":$\!$ [a, start, end]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular}
\end{minipage}
\end{center}
\end{example}

Record substructure can also be matched with wildcards.  Such a pattern has one of these two forms:
\begin{itemize}
\item any record {\PFAp A}
\item any record {\PFAp A} with \{{\PFApf name$_1$:} {\it type$_1$,} {\PFApf name$_2$:} {\it type$_2$,} \ldots\ {\PFApf name$_n$:} {\it type$_n$}\}
\end{itemize}
The first matches any record, regardless of what fields it contains, and the second matches a record with at least the specified fields.  Wildcards with and without specifying record substructure have labels in the same namespace.

Enumeration lists can also be matched to record fields:
\begin{itemize}
\item enum {\PFAp A} of fields of {\PFAp B}
\end{itemize}
where {\PFAp B} refers to a wildcarded record.  To match this pattern, the enum's symbols must be equal to the record field names--- the same strings in the same order, without any missing or any extra.  Functions with this pattern in their signature (such as ``model.tree.simpleTest'') not only guarantee that values of the enumeration correspond to some record field (unlike arbitrary strings), but at runtime, the record field can be retrieved by index or pointer, rather than by name.

Finally, some library functions can accept functions as arguments, even though functions are not first-class objects in the language.  A function cannot be assigned to a symbol, but it can appear in an argument list.  The following type pattern matches functions:
\begin{itemize}
\item function ({\it type$_1$}, {\it type$_2$}, \ldots\ {\it type$_n$}) $\to$ {\it type}
\end{itemize}
The pattern does not specify the names of parameters, only their number, order, and types (as patterns).  Only non-generic functions can be matched, and since most library functions are generic, the matched function would usually be a user-defined function.  (Notable exceptions are mathematical special functions, probability distributions, and clustering metrics.)

\begin{example}
The parameter and return types of a function pattern can be wildcarded, as in this example of ``a.filter'', which filters an array.
\begin{center}
\begin{minipage}{0.9\linewidth}
\mbox{\PFAc \{"a.filter":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular}
\end{minipage}
\end{center}
\end{example}

\begin{example}
Library functions with function arguments are primarily used to override the default behavior of a statistical routine through callbacks.  The ``model.tree.simpleWalk'' function illustrates how a decision tree traversal can be given an arbitrary or even user-defined predicate.
\begin{center}
\begin{minipage}{0.9\linewidth}
\mbox{\PFAc \{"model.tree.simpleWalk":$\!$ [datum, treeNode, predicate]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & any record {\PFAtp D} \\  & \PFAc treeNode \rm & any record {\PFAtp T} with \{{\PFApf pass:}$\!$ union of \{{\PFAtp T}, any {\PFAtp S}\}, {\PFApf fail:}$\!$ union of \{{\PFAtp T}, {\PFAtp S}\}\} \\  & \PFAc predicate \rm & function ({\PFAtp D}, {\PFAtp T}) $\to$ boolean \\  & {\it (returns)} & {\PFAtp S} \\ \end{tabular}
\end{minipage}
\end{center}
\end{example}

Function arguments can only be provided using the \hyperlink{hsec:fcndef}{fcndef} or \hyperlink{hsec:fcnref}{fcnref} special forms, which require explicit functions to be known during static analysis.  Therefore, the platform on which PFA is being implemented does not need first class functions or the equivalent (e.g.\ objects with a pre-specified ``apply'' method).  It does not even need functions in the normal sense: if the platform requires all functions to be expanded inline, the PFA system can generate specific code for each case.  That is, the ``a.filter'' and ``model.tree.simpleWalk'' functions can be expanded into special-case bytecode for each call that takes a different function argument, possibly mixing the library function implementation with the user-defined callback.  This would not be possible if function arguments could only be resolved at runtime.

\pagebreak

\hypertarget{hsec:symbol-scope}{}
\section{Symbols, scope, and data structures}
\label{sec:symbol-scope}

Calculations in PFA are performed by nesting function calls in argument lists (purely functional programming) and assigning values to symbols, cells, and pools, possibly overwriting previous values (imperative programming).  Some mathematical algorithms are more easily expressed in a functional style while others are more easily expressed in an imperative style.  Cells and pools (global state) are discussed in \hyperlink{hsec:state}{Sec.~\ref{sec:state}}.  Symbols provide temporary local state.

Much like a cell, a symbol is a named container with fixed type whose value can be replaced: it is a variable.  Unlike a cell, a symbol can only be referenced within a limited scope.  Symbol scopes in PFA are
\begin{itemize}
\item lexical: scopes are defined in terms of character ranges in the text of the PFA document, and
\item block-level: they range from the declaration of the symbol to the end of the containing block, which is either a single expression of a JSON array of expressions.
\end{itemize}

Since blocks are deeply nested in a moderately complex PFA document, symbol scopes may be deeply nested as well.  A symbol must not be shadowed; that is, it must not be declared twice in the same scope or in two scopes such that one is nested within the other.  The same symbol name may be used in non-overlapping scopes.

Symbols are declared with the ``let'' special form and reassigned with the ``set'' special form (\hyperlink{hsec:let-set}{see Sec.~\ref{sec:let-set}}).  This distinction between declaration and reassignment should be enforced, as it allows an observer to determine which symbols are constant and which algorithms are purely functional at a glance.

Although a symbol is readable anywhere below the point at which it is defined, some special forms limit the scopes in which a symbol can be reassigned.  For example, symbols declared outside of an anonymous function cannot be modified by the function, since that would be hard to implement in a system that does not have closures.  Looping special forms for which {\PFAc seq} is {\PFAc false} may be evaluated in any order to allow for systems that might parallelize the loop--- in this case, symbols declared outside the loop cannot be modified in the loop, since that would lead to race conditions.  Special forms that prohibit modification of symbols declared outside the form are said to be ``sealed from above''.

Some forms also do not allow new variable declarations.  One such example is the argument list of a function call, since such a declaration could never be used (each argument of the function call is in a different scope).  These scopes are said to be ``sealed within''.  In a functional programming style, it is sometimes desirable to insert whole algorithms in what would otherwise be a restricted block like a function argument.  To allow for this usage, a ``do'' special form can be placed within such a scope, creating a sub-scope that allows variable declarations and expands a single-expression block into a JSON array of expressions.  The ``do'' form is required to ensure that this usage is intentional.

The sealed-from-above or sealed-within status of scopes within each special form is specified in \hyperlink{hsec:expressions}{Sec.~\ref{sec:expressions}}.

Symbol names must match the following pattern: {\PFAc [A-Za-z\_][A-Za-z0-9\_]*} (the first character must be a letter or underscore; subsequent characters, if they exist, may also be numbers).  Symbol names do not share a namespace with cells, pools, or functions.

\hypertarget{hsec:immutable}{}
\subsection{Immutable data structures}
\label{sec:immutable}

All values in PFA, including complex data structures like arrays, maps, and records, are immutable.  That is, there are no special forms or library functions that can change the structure of a value in-place, so in-place operations cannot be expressed in any routine constructed from those calls.  The PFA specification puts no constraints on how values are implemented, however: they may be immutable in the context of PFA operations and yet mutable in the context of the host system.  We suggest that complex data structures be implemented with structural sharing to optimize speed and memory usage, but this is an implementation detail.

One consequence of all data structures being immutable is that there is no distinction between a value and a reference to a value or between copying and linking.  In languages with mutable values and references, this distinction is important because linking a reference to the same value in multiple places creates an unseen connection between them.  For instance (in Python),
\begin{center}
\begin{minipage}{0.9\linewidth}
\PFAc y.child = x \\
z.child = x \\
... \\
y.child.modify()
\end{minipage}
\end{center}
modifies {\PFAc z.child} as well as {\PFAc y.child}, while
\begin{center}
\begin{minipage}{0.9\linewidth}
\PFAc y.child = deepcopy(x) \\
z.child = deepcopy(x) \\
... \\
y.child.modify()
\end{minipage}
\end{center}
only modifies {\PFAc y.child}.  Since PFA lacks the equivalent of {\PFAc modify()}, the above distinction is irrelevant.

Another consequence is that it is impossible to create a circular reference in PFA.  In Python, one can create a circular reference in a list {\PFAc x} by
\begin{center}
\begin{minipage}{0.9\linewidth}
\PFAc x.append(x)
\end{minipage}
\end{center}
Attempts to depth-first walk through this list of lists would result in an infinite loop, and modifications of {\PFAc x} would silently change this nested element (as above).  In PFA, the equivalent statement
\begin{json}
{"set": {"x": {"a.append": ["x", "x"]}}}
\end{json}
creates a new array that contains all of the old items of {\PFAc x} with the entire old array {\PFAc x} appended.  This new array is assigned to symbol {\PFAc x}.  Since PFA has no mutable structures (and no lazy evaluation), it is impossible to create a circular reference.

\begin{example}
In fact, assignments with the same symbol on the left-hand side as the right-hand side behave like ``{\PFAc x = x + 1}'' in that the right-hand side always deals with the old value of the symbol and the left-hand side may change the meaning of the symbol to a new value.  For instance,
\begin{json}
{"do": [
    {"let": {"x": {
        "type": {"type": "record", "name": "R", "fields": [
            {"name": "child", ["R", "null"]}]},
        "value": {"child": null}}}},
    {"set": {"x": {"attr": "x", "path": ["child"], "to": "x"}}},
    {"set": {"x": {"attr": "x", "path": ["child"], "to": "x"}}},
    {"set": {"x": {"attr": "x", "path": ["child"], "to": "x"}}},
    "x"]}
\end{json}
results in
\begin{json}
{"child": {"child": {"child": {"child": null}}}}
\end{json}
just as
\begin{json}
{"do": [
    {"let": {"x": 0}},
    {"set": {"x": {"+": ["x", 1]}}},
    {"set": {"x": {"+": ["x", 1]}}},
    {"set": {"x": {"+": ["x", 1]}}},
    "x"]}
\end{json}
results in 3.  In languages with mutable data structures, some updates behave like ``{\PFAc x = x + 1}'' while others create circular references.
\end{example}

Similarly, there is no distinction between passing a function argument by reference versus passing it by value.  Such a distinction would be seen when the function modifies the object that it is given, but in PFA, these modifications are not possible.

To get this behavior in a language or context that allows in-place modifications, one must make deep copies of the objects because copies are not linked the way that references are.  However, purely immutable objects can be safely passed without copying and structurally shared when modified.  In the examples above, a PFA implementation may use the same object in memory wherever its value is needed and may always pass a pointer to the object as a function argument.  Since values and references are equivalent, one can choose the computationally least expensive operation.

Our decision to make all data structures immutable was driven by two needs: (1) to make them fully expressible by Avro type schemae, which do not allow for circular references or any non-treelike graph, and (2) to simplify the read-copy-update \hyperlink{hsec:concurrent}{concurrency algorithm}.  If objects were mutable, then an explicit copy would be needed to allow read operations to see the old version of the object while write operations create a new version.  In addition to making implementations more complicated, this would make all write operations more expensive, since they must do a deep copy on every update.  With immutable objects, the copy step is unnecessary.

\subsection{Memory management}

PFA does not define any particular memory management technique.  The language has constructs for creating objects but not for deleting them, so some sort of garbage collector will be needed to release objects that are out of scope.  This implicit garbage collector may be the same as the one used by PFA host's environment (e.g.\ the JVM and Python have built-in garbage collectors) or it may be a library used to collect garbage only in the PFA system (e.g.\ the boehmgc and boost libraries provide garbage collectors for C++).

\pagebreak

\hypertarget{hsec:user-defined-fcns}{}
\section{User-defined functions}
\label{sec:user-defined-fcns}

A PFA document may define new functions that are called as though they were library functions.  There are two differences between these ``user-defined'' functions and the library functions specified by PFA:
\begin{itemize}
\item user-defined functions are prefixed by ``{\PFAc u.}'' when called (in the ``u'' branch of the module tree);
\item their signatures must consist of specific Avro types, since only library functions can have generic signatures (\hyperlink{hsec:generic-signatures}{see Sec.~\ref{sec:generic-signatures}}).
\end{itemize}

The scope of all functions, including user-defined functions, is global.  Functions are also static; they cannot be declared at runtime.  They may be declared in the {\PFAc fcns} top-level field, which makes their global, static nature manifest, or they may be declared inline in the argument list of a special form or library function that accepts a function as an argument.

In the latter case, the user-defined function has no name (an ``anonymous function'') and some features of a lexical closure.  It has access to symbols defined in an enclosing scope (it ``closes over'' those symbols), but this access is limited to reading only.  A PFA system may implement this by internally adding the closed symbols to its parameter list.  In all other aspects, an anonymous function behaves like a globally defined function and may be implemented as one (with an auto-generated name).

Function names must match the following: {\PFAc [A-Za-z\_]([A-Za-z0-9\_]|\textbackslash.[A-Za-z][A-Za-z0-9\_]*)*} (consists of dot-delimited words in which each word starts with a letter or underscore; subsequent characters, if they exist, may also be numbers; there must be at least one word).  Functions do not share a namespace with cells, pools, or symbols.

\subsection{No first-class functions}

Some languages have first-class functions, meaning that functions are ``first-class citizens'' and can be treated like any other data structure.  In PFA, functions are second-class, but not coach.  Similar to first-class functions, they may be passed as arguments to other functions (specific library functions that accept functions as arguments) and they may be defined inline as anonymous functions that close over local variables.  Unlike first-class functions, they cannot be assigned to symbols or be returned from functions, and the closures have read-only access to the variables they close over.

These restrictions make it possible to implement PFA functions in very limited environments and to be able to fully analyze the function call graph without executing the scoring engine (thereby statically detecting recursion, if necessary).  If, instead, a function could be assigned to a symbol, then it could be changed at runtime and not be predicted statically.  If an inline function could reassign symbols in its scope, then it could not be internally implemented as a simple function.

These rules provide enough flexibility to implement callbacks in library functions, but not so much as to make the call graph unpredictable or make the scoring engine impossible to implement in environments that only accept inline-expanded functions.  Pascal and Algol are two historical examples of languages with the same set of rules.

\subsection{Syntax for declaring new functions}

User functions are declared with the ``fcndef'' special form.  If ``fcndef'' appears in an argument list, it defines an anonymous function.  If it appears as a member value for a name-value pair in the {\PFAc fcns} top-level field, it defines a named function.

\subsubsection{Defining function: the ``fcndef'' special form}

\hypertarget{hsec:fcndef}{}
\label{form:fcndef}
\begin{minipage}{\linewidth}
The ``fcndef'' special form has the following syntax.
\begin{center}
\begin{minipage}{0.9\linewidth}
\mbox{\PFAc \{"params":$\!$ [\{par1:$\!$ type1\}, \{par2:$\!$ type2\}, ...], "ret":$\!$ retType, "do":$\!$ expr\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\
\rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}
& \PFAc par1 \rm & string, name of first parameter \\
& \PFAc type1 \rm & Avro schema, type of first parameter \\
& \PFAc par2 \rm & string, name of second parameter \\
& \PFAc type2 \rm & Avro schema, type of second parameter \\
& \ldots & \\
& \PFAc retType \rm & Avro schema, return type \\
& \PFAc expr \rm & expression or JSON array of expressions \\
\end{tabular}
\end{minipage}
\end{center}
\end{minipage}

The {\PFAc params}, {\PFAc ret}, and {\PFAc do} fields must be present, though {\PFAc params} could be an empty JSON array (no parameters).  The individual parameters are always represented by single-member JSON objects: the name is the parameter name (used in the function body), and the value is its type.

The {\PFAc do} field is the function body, and its return value is the last or only expression it contains.  The {\PFAc do} field must contain at least one expression (it must not be an empty JSON array).

If this form appears in the {\PFAc fcns} top-level field, the function name (without its namespace qualifier, ``{\PFAc u.}'') is given by the associated member name.

\begin{example}
For example,
\begin{json}
"fcns": {
    "square": {"params": [{"x": "double"}], "ret": "double", "do": {"**": ["x", 2]}},
    "cube": {"params": [{"x": "double"}], "ret": "double", "do": {"**": ["x", 3]}}
}
\end{json}
defines {\PFAc u.square} (which squares the input value) and {\PFAc u.cube} (which cubes the input value).  The number 5 may now be squared by {\PFAc \{"u.square":$\!$ 5\}} or {\PFAc \{"u.square":$\!$ [5]\}}.
\end{example}

\begin{example}
This Fibonacci number algorithm demonstrates recursion.
\begin{json}
"fcns": {
    "fib": {"params": [{"n": "int"}], "ret": "int", "do":
        {"cond": {"if": {"==": ["n", 0]}, "then": 0},
                 {"if": {"==": ["n", 1]}, "then": 1},
         "else": {"+": [
             {"u.fib": [{"-": ["n", 1]}]},
             {"u.fib": [{"-": ["n", 2]}]}
         ]}}}
}
\end{json}
\end{example}

\begin{example}
This iterative Fibonacci number algorithm illustrates a multi-line {\PFAc do} field.
\begin{json}
"fcns": {
    "fib": {"params": [{"n": "int"}], "ret": "int", "do": [
        {"let": {"now": 0,
                 "next": 1}},
        {"for": {"i": "n"},
         "until": {"<": ["i", 0]},
         "step": {"i": {"-": ["i", 1]}},
         "seq": true,
         "do": [
             {"let": {"tmp": {"+": ["now", "next"]}}},
             {"set": {"now": "next",
                      "next": "tmp"}}
         ]},
         {"if": {"==": ["n", 0]},
          "then": 0,
          "else": "next"}
    ]}
}
\end{json}
\end{example}

\hypertarget{hsec:referencing-functions}{}
\subsection{Syntax for referencing functions}
\label{sec:referencing-functions}

Named functions are referenced with the ``fcnref'' special form, and anonymous functions are both declared and referenced with an inline ``fcndef'' special form (see above).

\hypertarget{hsec:fcnref}{}
\label{form:fcnref}

\subsubsection{Referencing a globally defined function: the ``fcnref'' special form}

\begin{minipage}{\linewidth}
The ``fcnref'' special form has the following syntax.
\begin{center}
\begin{minipage}{0.9\linewidth}
\mbox{\PFAc \{"fcn":$\!$ name\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\
\rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}
& \PFAc name \rm & string, the name of the function \\
\end{tabular}
\end{minipage}
\end{center}
or
\begin{center}
\begin{minipage}{0.9\linewidth}
\mbox{\PFAc \{"fcn":$\!$ name, "fill":$\!$ \{param1:$\!$ value1, param2:$\!$ value2, \ldots\}\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\
\rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}
& \PFAc name \rm & string, the name of the function \\
& \PFAc param\# \rm & string, the name of a parameter of the function \\
& \PFAc value\# \rm & expression, an expression to evaluate and pass to param\# \\
\end{tabular}
\end{minipage}
\end{center}
\end{minipage}

The {\PFAc name} string must be an exact name of the function, not an expression that can be evaluated at runtime.

If the {\PFAc fill} field is used, the form represents a new function with fewer parameters than the referenced function, in which one or more of the referenced function's fields are filled by an expression.  The expression is evaluated every time the new function is called (relevant if it has any side-effects).  Since the new function has fewer parameters than the referenced function, it has a different type than the referenced function.  This form is usually used to supply default arguments to a general function.

Only non-generic functions with a single signature that does not reference other functions can be represented by a ``fcnref'' form.  Generic parameters or function parameters are only allowed if they are filled (hidden) by a {\PFAc fill} field.  Note that return types may not be generic, either.  If you wish to reference a general function, wrap it in an inline ``fcndef'', which is non-generic, single-signature, and hs no explicit function arguments because it is a user function.

\begin{example}
Here is a complete PFA document that increments and returns a counter every time it is pinged (the scoring engine is executed with {\PFAc null} input).
\begin{json}
{"input": "null",
 "output": "int",
 "action": [
     {"cell": "counter", "to": {"fcn": "u.increment"}},
     {"cell": "counter"}],
 "cells":
     {"counter": {"type": "int", "init": 0, "shared": true}},
 "fcns":
     {"increment":
         {"params": [{"x": "int"}],
          "ret": "int",
          "do": {"+": ["x", 1]}}}
}
\end{json}
The increment is defined in a function so that getting the counter value, incrementing it, and putting the new value in the cell are all one atomic action--- other update attempts block until this one is done.  Without ensuring atomicity, the counter could miss an update when a second update attempt reads {\PFAc counter} before the first writes its new value.
\end{example}

\begin{example}
The same operation could be performed with an inline ``fcndef''.  In the example below, the scoring engine adds the input value to {\PFAc counter} every time it is called.  Because of its location, the anonymous function can close over the {\PFAc input} symbol, which exists in the {\PFAc action} block but not in {\PFAc fcns}.
\begin{json}
{"input": "int",
 "output": "int",
 "action": [
     {"cell": "counter", "to": {"params": [{"x": "int"}],
                                "ret": "int",
                                "do": {"+": ["x", "input"]}}},
     {"cell": "counter"}],
 "cells":
     {"counter": {"type": "int", "init": 0, "shared": true}}
}
\end{json}
\end{example}

\pagebreak

\hypertarget{hsec:expressions}{}
\section{Expressions}
\label{sec:expressions}

PFA documents may contain simple programs formed by composing expressions.  There are four types of expressions: symbol references, literal values, function calls, and special forms.

\hypertarget{hsec:symbol-ref}{}
\subsection{Symbol references}
\label{sec:symbol-ref}

A symbol reference yields the current value of a predefined symbol.  For example, the {\PFAc action} routine has a {\PFAc input} symbol pre-defined: wherever this appears, the input value is inserted.  New symbols can be created with ``\hyperlink{hsec:let-set}{let}'' and old symbols can be changed with ``\hyperlink{hsec:let-set}{set}'', if the current context allows it (\hyperlink{hsec:symbol-scope}{see Sec.~\ref{sec:symbol-scope}}).  \hyperlink{hsec:cells-pools}{Cells and pools} are not symbols; they are referenced through \hyperlink{hsec:cell-pool-forms}{a pair of special forms}.

A symbol reference is simply a JSON string.  JSON strings in contexts where an expression is expected are interpreted as symbol references (with one exception); JSON strings in other contexts have other meanings.  The exception is the following: a valid symbol name must not contain dots (``.'') as described at the end of \hyperlink{hsec:symbol-scope}{Sec.~\ref{sec:symbol-scope}}, and if a JSON string where an expression is expected contains dots, it should be interpreted as a shortcut for the ``\hyperlink{hsec:attr-form}{attr}'' special form.

\hypertarget{hsec:literals}{}
\subsection{Literal values}
\label{sec:literals}

Literal values are constants embedded in an expression.  Simple examples are numbers, such as the ``2'' in this expression that squares {\PFAc x}: {\PFAc \{"**":$\!$ ["x", 2]\}}.

Cells without ``cell-to'' can also be used to define constants in a PFA document.  The differences are: (1) a literal appears in the midst of an expression, while cells are in the {\PFAc cells} top-level field, (2) cells are named and can be referenced in many places throughout a PFA document, including functions, but literals are unnamed unless assigned to a symbol of limited scope, (3) constant cells are constructed once, in the \hyperlink{hsec:phases}{initialization phase} of the engine, but literals may or may not be constructed every time the program flow reaches them (this is an implementation detail).  Typically, large data structures like the representation of a statistical model would be stored in a cell, rather than an inline literal.

Literals are represented by the following special forms:
\begin{itemize}
\item {\PFAc \{"int":$\!$ NUMBER\}} where {\PFAc NUMBER} is a JSON integer.  The return type is {\bf int}; a value that is too large to be represented as a 32-bit number is a syntax error.
\item {\PFAc \{"long":$\!$ NUMBER\}} where {\PFAc NUMBER} is a JSON integer.  The return type is {\bf long}; a value that is too large to be represented as a 64-bit number is a syntax error.
\item {\PFAc \{"float":$\!$ NUMBER\}} where {\PFAc NUMBER} is a JSON floating-point number.  The return type is {\bf float}; a value that is too large, too small, or too precise to be represented as a \href{http://dx.doi.org/10.1109%2FIEEESTD.2008.4610935}{IEEE 754} 32-bit floating point number is a syntax error.
\item {\PFAc \{"double":$\!$ NUMBER\}} where {\PFAc NUMBER} is a JSON floating-point number.  The return type is {\bf double}; a value that is too large, too small, or too precise to be represented as a \href{http://dx.doi.org/10.1109%2FIEEESTD.2008.4610935}{IEEE 754} 64-bit floating point number is a syntax error.
\item {\PFAc \{"string":$\!$ STRING\}} where {\PFAc STRING} is a quoted string.  The return type is {\bf string}.
\item {\PFAc \{"base64":$\!$ STRING\}} where {\PFAc STRING} is a \href{http://www.ietf.org/rfc/rfc3548.txt}{base-64 representation} of a binary input.  The return type is {\bf bytes}.
\item {\PFAc \{"type":$\!$ TYPE, "value":$\!$ VALUE\}} where {\PFAc TYPE} is an Avro schema and {\PFAc VALUE} is a JSON literal ({\it not} an expression) whose type matches {\PFAc TYPE}.  This form can be used to construct arrays, maps, records, etc.
\end{itemize}

Additionally, if an integer appears where an expression is expected, that number is an {\bf int} literal if 32-bit, a {\bf long} literal if 64-bit, and a syntax error if larger.  If a floating point number appears where an expression is expected, that number is a {\bf double} literal (not a {\bf float}, even if small enough).  A floating-point number that is too large, too small, or too precise to be a \href{http://dx.doi.org/10.1109%2FIEEESTD.2008.4610935}{IEEE 754} 64-bit floating point number causes a syntax error.

There is also a shortcut for making {\bf string} literals: {\PFAc [STRING]} (single-element JSON array containing a string).  Note that a string, by itself is interpreted as a \hyperlink{sec:symbol-ref}{symbol reference} (because symbol references are more common than string literals).  In some contexts, such as the argument list of a function, an expression or an array of expressions is expected.  If a {\PFAc [STRING]} appears in one of these contexts, it is interpreted as a one-element array containing a symbol reference, not a literal string.

\hypertarget{hsec:function-call}{}
\subsection{Function calls}
\label{sec:function-call}

Most of the functionality of PFA is provided through function calls; data-centric scoring engines, such as statistical models, would often involve only one function call.  Library functions are part of the PFA definition (\hyperlink{hsec:core-library}{see Sec.~\ref{sec:core-library} et seq.}); user functions are defined in a PFA document (\hyperlink{hsec:user-defined-fcns}{see Sec.~\ref{sec:user-defined-fcns}}).

A function call is expressed in JSON as a single-member object, like this
\begin{json}
{"functionName": [argument1, argument2, ... argumentN]}
\end{json}
for a function {\PFAc functionName} of {\PFAc N} (zero or more) arguments or
\begin{json}
{"functionName": argument1}
\end{json}
for a function of exactly one argument.

The arguments of a function call can either be an expression or a \hyperlink{hsec:referencing-functions}{function reference} (assuming that the called function accepts functions as arguments).

Functions have strict requirements on the number of arguments (always fixed; there are no optional arguments or varargs) and their types.  Functions return a value with a specific type, though that type may depend on the argument types (for library functions).

Function call expressions evaluate all of the function's arguments, from left to right, before calling the function, unless documented otherwise.  For instance, the {\PFAc and} function only evaluates its second argument if the first does not evaluate to {\PFAc false} and the {\PFAc or} function only evaluates its second argument if the first does not evaluate to {\PFAc true}.

The expression in each argument of a function call is evaluated in a separate, sealed-from-above and sealed-within scope (\hyperlink{hsec:symbol-scope}{see Sec.~\ref{sec:symbol-scope}}).  Thus, one cannot declare or reassign symbols as one progresses through the argument list.

\hypertarget{hsec:special-forms}{}
\subsection{Special forms}
\label{sec:special-forms}

Special forms are expressions that take arguments, perform an operation, and return a value, much like function calls.  Unlike function calls, however, they may have irregular syntax.  Whereas a function call is always a JSON object with one member name (the function name) and one member value (its arguments, interpreted as expressions), some special forms have multiple JSON object members and some special forms have custom interpretations for their member values.  These object members may appear in any order.  In addition, special forms have custom scoping rules when they do interpret values as expressions.

\hypertarget{hsec:call-args}{}
\subsection{Call a user-defined function that is specified at runtime}
\label{sec:call-args}

PFA excludes first class functions so that the call graph can be analyzed without running the analytic.  Therefore, all \hyperlink{hsec:function-call}{function calls} and \hyperlink{hsec:fcnref}{function references} are static strings in the JSON text.  However, it is sometimes useful to select a function to call at runtime, so the following special form is available to select a function from a small set.
\begin{json}
{"call": expression, "args": [argument1, argument2, ... argumentN]}
\end{json}
The {\PFAc expression} must resolve to an enumeration type, and the values of the enumeration type must be user-defined functions (without the ``{\PFAc u.}'' prefix).

All functions referenced by the enumeration type must accept the argument types defined by {\PFAc args}.  The return type of this special form is the narrowest supertype of the return types of all referenced functions.  Therefore, the types are verified for all possible values of the {\PFAc expression}.

In the call graph, this special form is presented as the union of all members of the enumeration type.  Therefore, if the enumeration type has symbols ``one'', ``two'', and ``three'', then there must be user-defined functions accepting the arguments presented with compatible return types, and the call graph would include ``u.one'', ``u.two'', and ``u.three'', as well as any functions called in the argument list.  Even if function ``u.three'' is never called at runtime, this special form reports it because it {\it might} be called.

\hypertarget{hsec:new-form}{}
\subsection{Creating arrays, maps, and records}
\label{sec:new-form}

\subsubsection{Creating arrays/maps/records from expressions: the ``new'' special form}

Arrays, maps, and records can be created with the {\PFAc \{"type":$\!$ TYPE, "value":$\!$ VALUE\}} literal form \hyperlink{hsec:literals}{described above}, but the {\PFAc VALUE} must be a JSON literal and not an expression.  Thus, the literal form cannot depend on any inputs.  The ``new'' special form exists to create arrays, maps, and records from expressions:
\begin{json}
{"new": ARRAY, "type": ARRAY-TYPE}
{"new": OBJECT, "type": MAP-OR-RECORD-TYPE}
\end{json}
where {\PFAc ARRAY} is a JSON array of expressions whose type is accepted by Avro schema {\PFAc ARRAY-TYPE}, and {\PFAc OBJECT} is a JSON object whose member values are expressions matching Avro schema {\PFAc MAP-OR-RECORD-TYPE}.

\begin{example}
The following returns an array of powers of {\PFAc x}, which has type {\bf double}.
\begin{json}
{"new": [1, "x", {"**": ["x", 2]}], "type": {"type": "array", "items": "double"}}
\end{json}
\end{example}

\begin{example}
The following returns a map from names to powers of {\PFAc x}, which has type {\bf double}.
\begin{json}
{"new": {"p0": 1, "p1": "x", "p2": {"**": ["x", 2]}},
 "type": {"type": "array", "items": "double"}}
\end{json}
\end{example}

\begin{example}
The following initializes a record of type {\PFAc R} with a {\bf string} stored in {\PFAc x} and its length.
\begin{json}
{"new": {"theString": "x", "theLength": {"s.len": "x"}},
 "type": {"type": "record", "name": "R", "fields":
     [{"name": "theString", "type": "string"},
      {"name": "theLength", "type": "int"}]}}
\end{json}
\end{example}

\hypertarget{hsec:let-set}{}
\subsection{Symbol assignment and reassignment}
\label{sec:let-set}

\subsubsection{Creating symbols: the ``let'' special form}

The ``let'' special form creates new symbols and assigns an initial value.  The ``set'' special form changes the value associated with a set of symbols.  There are no type declarations for new symbols because its types are \hyperlink{hsec:type-inference}{inferred} from the initial value.

A ``let'' has the following syntax:
\begin{json}
{"let": {"name1": VALUE1, "name2": VALUE2, ...}}
\end{json}
where {\PFAc VALUE1}, {\PFAc VALUE2}, etc. are expressions.  These expressions must not depend on symbols defined in the same ``let'' form, and they may be evaluated in any order.  (The symbols can be referenced after the end of the ``let'' form and before the end of its containing form.)  The {\PFAc VALUE} expressions are \hyperlink{hsec:symbol-scope}{sealed-within}: they may not declare new symbols unless wrapped in a ``do'' special form, and cannot change externally declared symbols.

A ``let'' that only declares one symbol still requires a nested JSON object.  The ``let'' form has return type {\bf null}.  It must declare at least one symbol.

\subsubsection{Changing symbol bindings: the ``set'' special form}

A ``set'' has the following syntax:
\begin{json}
{"set": {"name1": VALUE1, "name2": VALUE2, ...}}
\end{json}
where {\PFAc VALUE1}, {\PFAc VALUE2}, etc. are expressions.  These expressions may depend on symbols that are rebound in the same ``set'' form, but if so, they are provided with the old values of those symbols, as defined immediately before the ``set'' form.  The assignments within a ``set'' may be evaluated in any order.  The {\PFAc VALUE} expressions are \hyperlink{hsec:symbol-scope}{sealed-within}, just like the ``let'' form.

A ``set'' that only changes one symbol still requires a nested JSON object.  The ``set'' form has return type {\bf null}.  It must reassign at least one symbol.

\begin{example}
If the following appears in a JSON array of expressions, the final values of {\PFAc x} and {\PFAc y} are 2 and 2 (not 2 and 3 or 3 and 2).
\begin{json}
{"let": {"x": 1, "y": 1}},
{"set": {"x": {"+": ["x", "y"]}, "y": {"+": ["x", "y"]}}}
\end{json}
Regardless of whether {\PFAc x} is reassigned first or {\PFAc y} is reassigned first, each sum sees both {\PFAc x} and {\PFAc y} as having a value of 1 at the time of assignment.
\end{example}

\hypertarget{hsec:attr-form}{}
\subsection{Extracting from and updating arrays, maps, and records}
\label{sec:attr-form}

\subsubsection{Retrieving nested values: the ``attr'' special form}

The ``attr'' special form extracts a value from an array, a map, a record, or any combination of these three.  The ``attr-to'' special form returns an object with one element changed (leaving the original untouched).

The form of ``attr'' is
\begin{json}
{"attr": EXPRESSION, "path": INDEXES}
\end{json}
where {\PFAc EXPRESSION} is the array, map, or record to extract from and {\PFAc INDEXES} is a JSON array of expressions with {\bf int} type or {\bf string} type and string literals.  These {\PFAc INDEXES} specify a path through the nested objects.  If nesting is only one level deep, {\PFAc INDEXES} must have exactly one element.  It is a syntax error for {\PFAc INDEXES} to have zero elements.

If the type at a particular nesting level is an {\bf array}, the path index must resolve to an {\bf int}, though it can perform arbitrary calculations to produce the {\bf int}.  If the type at a particular nesting level is a {\bf map}, the path index must resolve to a {\bf string}.  If the type at a particular nesting level is a {\bf record}, the path index must be a literal {\bf string} (not just an expression that resolves to a {\bf string}), and that string must be a field name of the record.  Since it is a literal string, static analysis can verify that the field name exists and a PFA system should raise a type error if no such field exists.  The nesting level is increased for each array element of the path, and the return type of ``attr'' is the type of the deepest object referenced by the path.

If an array index is out of bounds (at any level of dereferencing along the path), an ``array index not found'' (code \#2000) runtime error is raised. If a map key is not found (at any level of dereferencing along the path), a ``map key not found'' (code \#2001) runtime error is raised. If a record field is not valid, it is a semantic error, a scoring engine cannot be built.

As a convenience, ``attr'' forms may also be expressed as a dot-delimited string resembling a symbol reference.  The first substring is taken to be a symbol reference {\PFAc EXPRESSION} and the rest are taken to be elements of the {\PFAc INDEXES} array (literal expressions only).  PFA systems should implement this short-cut.

\begin{example}
The following are equivalent:
\begin{json}
"x.4.key.field"
\end{json}
and
\begin{json}
{"attr": "x", "path": [4, ["key"], ["field"]]}
\end{json}
and 
\begin{json}
{"attr": {"attr": {"attr": "x", "path": [4]}, "path": [["key"]]}, "path": [["field"]]}
\end{json}
If the type of {\PFAc x} is
\begin{json}
{"type": "array", "items": {"type": "map", "values": {"type": "record", "name": "R",
     "fields": [{"name": "field", "type": X}]}}}
\end{json}
then the example is valid and the return type is {\PFAtp X}.

(Note: {\PFAc ["key"]} and {\PFAc ["field"]} are short-cuts for {\PFAc \{"string":$\!$ "key"\}} and {\PFAc \{"string":$\!$ "field"\}}, respectively; \hyperlink{hsec:literals}{see Sec.~\ref{sec:literals}}.)
\end{example}

\subsubsection{Copy with different nested values: the ``attr-to'' special form}

The form of ``attr-to'' is:
\begin{json}
{"attr": EXPRESSION, "path": INDEXES, "to": VALUE-OR-FUNCTION}
\end{json}
with the same meaning for {\PFAc EXPRESSION} and {\PFAc INDEXES} as in ``attr''.  If the attribute evaluates to {\PFAtp X} at the end of its path, the {\PFAc VALUE-OR-FUNCTION} argument must either be an expression of type {\PFAtp X} or a function that maps {\PFAtp X} to {\PFAtp X}.  If is an expression, then the form will return a structure like the original, but with the specified subelement changed to the new value.  If {\PFAc VALUE-OR-FUNCTION} is a function, then the function is evaluated, passing in the old value of the subelement and updating the structure with the function's return value.

The {\PFAc INDEXES} must contain at least item.  There is no equivalent of using the dot-delimited string as a short-cut.  The ``attr-to'' form returns a whole new structure with one subelement changed; it has the same type as {\PFAc EXPRESSION}.  It must be emphasized that ``attr-to'' does not change the {\PFAc EXPRESSION} or the object it refers to, nor does it reassign any symbols; it returns a new value.

If an array index is out of bounds (at any level of dereferencing along the path), an ``array index not found'' (code \#2002) runtime error is raised. If a map key is not found (at any level of dereferencing along the path), a ``map key not found'' (code \#2003) runtime error is raised. If a record field is not valid, it is a semantic error, a scoring engine cannot be built.

\begin{example}
If {\PFAc x} is an array, we can effectively change one element of {\PFAc x} to {\PFAc xn} by
\begin{json}
{"set": {"x": {"attr": "x", "path": ["n"], "to": "xn"}}}
\end{json}
\end{example}

\begin{example}
If the {\PFAc "x.4.key.field"} subelement is a {\PFAc int}, following are equivalent:
\begin{json}
{"attr": "x", "path": [4, ["key"], ["field"]], "to": {"+": ["x.4.key.field", 1]}}
\end{json}
and 
\begin{json}
{"attr": "x", "path": [4, ["key"], ["field"]], "to":
     {"params": [{"z": "int"}], "ret": "int", "do": {"+": ["z", 1]}}}
\end{json}
The first version represents the same path twice (the second time with dot-notation for brevity), while the second version represents the path once and applies an updator function when it gets to the end of the path.  This updator function could be referenced by name with \hyperlink{hsec:fcnref}{fcnref} for code re-use.
\end{example}

\hypertarget{hsec:cell-pool-forms}{}
\subsection{Extracting from and updating cells and pools}
\label{sec:cell-pool-forms}

Cells and pools (\hyperlink{hsec:cells-pools}{see Sec.~\ref{sec:cells-pools}}) are referenced with ``cell'' and ``pool'' special forms and updated with ``cell-to'', ``pool-to'', and ``pool-del'' special forms.  Subelements in a cell or pool are referenced/updated with a path of the same form as ``\hyperlink{hsec:attr-form}{attr}'', though the ``cell'' and ``cell-to'' forms may be given without any path to specify the cell as a whole.

\subsubsection{Retrieving cell values: the ``cell'' special form}

The ``cell'' special form has the following syntax.
\begin{json}
{"cell": NAME}
\end{json}
or
\begin{json}
{"cell": NAME, "path": INDEXES}
\end{json}
where {\PFAc NAME} is the name of the cell and {\PFAc INDEXES} is a JSON array of {\bf int} and {\bf string} valued expressions (for arrays and maps) and {\bf string} literals (for records).  If a {\PFAc path} is not given, this form returns the value of the specified cell.  If a {\PFAc path} is given, then it walks down the {\PFAc INDEXES} of the {\PFAc path} in the same way as ``attr''.  Unlike ``attr'', {\PFAc INDEXES} may be an empty JSON array, in which case the behavior is the same as if {\PFAc path} had not been specified.

If an array index is out of bounds (at any level of dereferencing along the path), an ``array index not found'' (code \#2004) runtime error is raised. If a map key is not found (at any level of dereferencing along the path), a ``map key not found'' (code \#2005) runtime error is raised. If a record field is not valid, it is a semantic error, a scoring engine cannot be built.

\subsubsection{Changing cell values: the ``cell-to'' special form}

The ``cell-to'' special form has the following syntax.
\begin{json}
{"cell": NAME, "to": VALUE-OR-FUNCTION}
\end{json}
or
\begin{json}
{"cell": NAME, "path": INDEXES, "to": VALUE-OR-FUNCTION}
\end{json}
where {\PFAc VALUE-OR-FUNCTION} is expression of type {\PFAtp X} or a function that maps {\PFAtp X} to {\PFAtp X}, assuming that the cell or subelement has type {\PFAtp X}.  Like ``attr-to'', the {\PFAc to} field replaces the cell or subelement at the end of the path with {\PFAc VALUE-OR-FUNCTION} if it is a value or evaluates {\PFAc VALUE-OR-FUNCTION} on the subelement if it is a function.  Like ``attr-to'', the return value is the new cell value.  Unlike ``attr-to'', the cell is changed in-place: subsequent calls to extract the cell value will get the new value, rather than the old one.  If the old value (or its parts) were previously copied into a local symbol, those copies are unchanged.

If an array index is out of bounds (at any level of dereferencing along the path), an ``array index not found'' (code \#2006) runtime error is raised. If a map key is not found (at any level of dereferencing along the path), a ``map key not found'' (code \#2007) runtime error is raised. If a record field is not valid, it is a semantic error, a scoring engine cannot be built.

\begin{example}
For example, suppose that {\PFAc myCell} is a cell containing an array of {\bf string} and {\PFAc n} is an index within the bounds of the array.
\begin{json}
{"let": {"x": {"cell": "myCell"}, "y": {"cell": "myCell", "path": ["n"]}}},
{"cell": "myCell", "path": ["n"], "to": {"string": "hello"}}
\end{json}
The first line retrieves the value of the cell and a subelement of the cell, putting them in local symbols {\PFAc x} and {\PFAc y}.  The second line changes {\PFAc myCell} in such a way that element {\PFAc n} (only) is now {\PFAc "hello"}.  However, both {\PFAc x} and {\PFAc y} are unchanged--- they continue to reference the old value of {\PFAc myCell} and its components.
\end{example}

For ``attr-to'', the difference between the value form and the function form of {\PFAc VALUE-OR-FUNCTION} is just a matter of style (whether the path is repeated or the function can be re-used).  For shared cells, choosing between the value form and the function form of {\PFAc VALUE-OR-FUNCTION} in ``cell-to'' could make a difference in the behavior of the scoring engine.  If a cell is extracted and replaced in two steps, then it is possible for another scoring engine sharing that value to modify it between the extraction step and the replacement step.  The function form, however, is atomic: all other attempts to modify the value wait until it is done.

\begin{example}
Suppose that {\PFAc myCell} is a shared cell that we want to increment by 1.  If we use
\begin{json}
{"cell": "myCell", "to": {"+": [{"cell": "myCell"}, 1]}}
\end{json}
in multiple scoring engines, then it is possible that their calls to ``cell'' and ``cell-to'' might interleave.  In this sequence of operations:
\begin{enumerate}
\item value of {\PFAc myCell} is 5
\item scoring engine A gets the value of {\PFAc myCell} (5)
\item scoring engine B gets the value of {\PFAc myCell} (5)
\item scoring engine A adds 1 to 5 and sets the value of {\PFAc myCell} to the result (6)
\item scoring engine B adds 1 to 5 and sets the value of {\PFAc myCell} to the result (6)
\end{enumerate}
{\PFAc myCell} is only incremented once, though two scoring engines attempted to increment it.  If steps 3 and 4 were reversed (a race condition), the final result would be 7, rather than 6.

Instead, we should increment a cell with the function form:
\begin{json}
{"cell": "myCell", "to":
     {"params": [{"x": "int"}], "ret": "int", "do": {"+": ["x", 1]}}}
\end{json}
\end{example}

The same applies to subelements of a cell specified by a {\PFAc path}.  If a {\PFAc path} is used, the granularity of the writers lock is at the level of the whole cell: two scoring engines cannot modify different parts of the same cell at the same time.  Calls to ``cell'' (readers) are never blocked: they always see the old version of the cell until the ``cell-to'' function finishes (\hyperlink{hsec:concurrent}{see Sec.~\ref{sec:concurrent}}).

The functions passed to ``cell-to'' are restricted: they should not be allowed to call any ``cell-to'' or ``path-to'' at any level of their call graphs.  (That is, they cannot modify cells or pools and the functions that they call cannot modify cells or pools, including any functions those functions call, etc.)  This constraint should be enforced by a PFA system that supports shared cells, since it excludes the possibility of deadlock.

\subsubsection{Retrieving pool values: the ``pool'' special form}

The ``pool'' special form is similar to ``cell'', except that a {\PFAc path} is always required.
\begin{json}
{"pool": NAME, "path": INDEXES}
\end{json}
The {\PFAc INDEXES} must not be empty, and the first item must be a literal string naming the desired object in the pool's namespace.

If an array index is out of bounds (at any level of dereferencing along the path), an ``array index not found'' (code \#2008) runtime error is raised. If a map key is not found (at any level of dereferencing along the path, including the pool item itself), a ``map key not found'' (code \#2009) runtime error is raised. If a record field is not valid, it is a semantic error, a scoring engine cannot be built.

\subsubsection{Creating or changing pool values: the ``pool-to'' special form}

The ``pool-to'' special form is similar to ``cell-to'', except that the {\PFAc path} is always required and an {\PFAc init} is required to handle the case in which the desired pool element is missing.
\begin{json}
{"pool": NAME, "path": INDEXES, "to": FUNCTION, "init": VALUE}
\end{json}
Unlike a cell, a pool element might not exist at runtime.  If it does not exist, the element is created with initial value {\PFAc VALUE} and then the {\PFAc to} replacement or function is applied.  The {\PFAc VALUE} specified by {\PFAc init} must have the type of a pool element.  The ``pool-to'' form changes the value of the pool element in-place (like ``cell-to'') and returns the new value of the pool element.

The same concurrency issues apply to shared pools as to shared cells.  The check for existence and update or the check for existence, creation, and update are all performed in one atomic operation.  The granularity of the writers lock is on a single pool element, not the whole pool and not a part of the element.

Some PFA systems may implement shared cells and pools with a networked database.  If so, they can take advantage of the {\PFAc path} in the ``cell'' special form or the ``pool'' special form to only transfer the relevant subelement of the cell or pool over the network, rather than sending the whole data structure and extracting the subelement afterward.

If an array index is out of bounds (at any level of dereferencing along the path), an ``array index not found'' (code \#2010) runtime error is raised. If a map key is not found (at any level of dereferencing along the path), a ``map key not found'' (code \#2011) runtime error is raised. If a record field is not valid, it is a semantic error, a scoring engine cannot be built.

\subsubsection{Removing pool values: the ``pool-del'' special form}

The ``pool-del'' special form specifies a pool item for removal.
\begin{json}
{"pool": NAME, "del": EXPRESSION}
\end{json}
The {\PFAc EXPRESSION} must evaluate to a string, naming the pool item, and the special form returns {\PFAc null}.

The same concurrency rules apply to ``pool-del'' as to ``pool-to''.  If scoring engine A begins a ``pool-to'' on an item before scoring engine B begins a ``pool-del'' on the same item, the end result is that the item will be deleted (either by letting the update continue and then deleting the item when done or by intelligently stopping the update). If scoring engine A begins a ``pool-del'' on an item before scoring engine B begins a ``pool-to'' on the same item, the update will proceed as though the item never existed (that is, using the ``pool-to'' {\PFAc init}).

Some PFA systems may implement shared pools with a networked database.  If so, the ``pool-del'' is an atomic transaction that must be queued in the same queue with ``pool-to'' (for the same item). No errors are raised when the pool item is not found.

\subsection{Tree-like structures in the program flow}

\subsubsection{Expanding an expression into a mini-program: the ``do'' special form}

A ``do'' special form allows the PFA document author to insert a series of expressions where one expression is expected.  It has the following syntax.
\begin{json}
{"do": ARRAY-OF-EXPRESSIONS}
\end{json}
where {\PFAc ARRAY-OF-EXPRESSIONS} is a JSON array of expressions and the whole form is one expression.  The return value is the value of the last expression in the JSON array, which must not be empty.

It is also possible for {\PFAc ARRAY-OF-EXPRESSIONS} to be replaced with a single expression, though doing so would defeat the purpose of a ``do'' block.  This option exists for symmetry with other, similar forms.

\begin{example}
A ``do'' form is also useful for declaring symbols in a sealed-within scope (\hyperlink{hsec:symbol-scope}{see Sec.~\ref{sec:symbol-scope}}).  For instance, new symbols usually cannot be declared in a function's argument list, but sometimes it is useful to insert a mini-program as an argument (in a purely functional style).  For instance,
\begin{json}
{"someFunction": [
     "simpleArgument",
     {"do": [
          {"let": {"x": 0}},
          {"while": {"notDone": "x"}, "do": {"set": {"x": {"iterate": "x"}}}}
          "x"
     ]},
     "simpleArgument"]}
\end{json}
The first and third arguments to {\PFAc someFunction} are just references to a symbol named {\PFAc simpleArgument}, but the second argument is a mini-program that calls {\PFAc iterate} on a value until {\PFAc notDone} is {\PFAc false}.
\end{example}

\begin{example}
Although a ``do'' block can loosen a sealed-within scope, it cannot loosen its sealed-from-above attribute.  Symbols declared outside of a sealed-from-above scope cannot be modified in that scope, even within a ``do'' block.  For example, the following is invalid (a semantic error).
\begin{json}
{"let": {"outerSymbol": 0}},
{"someFunction": [
     {"do": [
          {"set": {"outerSymbol": 1}},
          "outerSymbol"
     ]}]}
\end{json}
because the scope of function arguments are sealed-from-above.
\end{example}

\begin{example}
A ``do'' block does not apply any additional constraints on the scope of symbols.  The following attempt to modify an outside symbols is valid.
\begin{json}
{"let": {"outerSymbol": 0}},
{"do": [
     {"set": {"outerSymbol": 1}},
     "outerSymbol"
]}
\end{json}
\end{example}

\subsection{Branching the program flow}

Conditionals cause a branch in the program flow, in which the expressions that are evaluated depend on values at runtime.

\subsubsection{Conditional with one or two cases: the ``if'' special form}

The ``if'' special form has the following syntax:
\begin{json}
{"if": CONDITION, "then": EXPRESSION-OR-EXPRESSIONS}
\end{json}
or
\begin{json}
{"if": CONDITION, "then": EXPRESSION-OR-EXPRESSIONS, "else": EXPRESSION-OR-EXPRESSIONS}
\end{json}
where {\PFAc CONDITION} is a single expression that evaluates to {\bf boolean} and {\PFAc EXPRESSION-OR-EXPRESSIONS} is either a single expression or a JSON array of expressions.  The form without an {\PFAc else} clause returns {\PFAc null}, but the form with an {\PFAc else} clause returns the \hyperlink{hsec:narrowest-supertype}{narrowest supertype} of the {\PFAc then} and {\PFAc else} clauses.

The {\PFAc CONDITION} expression is evaluated in a sealed-from-above, sealed-within scope, but the {\PFAc then} and {\PFAc else} clauses are unsealed (\hyperlink{hsec:symbol-scope}{see Sec.~\ref{sec:symbol-scope}}).  That is, an outside symbol cannot be modified in the {\PFAc CONDITION}, but it can be modified in the {\PFAc then} and {\PFAc else} clauses.  In an imperative programming style, {\PFAc then} and {\PFAc else} are primarily used to assign values to symbols defined outside the ``if''.  In a functional programming style, the return value of the entire ``if'' form would be assigned to a symbol.

\subsubsection{Conditional with many cases: the ``cond'' special form}

The ``cond'' special form allows one to chain a series of conditionals.
\begin{json}
{"cond": [{"if": CONDITION1, "then": EXPRS1}, {"if": CONDITION2, "then": EXPRS2}, ...]}
\end{json}
or
\begin{json}
{"cond": [{"if": CONDITION1, "then": EXPRS1}, {"if": CONDITION2, "then": EXPRS2}, ...],
 "else": EXPRS}
\end{json}
The ``if'' forms within a ``cond'' are like stand-alone ``if'' forms except that they cannot have {\PFAc else} clauses.  The ``cond'' form can have a single {\PFAc else} clause.  Much like an ``if'', the return value of ``cond'' is {\PFAc null} if {\PFAc else} is absent, and it is the narrowest supertype of all {\PFAc then} clauses and the {\PFAc else} clause if the {\PFAc else} is present.  A ``cond'' must have at least one ``if''.  The {\PFAc CONDITION1}, {\PFAc CONDITION2}, \ldots\ are all single expressions that are sealed-from-above and sealed-within, and the {\PFAc EXPRS1}, {\PFAc EXPRS2}, \ldots\ and {\PFAc EXPRS} are either single expressions or JSON arrays of expressions that are unsealed.  The {\PFAc then} clause corresponding to the first (and only the first) successful {\PFAc if} condition is evaluated, or the {\PFAc else} clause is evaluated if no {\PFAc if} conditions are successful.

\subsection{Loops in the program flow}

Loops repeatedly evaluate a set of expressions until some condition is met at runtime.

\subsubsection{Generic pre-test loop: the ``while'' special form}

The pre-test ``while'' special form has the following syntax.
\begin{json}
{"while": CONDITION, "do": EXPRESSION-OR-EXPRESSIONS}
\end{json}
where {\PFAc CONDITION} is a single expression that evaluates to {\bf boolean} and {\PFAc EXPRESSION-OR-EXPRESSIONS} is either a single expression or a JSON array of expressions.  The return value of the ``while'' form is {\PFAc null}: it can only be used to modify state.  The scope of the {\PFAc CONDITION} is sealed-from-above and sealed-within, but the scope of the {\PFAc EXPRESSION-OR-EXPRESSIONS} is unsealed (\hyperlink{hsec:symbol-scope}{see Sec.~\ref{sec:symbol-scope}}).

The {\PFAc CONDITION} is evaluated before the {\PFAc EXPRESSION-OR-EXPRESSIONS} and the two are evaluated in alternation until {\PFAc CONDITION} returns {\PFAc false}.  If {\PFAc CONDITION} returns {\PFAc false} the first time it is called, the {\PFAc EXPRESSION-OR-EXPRESSIONS} would never be evaluated.

\subsubsection{Generic post-test loop: the ``do-until'' special form}

The post-test ``do-until'' special form has the following syntax.
\begin{json}
{"do": EXPRESSION-OR-EXPRESSIONS, "until": CONDITION}
\end{json}
Like ``while'', the {\PFAc CONDITION} is a single expression that evaluates to {\bf boolean} and {\PFAc EXPRESSION-OR-EXPRESSIONS} is either a single expression or a JSON array of expressions.  The return value is {\PFAc null}.  The difference is that the alternation between evaluating {\PFAc EXPRESSION-OR-EXPRESSIONS} and {\PFAc CONDITION} starts with the {\PFAc EXPRESSION-OR-EXPRESSIONS} and continues until {\PFAc CONDITION} is {\PFAc true}.  Thus, the {\PFAc EXPRESSION-OR-EXPRESSIONS} is evaluated at least once, even if {\PFAc CONDITION} is always {\PFAc true}.

\subsubsection{Iteration with dummy variables: the ``for'' special form}

For loops are specialized loops that declare new symbols for use in the loop body.  There are three basic types: ``for'' loops, which are usually used to increment a numerical index, ``foreach'' loops, which iterate over values of an array, and ``forkey-forval'' loops, which iterate over key-value pairs of a map.

The ``for'' special form has the following syntax.
\begin{json}
{"for": NAME-TO-EXPRESSION, "while": CONDITION, "step": NAME-TO-EXPRESSION,
 "do": EXPRESSION-OR-EXPRESSIONS}
\end{json}
The {\PFAc for} clause's {\PFAc NAME-TO-EXPRESSION} is a JSON object whose members are new symbols to declare, the {\PFAc step} clause's {\PFAc NAME-TO-EXPRESSION} is a JSON object whose members are symbols to modify, and {\PFAc while} is a {\bf boolean}-valued single expression that stops the iteration when it becomes {\PFAc false}.  The {\PFAc do} expression or expressions is the body of the loop, and the return value of the ``for'' form is {\PFAc null}.

The {\PFAc for} clause's {\PFAc NAME-TO-EXPRESSION} is similar to a \hyperlink{hsec:let-set}{let expression} in that it declares and initializes new symbols.  The names of the symbols are the member names of the {\PFAc NAME-TO-EXPRESSION} and the initial values are the evaluated results of the member values.  The scope of the initialization expressions are sealed-from-above and sealed-within (\hyperlink{hsec:symbol-scope}{see Sec.~\ref{sec:symbol-scope}}), and they are evaluated before anything else in the ``if'' form but the order of initialization expressions is not guaranteed.  The symbols declared by the {\PFAc for} clause can only be referenced in the {\PFAc while}, {\PFAc step}, and {\PFAc do} clauses.

The {\PFAc step} clause's {\PFAc NAME-TO-EXPRESSION} is similar to a \hyperlink{hsec:let-set}{set expression} in that it changes symbols, usually by incrementing them.  The names of the symbols to modify are the member names of the {\PFAc NAME-TO-EXPRESSION} and their new values are the evaluated results of the member values.  The scope of the updator expressions are sealed-from-above and sealed-within, and if any updator expressions depend on a symbol that is also being updated, they will see the old value of the symbol.  That way, they can be evaluated in any order without conflict, which is important because their order is not guaranteed.

The {\PFAc while} expression is sealed-from-above and sealed-within.  It is evaluated before the loop body ({\PFAc do}), so it is possible for the loop body to never be evaluated.

The {\PFAc do} expression or expressions is evaluated while the {\PFAc CONDITION} is {\PFAc true}.  The symbols declared by the {\PFAc for} clause may be referenced and even modified, though it is good practice to modify these loop variables only in the {\PFAc step} clause.  The body of the loop is unsealed, meaning that it can modify symbols defined outside of its scope.

\begin{example}
This is a basic for loop that indexes the loop iteration with an integer {\PFAc i}.
\begin{json}
{"for": {"i": 0}, "while": {"<": ["i", 10]}, "step": {"i": {"+": ["i", 1]}},
 "do": [
     {"something": i}
     {"somethingElse": i}
 ]}
\end{json}
The {\PFAc something} and {\PFAc somethingElse} functions are called with arguments from 0 (inclusive) until 10 (exclusive).
\end{example}

\subsubsection{Iteration over arrays: the ``foreach'' special form}

The ``foreach'' special form iterates over elements of an array.  It has the following syntax.
\begin{json}
{"foreach": NAME, "in": ARRAY-EXPRESSION, "do": EXPRESSION-OR-EXPRESSIONS}
\end{json}
or
\begin{json}
{"foreach": NAME, "in": ARRAY-EXPRESSION, "do": EXPRESSION-OR-EXPRESSIONS,
 "seq": TRUE-OR-FALSE}
\end{json}
where {\PFAc NAME} is a string naming the new symbol to declare, {\PFAc ARRAY-EXPRESSION} is a single expression whose type is an {\bf array}, the {\PFAc do} expression or expressions is the body of the loop, and the return value of the ``for'' form is {\PFAc null}.  The {\PFAc seq} flag, if absent or set to {\PFAc true}, ensures that the loop order through the array is sequential.  This flag affects the scope of symbols, so that a PFA system has the option to evaluate the loop body in parallel if the {\PFAc seq} flag is present and {\PFAc false}.

The symbol declared by the {\PFAc foreach} clause can be referenced only in the body of the loop.  The {\PFAc ARRAY-EXPRESSION} is sealed-from-above and sealed-within.  If the return type of the {\PFAc ARRAY-EXPRESSION} is an array of {\PFAtp X}, the symbol declared by {\PFAc foreach} has type {\PFAc X}.

The loop body is evaluated once for every element in the array specified by the {\PFAc in} clause.  Since the array might be empty, the loop body might never be evaluated.  If {\PFAc seq} is absent or {\PFAc false}, the order of elements is not guaranteed and the loop scope is sealed-from-above.  Some PFA implementations may take advantage of this fact to parallelize the loop.  (If so, all cells and pools referenced within the loop must be treated as though they are shared.)  If {\PFAc seq} is absent or {\PFAc true}, then the elements of the array are processed in order and the loop scope is not sealed-from-above.

\subsubsection{Iteration over maps: the ``forkey-forval'' special form}

The ``forkey-forval'' special form iterates over key-value pairs of a map.  It has the following syntax.
\begin{json}
{"forkey": NAME1, "forval": NAME2, "in": MAP-EXPRESSION,
 "do": EXPRESSION-OR-EXPRESSIONS}
\end{json}
where {\PFAc NAME1} is a string naming a new symbol that iterates through map keys, {\PFAc NAME2} is a string naming a new symbol that iterates through map values, {\PFAc MAP-EXPRESSION} is a single expression whose type is a {\bf map}, the {\PFAc do} expression or expressions is the body of the loop, and the return value of the ``forkey-forval'' form is {\PFAc null}.

The symbols declared by the {\PFAc forkey} and {\PFAc forval} clauses can be referenced only in the body of the loop.  The {\PFAc MAP-EXPRESSION} is sealed-from-above and sealed-within.  If the return type of the {\PFAc MAP-EXPRESSION} is a map of {\PFAtp X}, the symbol declared by {\PFAc forval} has type {\PFAtp X}.  The symbol declared by {\PFAc forkey} has type {\bf string}.

The loop body is evaluated once for every key-value pair in the map specified by the {\PFAc in} clause.  Since the map might be empty, the loop body might never be evaluated.  The order of elements is not guaranteed, but the loop scope is unsealed.  An order-dependent calculation may yield different results every time it is evaluated, so it is good practice to only perform order-independent operations in a ``forkey-forval'' loop.

\hypertarget{hsec:casting}{}
\subsection{Type-safe casting}
\label{sec:casting}

Unrestricted type-casting would invalidate the guarantees that a static type check provides.  It is allowed in many popular programming languages, and if an incorrect type-cast is encountered at runtime, an exception (Java) or undefined behavior (C++) ensues.

However, it is possible to provide the advantages of type-casting without invalidating the static type check.  Instead of returning the type-cast object as a single expression, we split the program flow into branches, one for each possible down-cast type.  For instance, if a possibly-missing input datum has type {\bf union(null, double)}, we split the program flow into a branch that handles the {\bf null} case and a branch that handles the {\bf double} case.  Thus, the type-cast is a special kind of conditional.

\subsubsection{Narrowing a type: the ``cast-cases'' special form}

Down-casting (making a value's type more specific) is handled by the ``cast-cases'' special form, which has the following syntax.
\begin{json}
{"cast": EXPRESSION, "cases": [
     {"as": TYPE1, "named": NAME1, "do": EXPRESSION-OR-EXPRESSIONS1},
     {"as": TYPE2, "named": NAME2, "do": EXPRESSION-OR-EXPRESSIONS2},
     ...
]}
\end{json}
or
\begin{json}
{"cast": EXPRESSION, "cases": [
     {"as": TYPE1, "named": NAME1, "do": EXPRESSION-OR-EXPRESSIONS1},
     {"as": TYPE2, "named": NAME2, "do": EXPRESSION-OR-EXPRESSIONS2},
     ...],
 "partial": TRUE-OR-FALSE}
\end{json}
The {\PFAc cast} clause evaluates a single {\PFAc EXPRESSION} with some type {\PFAtp X}.  The {\PFAc as} clauses enumerate possible subtypes {\PFAtp Y}$_i$ of {\PFAtp X}.  If {\PFAtp X} does not accept {\PFAtp Y}$_i$, then branch $i$ can never be reached, which should result in a semantic exception.  If {\PFAc partial} is absent or {\PFAc false}, then the Avro type schemae named by {\PFAc as} clauses should be exhaustive, there must be at least two cases, and the ``cast-cases'' form returns the last value of the followed branch.  If {\PFAc partial} is present and {\PFAc true}, then the types named by {\PFAc as} clauses do not need to be exhaustive, there must be at least one case, and the ``cast-cases'' form returns {\PFAc null}.  Only one branch is followed: the one with the first matching type schema.

The {\PFAc named} clause takes a string that declares a new symbol with the given name.  The new symbol can be referenced only within the corresponding {\PFAc do} expression or expressions.  Since the scopes of the {\PFAc do} clauses do not overlap, cases may re-use names without shadowing.

The {\PFAc cast} expression is sealed-from-above and sealed-within, but the {\PFAc do} expressions are unsealed (\hyperlink{hsec:symbol-scope}{see Sec.~\ref{sec:symbol-scope}}).

\begin{example}
This replaces a missing value in the {\PFAc input} symbol by a default value, assuming that the PFA document's input type {\PFAc [null, double]} (union of {\bf null} and {\bf double}).  The ``cast-cases'' form is used as an expression that initializes {\PFAc normalizedInput}.
\begin{json}
{"let": {"normalizedInput":
     {"cast": "input", "cases": [
          {"as": "null", "named": "x", "do": -1000.0},
          {"as": "double", "named": "x", "do": "x"}
     ]}}}
\end{json}
\end{example}

\begin{example}
Alternatively, we could use an imperative programming style and overwrite a default value, like the following.
\begin{json}
{"let": {"normalizedInput": -1000.0}},
{"cast": "input", "cases":
     [{"as: "double", "named": "x", "do": {"set": {"normalizedInput": "x"}}}]
 "partial": true}
\end{json}
\end{example}

\subsubsection{Widening a type: the ``upcast'' special form}

It is sometimes (rarely) useful to up-cast a value, making it less specific.  This is handled by the ``upcast'' expression, which simply returns the casted value.
\begin{json}
{"upcast": EXPRESSION, "as": TYPE}
\end{json}
The Avro type schema specified by {\PFAc as} should accept the return type of {\PFAc EXPRESSION} and raise a semantic error if it does not.

\subsubsection{Checking missing values: the ``ifnotnull'' special form}

A special case that is frequently used in PFA is to cast a union of {\PFAtp X} and {\bf null} to {\PFAtp X}.  Null is used to represent missing values, so this would branch the program flow based on whether the value is missing or not.  Moreover, some datasets have many fields that could be missing and it is useful to isolate the case in which none of them are, in fact, missing.  This could be accomplished with nested ``cast-cases'' forms, but the nesting level would be very deep and unwieldy, even for automated processing.

To simplify the PFA document, the ``ifnotnull'' special form only performs a {\bf null}-removing cast, but it applies to one or more symbols simultaneously.  It has the following syntax.
\begin{json}
{"ifnotnull": {SYM1: EXPR1, ... SYMN: EXPRN}, "then": EXPRESSION-OR-EXPRESSIONS}
\end{json}
or
\begin{json}
{"ifnotnull": {SYM1: EXPR1, ... SYMN: EXPRN}, "then": EXPRESSION-OR-EXPRESSIONS,
 "else": EXPRESSION-OR-EXPRESSIONS}
\end{json}
where {\PFAc SYM1} \ldots\ {\PFAc SYMN} are as-yet undefined symbols, {\PFAc EXPR1} \ldots\ {\PFAc EXPRN} are single expressions, and \\ {\PFAc EXPRESSION-OR-EXPRESSIONS} are expressions or JSON arrays of expressions.

All of the {\PFAc EXPR1} \ldots\ {\PFAc EXPRN} expressions are evaluated, in an unspecified order, with sealed-from-above and sealed-within scope.  Each of these expressions must have a union type that includes {\bf null}, though they may have different types from one another.

If all of the {\PFAc EXPR1} \ldots\ {\PFAc EXPRN} expressions are not null, their values are assigned to new symbols {\PFAc SYM1} \ldots\ {\PFAc SYMN}, respectively.  If the type of some {\PFAc EXPR} is {\bf union(X, null)}, the corresponding {\PFAc SYM} has type {\bf X}.  If the type of some {\PFAc EXPR} is {\bf union(X, Y, \ldots\ null)}, the corresponding {\PFAc SYM} has type {\bf union(X, Y, \ldots)}.  These symbols are only defined in the scope of the {\PFAc then} clause.

If all of the {\PFAc EXPR1} \ldots\ {\PFAc EXPRN} expressions are not null, the {\PFAc then} clause is executed with the new symbols in scope.  If any of the {\PFAc EXPR1} \ldots\ {\PFAc EXPRN} expressions are null and the {\PFAc else} clause exists, the {\PFAc else} clause is executed without any new symbols in scope.  The {\PFAc then} and {\PFAc else} clauses have no scope constraints.

The ``ifnotnull'' form without an {\PFAc else} clause returns {\PFAc null}, but the form with an {\PFAc else} clause returns the \hyperlink{hsec:narrowest-supertype}{narrowest supertype} of the {\PFAc then} and {\PFAc else} clauses.

\subsubsection{Extracting values from binary: the ``unpack'' special form}

Sometimes inputs to a model are not provided as well-structured values but as a block of binary data.  The ``unpack'' special form interprets a {\bf bytes} object as a set of new variables that can be used in a block of expressions.  The syntax is
\begin{json}
{"unpack": BYTES-EXPRESSION, "format": [{SYM1: FORMAT1}, ... {SYMN: FORMATN}],
 "then": EXPRESSION-OR-EXPRESSIONS}
\end{json}
to simply split the flow (returning {\PFAc null}) or
\begin{json}
{"unpack": BYTES-EXPRESSION, "format": [{SYM1: FORMAT1}, ... {SYMN: FORMATN}],
 "then": EXPRESSION-OR-EXPRESSIONS, "else": EXPRESSION-OR-EXPRESSIONS}
\end{json}
to provide for the case in which the {\PFAc FORMAT} does not match the {\PFAc BYTES-EXPRESSION}.  In both cases, \\ {\PFAc BYTES-EXPRESSION} is an expression whose return value is {\bf bytes}, {\PFAc SYM1} \ldots\ {\PFAc SYMN} are as-yet undefined symbols, {\PFAc FORMAT1} \ldots \ {\PFAc FORMATN} are format-specifiers, described below, and {\PFAc EXPRESSION-OR-EXPRESSIONS} are expressions or JSON arrays of expressions.  The latter case returns the result of the {\PFAc then} clause or the {\PFAc else} clause, whose type is the \hyperlink{hsec:narrowest-supertype}{narrowest supertype} of the two.

Format specifiers are JSON strings that satisfy one of the following regular expressions, where {\PFAc \textbackslash E} is {\PFAc (<|>|!|little|big|network)?}, {\PFAc \textbackslash U} is {\PFAc unsigned}, and {\PFAc \textbackslash s} is any whitespace character.  If an endianness is not provided, big-endian is assumed.

\noindent \begin{longtable}{p{0.55\linewidth} p{0.22\linewidth} p{0.15\linewidth}}
{\PFAc FORMAT} & {\bf Result} & {\bf PFA Type} \\\hline
{\PFAc \textbackslash s*pad\textbackslash s*} & skips one byte & {\bf null} \\
{\PFAc \textbackslash s*boolean\textbackslash s*} & interprets one byte as true if nonzero & {\bf boolean} \\
{\PFAc \textbackslash s*(byte|int8)\textbackslash s*} & one byte as signed integer & {\bf int} \\
{\PFAc \textbackslash s*\textbackslash U\textbackslash s*(byte|int8)\textbackslash s*} & one byte as non-negative integer & {\bf int} \\
{\PFAc \textbackslash s*\textbackslash E\textbackslash s*(short|int16)\textbackslash s*} & two bytes as signed integer & {\bf int} \\
{\PFAc \textbackslash s*\textbackslash E\textbackslash s*(\textbackslash U\textbackslash s*short|\textbackslash U\textbackslash s*int16)\textbackslash s*} & two bytes as non-negative integer & {\bf int} \\
{\PFAc \textbackslash s*\textbackslash E\textbackslash s*(int|int32)\textbackslash s*} & four bytes as signed integer & {\bf int} \\
{\PFAc \textbackslash s*\textbackslash E\textbackslash s*(\textbackslash U\textbackslash s*int|\textbackslash U\textbackslash s*int32)\textbackslash s*} & four bytes as non-negative integer & {\bf long} \\
{\PFAc \textbackslash s*\textbackslash E\textbackslash s*(long|long\textbackslash s+long|int64)\textbackslash s*} & eight bytes as signed integer & {\bf long} \\
{\PFAc \textbackslash s*\textbackslash E\textbackslash s*(\textbackslash U\textbackslash s*long|\textbackslash U\textbackslash s*long\textbackslash s+long|\textbackslash U\textbackslash s*int64)\textbackslash s*} & eight bytes as non-negative integer & {\bf double} \\
{\PFAc \textbackslash s*\textbackslash E\textbackslash s*(float|float32)\textbackslash s*} & four bytes as \href{http://dx.doi.org/10.1109%2FIEEESTD.2008.4610935}{IEEE 754} floating point number & {\bf float} \\
{\PFAc \textbackslash s*\textbackslash E\textbackslash s*(double|float64)\textbackslash s*} & eight bytes as \href{http://dx.doi.org/10.1109%2FIEEESTD.2008.4610935}{IEEE 754} floating point number & {\bf double} \\
{\PFAc \textbackslash s*raw\textbackslash s*[0-9}+\textbackslash s*] & extract fixed number of bytes & {\bf bytes} \\
{\PFAc \textbackslash s*null\textbackslash s*?terminated\textbackslash s*} & extract bytes until terminated by zero & {\bf bytes} \\
 & (excluding terminus) &  \\
{\PFAc \textbackslash s*length\textbackslash s*?prefixed\textbackslash s*} & interpret first byte as a size, then extract that many bytes & {\bf bytes} \\
 & (excluding size byte) & \\
\end{longtable}

If the fixed-width format specifiers and variable-width pattern specifiers (null-terminated and length-prefixed) does not use exactly the number of bytes provided in the {\PFAc BYTES-EXPRESSION}, the {\PFAc then} clause will not be evaluated.  If an {\PFAc else} clause is present, this is the clause that would be evaluated in this case.

\subsubsection{Encoding values in binary: the ``pack'' special form}

The ``pack'' special form does the opposite of the ``unpack'' form: it encodes a set of values into a byte array.  It has this syntax:
\begin{json}
{"pack": [{FORMAT1: EXPRESSION1}, ... {FORMATN: EXPRESSIONN}]}
\end{json}
where {\PFAc FORMAT1} \ldots\ {\PFAc FORMATN} are format specifiers and {\PFAc EXPRESSION1} \ldots\ {\PFAc EXPRESSIONN} are expressions whose types must correspond to the format specifiers.

The ``pack'' special form has the same format specifiers as ``unpack'' except for one additional specifier:

\noindent \begin{longtable}{p{0.55\linewidth} p{0.22\linewidth} p{0.15\linewidth}}
{\PFAc FORMAT} & {\bf Result} & {\bf PFA Type} \\\hline
{\PFAc \textbackslash s*raw\textbackslash s*} & any number of bytes & {\bf bytes} \\
\end{longtable}

The return type of the ``pack'' special form is {\bf bytes}.

If the size of a fixed-width bytes format does not match the size of the bytes expression, a ``raw bytes does not have specified size'' (code \#3000) runtime error is raised. If a bytes expression for a length-prefixed format is too large, a ``length prefixed bytes is larger than 255 bytes'' (code \#3001) runtime error is raised.

\subsection{Miscellaneous special forms}

\hypertarget{hsec:inline-doc}{}
\subsubsection{Inline documentation: the ``doc'' special form}
\label{sec:inline-doc}

JSON has no means of including comments.  Auto-generated code usually doesn't need comments, but there may be occasions in which it is useful to embed inactive statements in a PFA document.

The ``doc'' special form has the following syntax.
\begin{json}
{"doc": STRING}
\end{json}
Unlike a comment in a programming language, it occupies a slot in the syntax tree.  If inactive expressions are ever needed (the equivalent of Python's {\PFAc pass} keyword), one could use a ``doc'' with an empty {\PFAc STRING}.  This form returns {\PFAc null}.

\hypertarget{hsec:exception-form}{}
\subsubsection{User-defined exceptions: the ``error'' special form}
\label{sec:exception-form}

PFA provides non-local exits to stop the evaluation of a {\PFAc begin}, {\PFAc action}, or {\PFAc end} routine that behave like exceptions (\hyperlink{hsec:exceptions}{see Sec.~\ref{sec:exceptions}}).  Some library functions raise exceptions, but the PFA author can also raise user-defined exceptions.  The PFA engine is free to halt execution or just skip to the next input datum upon encountering an exception.

The ``error'' special form raises user-defined exceptions.  It has the following syntax.
\begin{json}
{"error": STRING}
\end{json}
or
\begin{json}
{"error": STRING, "code": NEGATIVE-INTEGER}
\end{json}
The {\PFAc STRING} is the error message, and if a {\PFAc code} is provided, it provides a safer way to identify specific errors than a human-readable message. User-defined error codes are negative to distinguish themselves from the library functions.

The ``error'' form has no return type: specifically, its return type is a type that can never be instantiated, called a bottom type.  The \hyperlink{hsec:narrowest-supertype}{narrowest supertype} of the bottom type with {\PFAtp X} is {\PFAtp X}, and thus if an if statement has a ``then'' branch that ends in a value and an ``else'' branch that ends in an error, the type of the if statement is the type of the value.  The same is true of ``cond'' forms, ``cast'' blocks, and anything else that branches the program flow.  If place at a point that does not branch the program flow (e.g.\ at the end of a ``do'' form), then the type is converted into {\bf null}.

\hypertarget{hsec:try-form}{}
\subsubsection{Turning exceptions into missing values: the ``try'' special form}
\label{sec:try-form}

A running scoring engine should only encounter two types of errors: a runtime error in a library call or a user-defined error.  Sometimes, it is better to treat exceptional cases as missing values than non-local exits.  The ``try'' special form evaluates an expression or array of expressions, catches errors, and either returns the result of the calculation or {\PFAc null} to indicate a missing value.  It has the following syntax.
\begin{json}
{"try": EXPRESSION-OR-EXPRESSIONS}
\end{json}
or
\begin{json}
{"try": EXPRESSION-OR-EXPRESSIONS, "filter": ARRAY-OF-STRINGS-AND-INTEGERS}
\end{json}

The return type of the ``try'' form is a union of ``null'' and the type of the last expression in the block.  Thus, if the {\PFAc EXPRESSION-OR-EXPRESSIONS} calculates a numerical result (e.g.\ ``double''), the try returns a possibly missing numerical result (e.g.\ [``double'', ``null'']).  This missing value may be returned directly or wrapped in an ``ifnotnull'' form to build a traditional try-catch block: the ``ifnotnull'' would perform the catch logic.

\begin{example}
Example of a traditional try-catch block.
\begin{json}
{"ifnotnull": {result: {"try": TRY-LOGIC}},
 "then": result,
 "else": CATCH-LOGIC}
\end{json}
\end{example}

If a ``filter'' is provided, only the specified error messages would be caught--- the rest are passed through. The strings need to match the error message text exactly, and the integers match error codes.

\hypertarget{hsec:logs}{}
\subsubsection{Log messages: the ``log'' special form}
\label{sec:logs}

The only three outputs that a PFA scoring engine can emit are (1) normal output, the result of a calculation, (2) an exception, and (3) log messages.  Log messages should not be used for normal output, as they may or may not be handled by the host PFA system.  The PFA system has full discretion to ignore, filter, collate, forward, or merge log messages.

The ``log'' special form emits a log message.  It has the following syntax.
\begin{json}
{"log": EXPRESSION-OR-EXPRESSIONS}
\end{json}
or
\begin{json}
{"log": EXPRESSION-OR-EXPRESSIONS, "namespace": NAME}
\end{json}
The {\PFAc EXPRESSION-OR-EXPRESSIONS} are the expressions to dump to the log (remember to wrap plain strings in {\PFAc \{"string":$\!$ "} \ldots {\PFAc "\}} or {\PFAc ["} \ldots {\PFAc "]}); the optional {\PFAc NAMESPACE} is a token that may be used for filtering or collating.  The ``log'' form returns {\PFAc null}.

\pagebreak

\hypertarget{hsec:core-library}{}
\section{Core library}
\label{sec:core-library}

The core library contains functions that would, in most languages, be infix operators.  Following a LISP style of defining them as functions makes it easier to manipulate the expression tree with an automated algorithm.

\subsection{Basic arithmetic}

\subsubsection{Addition of two values ($+$)}
\libfcn{+}

\subsubsection{Subtraction ($-$)}
\libfcn{-}

\subsubsection{Multiplication of two values (*)}
\libfcn{*}

\subsubsection{Floating-point division (/)}
\libfcn{/}

\subsubsection{Integer division (//)}
\libfcn{//}

\subsubsection{Negation (u$-$)}
\libfcn{u-}

\subsubsection{Modulo (\%)}
\libfcn{\%}

\subsubsection{Remainder (\%\%)}
\libfcn{\%\%}

\subsubsection{Raising to a power (**)}
\libfcn{**}

\subsection{Comparison operators}

Avro defines a \href{http://avro.apache.org/docs/1.7.6/spec.html#order}{sort order} for every pair of values with a compatible type, so any two objects of compatible type can be compared in PFA.

\subsubsection{General comparison (cmp)}
\libfcn{cmp}

\subsubsection{Equality (==)}
\libfcn{==}

\subsubsection{Inequality (!=)}
\libfcn{!=}

\subsubsection{Less than (<)}
\libfcn{<}

\subsubsection{Less than or equal to (<=)}
\libfcn{<=}

\subsubsection{Greater than (>)}
\libfcn{>}

\subsubsection{Greater than or equal to (>=)}
\libfcn{>=}

\subsubsection{Maximum of two values (max)}
\libfcn{max}

\subsubsection{Minimum of two values (min)}
\libfcn{min}

\subsection{Logical operators}

\subsubsection{Logical and (\&\&)}
\libfcn{\&\&}

\subsubsection{Logical or (||)}
\libfcn{||}

\subsubsection{Logical xor (\^{}\^{})}
\libfcn{\^{}\^{}}

\subsubsection{Logical not (!)}
\libfcn{!}

\subsection{Kleene operators (three-way logic)}

\subsubsection{Kleene and (\&\&\&)}
\libfcn{\&\&\&}

\subsubsection{Kleene or (|||)}
\libfcn{|||}

\subsubsection{Kleene not (!!!)}
\libfcn{!!!}

\subsection{Bitwise arithmetic}

\subsubsection{Bitwise and (\&)}
\libfcn{\&}

\subsubsection{Bitwise or (|)}
\libfcn{|}

\subsubsection{Bitwise xor (\^{})}
\libfcn{\^{}}

\subsubsection{Bitwise not (\textasciitilde{})}
\libfcn{TILDE}

\pagebreak

\section{Math library}

\subsection{Constants}

Constants such as $\pi$ and $e$ are represented as stateless functions with no arguments.  Specific implementations may choose to replace the function call with its inline value.

\subsubsection{Archimedes' constant $\pi$ (m.pi)}
\libfcn{m.pi}

\subsubsection{Euler's constant $e$ (m.e)}
\libfcn{m.e}

\subsection{Common functions}

\subsubsection{Square root (m.sqrt)}
\libfcn{m.sqrt}

\subsubsection{Hypotenuse (m.hypot)}
\libfcn{m.hypot}

\subsubsection{Trigonometric sine (m.sin)}
\libfcn{m.sin}

\subsubsection{Trigonometric cosine (m.cos)}
\libfcn{m.cos}

\subsubsection{Trigonometric tangent (m.tan)}
\libfcn{m.tan}

\subsubsection{Inverse trigonometric sine (m.asin)}
\libfcn{m.asin}

\subsubsection{Inverse trigonometric cosine (m.acos)}
\libfcn{m.acos}

\subsubsection{Inverse trigonometric tangent (m.atan)}
\libfcn{m.atan}

\subsubsection{Robust inverse trigonometric tangent (m.atan2)}
\libfcn{m.atan2}

\subsubsection{Hyperbolic sine (m.sinh)}
\libfcn{m.sinh}

\subsubsection{Hyperbolic cosine (m.cosh)}
\libfcn{m.cosh}

\subsubsection{Hyperbolic tangent (m.tanh)}
\libfcn{m.tanh}

\subsubsection{Natural exponential (m.exp)}
\libfcn{m.exp}

\subsubsection{Natural exponential minus one (m.expm1)}
\libfcn{m.expm1}

\subsubsection{Natural logarithm (m.ln)}
\libfcn{m.ln}

\subsubsection{Logarithm base 10 (m.log10)}
\libfcn{m.log10}

\subsubsection{Arbitrary logarithm (m.log)}
\libfcn{m.log}

\subsubsection{Natural logarithm of one plus square (m.ln1p)}
\libfcn{m.ln1p}

\subsection{Rounding}

\subsubsection{Absolute value (m.abs)}
\libfcn{m.abs}

\subsubsection{Floor (m.floor)}
\libfcn{m.floor}

\subsubsection{Ceiling (m.ceil)}
\libfcn{m.ceil}

\subsubsection{Simple rounding (m.round)}
\libfcn{m.round}

\subsubsection{Unbiased rounding (m.rint)}
\libfcn{m.rint}

\subsubsection{Threshold function (m.signum)}
\libfcn{m.signum}

\subsubsection{Copy sign (m.copysign)}
\libfcn{m.copysign}

\subsection{Special functions}

\subsubsection{Error function (m.special.erf)}
\libfcn{m.special.erf}

\subsubsection{Complimentary error function (m.special.erfc)}
\libfcn{m.special.erfc}

\subsubsection{Natural log of the gamma function (m.special.lnGamma)}
\libfcn{m.special.lnGamma}

\subsubsection{Natural log of the beta function (m.special.lnBeta)}
\libfcn{m.special.lnBeta}

\subsubsection{Binomial coefficient (m.special.nChooseK)}
\libfcn{m.special.nChooseK}

\subsection{Link or activation functions}

\subsubsection{Logit (m.link.logit)}
\libfcn{m.link.logit}

\subsubsection{Probit (m.link.probit)}
\libfcn{m.link.probit}

\subsubsection{Log-log (m.link.loglog)}
\libfcn{m.link.loglog}

\subsubsection{Complement of log-log (m.link.cloglog)}
\libfcn{m.link.cloglog}

\subsubsection{Cauchit (m.link.cauchit)}
\libfcn{m.link.cauchit}

\subsubsection{Hyperbolic tangent (m.link.tanh)}
\libfcn{m.link.tanh}

\subsubsection{Softmax (m.link.softmax)}
\libfcn{m.link.softmax}

\subsubsection{SoftPlus (m.link.softplus)}
\libfcn{m.link.softplus}

\subsubsection{Rectified linear unit (m.link.relu)}
\libfcn{m.link.relu}

\subsection{Kernel functions}

\subsubsection{Linear (m.kernel.linear)}
\libfcn{m.kernel.linear}

\subsubsection{Radial basis function (m.kernel.rbf)}
\libfcn{m.kernel.rbf}

\subsubsection{Polynomal (m.kernel.poly)}
\libfcn{m.kernel.poly}

\subsubsection{Sigmoidal (m.kernel.linear)}
\libfcn{m.kernel.sigmoid}

\pagebreak

\section{Linear algebra library}

\subsection{Unary scaling of vectors or matrices (la.scale)}
\libfcn{la.scale}

\subsection{Generalized unary operator (la.map)}
\libfcn{la.map}

\subsection{Addition of vectors or matrices (la.add)}
\libfcn{la.add}

\subsection{Subtraction of vectors or matrices (la.sub)}
\libfcn{la.sub}

\subsection{Generalized binary operator (la.zipmap)}
\libfcn{la.zipmap}

\subsection{Vector and matrix dot product (la.dot)}
\libfcn{la.dot}

\subsection{Transpose (la.transpose)}
\libfcn{la.transpose}

\subsection{Inverse and pseudo-inverse (la.inverse)}
\libfcn{la.inverse}

\subsection{Trace (la.trace)}
\libfcn{la.trace}

\subsection{Determinant (la.det)}
\libfcn{la.det}

\subsection{Check for symmetry (la.symmetric)}
\libfcn{la.symmetric}

\subsection{Real eigenbasis of symmetric matrix (la.eigenBasis)}
\libfcn{la.eigenBasis}

\subsection{Truncate rows (la.truncate)}
\libfcn{la.truncate}

\pagebreak

\section{Metric library}

\subsection{Euclidean metric without similarity or missing values (metric.simpleEuclidean)}
\libfcn{metric.simpleEuclidean}

\subsection{Absolute difference similarity function (metric.absDiff)}
\libfcn{metric.absDiff}

\subsection{Gaussian similarity function (metric.gaussianSimilarity)}
\libfcn{metric.gaussianSimilarity}

\subsection{Euclidean metric (metric.euclidean)}
\libfcn{metric.euclidean}

\subsection{Squared euclidean metric (metric.squaredEuclidean)}
\libfcn{metric.squaredEuclidean}

\subsection{Chebyshev metric (metric.chebyshev)}
\libfcn{metric.chebyshev}

\subsection{Taxicab metric (metric.taxicab)}
\libfcn{metric.taxicab}

\subsection{Minkowski metric (metric.minkowski)}
\libfcn{metric.minkowski}

\subsection{Simple binary metric (metric.simpleMatching)}
\libfcn{metric.simpleMatching}

\subsection{Jaccard binary similarity (metric.jaccard)}
\libfcn{metric.jaccard}

\subsection{Tanimoto binary similarity (metric.tanimoto)}
\libfcn{metric.tanimoto}

\subsection{General binary metric (metric.binarySimilarity)}
\libfcn{metric.binarySimilarity}

\pagebreak

\section{Random number library}

All pseudorandom functions are seeded by the top-level field {\PFAc randseed}.  If absent, the return values of these functions are unpredictable.  If present, they are reproducible for scoring engines generated from the same PFA file on the same PFA implementation.  Different PFA implementations may use different random number generators, so reproducibility among implementations is not guaranteed.

\subsection{Uniform random deviates of basic types}

\subsubsection{Random integer (rand.int)}
\libfcn{rand.int}

\subsubsection{Random integer (rand.long)}
\libfcn{rand.long}

\subsubsection{Random integer (rand.float)}
\libfcn{rand.float}

\subsubsection{Random integer (rand.double)}
\libfcn{rand.double}

\subsubsection{Random string (rand.string)}
\libfcn{rand.string}

\subsubsection{Random bytes (rand.bytes)}
\libfcn{rand.bytes}

\subsection{Common statistical distributions}

\subsubsection{Gaussian deviates (rand.gaussian)}
\libfcn{rand.gaussian}

\subsection{Common utility types}

\subsubsection{Type-4 UUID (rand.uuid4)}
\libfcn{rand.uuid}
\libfcn{rand.uuid4}

\subsection{Selecting arbitrary objects from a bag}

\subsubsection{Random object from a bag (rand.choice)}
\libfcn{rand.choice}

\subsubsection{Random set of objects with replacement (rand.choices)}
\libfcn{rand.choices}

\subsubsection{Random set of objects without replacement (rand.sample)}
\libfcn{rand.sample}

\subsubsection{Random objects with a specified probability distribution (rand.histogram)}
\libfcn{rand.histogram}

\pagebreak

\section{String manipulation library}

Strings are immutable, so none of the following functions modifies a string in-place.  Some return a modified version of the original string.

\subsection{Basic access}

\subsubsection{Length (s.len)}
\libfcn{s.len}

\subsubsection{Extract substring (s.substr)}
\libfcn{s.substr}

\subsubsection{Modify substring (s.substrto)}
\libfcn{s.substrto}

\subsection{Search and replace}

Search and replace functions in the basic string library do not use regular expressions.

\subsubsection{Contains (s.contains)}
\libfcn{s.contains}

\subsubsection{Count instances (s.count)}
\libfcn{s.count}

\subsubsection{Find first index (s.index)}
\libfcn{s.index}

\subsubsection{Find last index (s.rindex)}
\libfcn{s.rindex}

\subsubsection{Check start (s.startswith)}
\libfcn{s.startswith}

\subsubsection{Check end (s.endswith)}
\libfcn{s.endswith}

\subsection{Conversions to or from other types}

\subsubsection{Join an array of strings (s.join)}
\libfcn{s.join}

\subsubsection{Split into an array of strings (s.split)}
\libfcn{s.split}

\subsubsection{Format a number as a string (s.number)}
\libfcn{s.number}

\subsubsection{Format a positive integer as hexidecimal (s.hex)}
\libfcn{s.hex}

\subsection{Conversions to or from other strings}

\subsubsection{Concatenate two strings (s.concat)}
\libfcn{s.concat}

\subsubsection{Repeat pattern (s.repeat)}
\libfcn{s.repeat}

\subsubsection{Lowercase (s.lower)}
\libfcn{s.lower}

\subsubsection{Uppercase (s.upper)}
\libfcn{s.upper}

\subsubsection{Left-strip (s.lstrip)}
\libfcn{s.lstrip}

\subsubsection{Right-strip (s.rstrip)}
\libfcn{s.rstrip}

\subsubsection{Strip both ends (s.strip)}
\libfcn{s.strip}

\subsubsection{Replace all matches (s.replaceall)}
\libfcn{s.replaceall}

\subsubsection{Replace first match (s.replacefirst)}
\libfcn{s.replacefirst}

\subsubsection{Replace last match (s.replacelast)}
\libfcn{s.replacelast}

\subsubsection{Translate characters (s.translate)}
\libfcn{s.translate}

\pagebreak

\section{Regular expressions and text pre-procssing}

The regular expression syntax follows the POSIX extended standard (like {\tt grep -e} in Linux and UNIX).

\subsection{Basic identification of pattern}

\subsubsection{Check for existence of a pattern (re.contains)}
\libfcn{re.contains}

\subsubsection{Count occurrences of a pattern (re.count)}
\libfcn{re.count}

\subsection{Get matched parterns}

\subsubsection{Find the first instance of a pattern (re.findfirst)}
\libfcn{re.findfirst}

\subsubsection{Find all instances of a pattern (re.findall)}
\libfcn{re.findall}

\subsection{Get matched groups}

\subsubsection{Get first set of matching groups (re.groups)}
\libfcn{re.groups}

\subsubsection{Get all sets of matching groups (re.groupsall)}
\libfcn{re.groupsall}

\subsection{Get matched parterns and groups}

\subsubsection{Find the first instance of a pattern, with groups (re.findgroupsfirst)}
\libfcn{re.findgroupsfirst}

\subsubsection{Find all instances of a pattern, with groups (re.findgroupsall)}
\libfcn{re.findgroupsall}

\subsection{Get index position of match}

\subsubsection{Find the first index where a pattern appears (re.index)}
\libfcn{re.index}

\subsubsection{Find the last index where a pattern appears (re.rindex)}
\libfcn{re.rindex}

\subsubsection{Find all indexes that match a pattern (re.indexall)}
\libfcn{re.indexall}

\subsection{Replacement}

\subsubsection{Replace the first instance of a pattern (re.replacefirst)}
\libfcn{re.replacefirst}

\subsubsection{Replace the last instance of a pattern (re.replacelast)}
\libfcn{re.replacelast}

\subsubsection{Replace all instances of a pattern (re.replaceall)}
\libfcn{re.replaceall}

\subsection{Splitting}

\subsubsection{Split a string by a pattern (re.split)}
\libfcn{re.split}

\pagebreak

\section{Parsing library}

\subsection{Parsing numbers}

\subsubsection{32-bit integers (parse.int)}
\libfcn{parse.int}

\subsubsection{64-bit integers (parse.long)}
\libfcn{parse.long}

\subsubsection{Single-precision floating point (parse.float)}
\libfcn{parse.float}

\subsubsection{Double-precision floating point (parse.double)}
\libfcn{parse.double}

\pagebreak

\section{Casting library}

\subsection{Casting numbers as numbers of a different type}

\subsubsection{Signed integers with wrap-around (cast.signed)}
\libfcn{cast.signed}

\subsubsection{Unsigned integers with wrap-around (cast.unsigned)}
\libfcn{cast.unsigned}

\subsubsection{32-bit integers (cast.int)}
\libfcn{cast.int}

\subsubsection{64-bit integers (cast.long)}
\libfcn{cast.long}

\subsubsection{Single-precision floating point (cast.float)}
\libfcn{cast.float}

\subsubsection{Double-precision floating point (cast.double)}
\libfcn{cast.double}

\subsection{Fanning out variables to arrays of various types}

\subsubsection{Fan a variable out to an array of booleans (cast.fanoutBoolean)}
\libfcn{cast.fanoutBoolean}

\subsubsection{Fan a variable out to an array of ints (cast.fanoutInt)}
\libfcn{cast.fanoutInt}

\subsubsection{Fan a variable out to an array of longs (cast.fanoutLong)}
\libfcn{cast.fanoutLong}

\subsubsection{Fan a variable out to an array of floats (cast.fanoutFloat)}
\libfcn{cast.fanoutFloat}

\subsubsection{Fan a variable out to an array of doubles (cast.fanoutDouble)}
\libfcn{cast.fanoutDouble}

\subsection{Serializing arbitrary objects}

\subsubsection{Serialize an arbitrary object as Avro bytes (cast.avro)}
\libfcn{cast.avro}

\subsubsection{Serialize an arbitrary object as a JSON string (cast.json)}
\libfcn{cast.json}

\pagebreak

\section{Array manipulation library}

Arrays are immutable, so none of the following functions modifies an array in-place.  Some return a modified version of the original array.

\subsection{Basic access}

\subsubsection{Length (a.len)}
\libfcn{a.len}

\subsubsection{Extract subsequence (a.subseq)}
\libfcn{a.subseq}

\subsubsection{Extract the first item (a.head)}
\libfcn{a.head}

\subsubsection{Extract all but the first item (a.tail)}
\libfcn{a.tail}

\subsubsection{Extract the last item (a.last)}
\libfcn{a.last}

\subsubsection{Extract all but the last item (a.init)}
\libfcn{a.init}

\subsubsection{Modify subsequence (a.subseqto)}
\libfcn{a.subseqto}

\subsection{Search and replace}

\subsubsection{Contains (a.contains)}
\libfcn{a.contains}

\subsubsection{Count instances (a.count)}
\libfcn{a.count}

\subsubsection{Find first index (a.index)}
\libfcn{a.index}

\subsubsection{Find last index (a.rindex)}
\libfcn{a.rindex}

\subsubsection{Check start (a.startswith)}
\libfcn{a.startswith}

\subsubsection{Check end (a.endswith)}
\libfcn{a.endswith}

\subsection{Manipulation}

\subsubsection{Concatenate two arrays (a.concat)}
\libfcn{a.concat}

\subsubsection{Append (a.append)}
\libfcn{a.append}

\subsubsection{Append to a circular buffer with a maximum size (a.cycle)}
\libfcn{a.cycle}

\subsubsection{Insert or prepend (a.insert)}
\libfcn{a.insert}

\subsubsection{Replace item (a.replace)}
\libfcn{a.replace}

\subsubsection{Remove item (a.remove)}
\libfcn{a.remove}

\subsubsection{Rotate an array left (a.rotate)}
\libfcn{a.rotate}

\subsection{Reordering}

\subsubsection{Sort (a.sort)}
\libfcn{a.sort}

\subsubsection{Sort with a less-than function (a.sortLT)}
\libfcn{a.sortLT}

\subsubsection{Randomly shuffle array (a.shuffle)}
\libfcn{a.shuffle}

\subsubsection{Reverse order (a.reverse)}
\libfcn{a.reverse}

\subsection{Extreme values}

The functions listed here provide the Cartesian product of the following features: (1) minimization and maximization, (2) using the natural Avro sort order or a custom less-than function, (3) returning only the most extreme value or an array of the $N$ most extreme values, (4) returning the values themselves or the indexes of the values in the array.  Each combination is provided as a separate function to avoid complicating the type signatures of the functions.

\subsubsection{Maximum of all values (a.max)}
\libfcn{a.max}

\subsubsection{Minimum of all values (a.min)}
\libfcn{a.min}

\subsubsection{Maximum with a less-than function (a.maxLT)}
\libfcn{a.maxLT}

\subsubsection{Minimum with a less-than function (a.minLT)}
\libfcn{a.minLT}

\subsubsection{Maximum $N$ items (a.maxN)}
\libfcn{a.maxN}

\subsubsection{Minimum $N$ items (a.minN)}
\libfcn{a.minN}

\subsubsection{Maximum $N$ with a less-than function (a.maxNLT)}
\libfcn{a.maxNLT}

\subsubsection{Minimum $N$ with a less-than function (a.minNLT)}
\libfcn{a.minNLT}

\subsubsection{Argument maximum (a.argmax)}
\libfcn{a.argmax}

\subsubsection{Argument minimum (a.argmin)}
\libfcn{a.argmin}

\subsubsection{Argument maximum with a less-than function (a.argmaxLT)}
\libfcn{a.argmaxLT}

\subsubsection{Argument minimum with a less-than function (a.argminLT)}
\libfcn{a.argminLT}

\subsubsection{Maximum $N$ arguments (a.argmaxN)}
\libfcn{a.argmaxN}

\subsubsection{Minimum $N$ arguments (a.argminN)}
\libfcn{a.argminN}

\subsubsection{Maximum $N$ arguments with a less-than function (a.argmaxNLT)}
\libfcn{a.argmaxNLT}

\subsubsection{Minimum $N$ arguments with a less-than function (a.argminNLT)}
\libfcn{a.argminNLT}

\subsection{Numerical combinations}

\subsubsection{Add all array values (a.sum)}
\libfcn{a.sum}

\subsubsection{Multiply all array values (a.product)}
\libfcn{a.product}

\subsubsection{Sum of logarithms (a.lnsum)}
\libfcn{a.lnsum}

\subsubsection{Log of the sum of exponentials without roundoff error (a.logsumexp)}
\libfcn{a.logsumexp}

\subsubsection{Arithmetic mean (a.mean)}
\libfcn{a.mean}

\subsubsection{Geometric mean (a.geomean)}
\libfcn{a.geomean}

\subsubsection{Median (a.median)}
\libfcn{a.median}

\subsubsection{Percentile in unit interval (a.ntile)}
\libfcn{a.ntile}

\subsubsection{Mode, or most common value (a.mode)}
\libfcn{a.mode}

\hypertarget{hsec:set-like}{}
\subsection{Set or set-like functions}
\label{sec:set-like}

PFA does not have a set datatype, but arrays can be interpreted as sets with the following functions, which provide access and update times that scale with the length of the array.  To represent sets using constant-time hashtables, see the corresponding functions in \hyperlink{hsec:set-like-map}{Sec.~\ref{sec:set-like-map}}.

\subsubsection{Distinct items (a.distinct)}
\libfcn{a.distinct}

\subsubsection{Set equality (a.seteq)}
\libfcn{a.seteq}

\subsubsection{Union (a.union)}
\libfcn{a.union}

\subsubsection{Intersection (a.intersection)}
\libfcn{a.intersection}

\subsubsection{Set difference (a.diff)}
\libfcn{a.diff}

\subsubsection{Symmetric set difference (a.symdiff)}
\libfcn{a.symdiff}

\subsubsection{Subset check (a.subset)}
\libfcn{a.subset}

\subsubsection{Disjointness check (a.disjoint)}
\libfcn{a.disjoint}

\subsection{Functional programming}

These are the standard functors found in most functional programming contexts.

\subsubsection{Transform array items with function (a.map)}
\libfcn{a.map}

\subsubsection{Transform array items, providing access to the index (a.mapWithIndex)}
\libfcn{a.mapWithIndex}

\subsubsection{Filter array items with a function (a.filter)}
\libfcn{a.filter}

\subsubsection{Filter array items, providing access to the index (a.filterWithIndex)}
\libfcn{a.filterWithIndex}

\subsubsection{Filter and map (a.filterMap)}
\libfcn{a.filterMap}

\subsubsection{Filter and map, providing access to the index (a.filterMapWithIndex)}
\libfcn{a.filterMapWithIndex}

\subsubsection{Map and flatten (a.flatMap)}
\libfcn{a.flatMap}

\subsubsection{Map and flatten, providing access to the index (a.flatMapWithIndex)}
\libfcn{a.flatMapWithIndex}

\subsubsection{Zip and map (a.zipmap)}
\libfcn{a.zipmap}

\subsubsection{Zip and map, providing access to the index (a.zipmapWithIndex)}
\libfcn{a.zipmapWithIndex}

\subsubsection{Reduce array items to a single value (a.reduce)}
\libfcn{a.reduce}

\subsubsection{Right-to-left reduce (a.reduceRight)}
\libfcn{a.reduceRight}

\subsubsection{Fold array items to another type (a.fold)}
\libfcn{a.fold}

\subsubsection{Right-to-left fold (a.foldRight)}
\libfcn{a.foldRight}

\subsubsection{Take items until predicate is false (a.takeWhile)}
\libfcn{a.takeWhile}

\subsubsection{Drop items until predicate is true (a.dropWhile)}
\libfcn{a.dropWhile}

\subsection{Functional tests}

\subsubsection{Existential check, $\exists$ (a.any)}
\libfcn{a.any}

\subsubsection{Univeral check, $\forall$ (a.all)}
\libfcn{a.all}

\subsubsection{Pairwise check of two arrays (a.corresponds)}
\libfcn{a.corresponds}

\subsubsection{Pairwise check, providing access to the index (a.correspondsWithIndex)}
\libfcn{a.correspondsWithIndex}

\subsection{Restructuring}

\subsubsection{Sliding window (a.slidingWindow)}
\libfcn{a.slidingWindow}

\subsubsection{Unique combinations of a fixed size (a.combinations)}
\libfcn{a.combinations}

\subsubsection{Permutations (a.permutations)}
\libfcn{a.permutations}

\subsubsection{Flatten array (a.flatten)}
\libfcn{a.flatten}

\subsubsection{Group items by category (a.groupby)}
\libfcn{a.groupby}

\pagebreak

\section{Map manipulation library}

Maps are immutable, so none of the following functions modifies a map in-place.  Some return a modified version of the original map.

\subsection{Basic access}

\subsubsection{Length (map.len)}
\libfcn{map.len}

\subsubsection{Extract the keys (map.keys)}
\libfcn{map.keys}

\subsubsection{Extract the values (map.values)}
\libfcn{map.values}

\subsection{Search and replace}

\subsubsection{Contains key (map.containsKey)}
\libfcn{map.containsKey}

\subsubsection{Contains value (map.containsValue)}
\libfcn{map.containsValue}

\subsection{Manipulation}

\subsubsection{Insert a key-value pair (map.add)}
\libfcn{map.add}

\subsubsection{Remove a key (map.remove)}
\libfcn{map.remove}

\subsubsection{Keep only certain keys (map.only)}
\libfcn{map.only}

\subsubsection{Keep all except certain keys (map.except)}
\libfcn{map.except}

\subsubsection{Add or replace keys with an overlay map (map.update)}
\libfcn{map.update}

\subsubsection{Split map into an array of single-key maps (map.split)}
\libfcn{map.split}

\subsubsection{Join an array of maps into one map (map.join)}
\libfcn{map.join}

\subsection{Extreme values by key}

To get the maximum or minimum value of a map, simply call {\PFAf map.values} and then use one of the array max/min functions. If, however, you need to know the {\it key} of the maximum or minimum value, use one of the below.

\subsubsection{Argument maximum (map.argmax)}
\libfcn{map.argmax}

\subsubsection{Argument minimum (map.argmin)}
\libfcn{map.argmin}

\subsubsection{Argument maximum with a less-than function (map.argmaxLT)}
\libfcn{map.argmaxLT}

\subsubsection{Argument minimum with a less-than function (map.argminLT)}
\libfcn{map.argminLT}

\subsubsection{Maximum $N$ arguments (map.argmaxN)}
\libfcn{map.argmaxN}

\subsubsection{Minimum $N$ arguments (map.argminN)}
\libfcn{map.argminN}

\subsubsection{Maximum $N$ arguments with a less-than function (map.argmaxNLT)}
\libfcn{map.argmaxNLT}

\subsubsection{Minimum $N$ arguments with a less-than function (map.argminNLT)}
\libfcn{map.argminNLT}

\hypertarget{hsec:set-like-map}{}
\subsection{Set or set-like functions}
\label{sec:set-like-map}

PFA does not have a set datatype, but maps can be interpreted as sets with the following functions, which provide some constant-time access times.  For a simpler implementation, see the corresponding sections in \hyperlink{hsec:set-like}{Sec.~\ref{sec:set-like}}.

\subsubsection{Convert an array to a map-set (map.toset)}
\libfcn{map.toset}

\subsubsection{Convert a map to an array-set (map.fromset)}
\libfcn{map.fromset}

\subsubsection{Determine if an object is in the set (map.in)}
\libfcn{map.in}

\subsubsection{Union (map.union)}
\libfcn{map.union}

\subsubsection{Intersection (map.intersection)}
\libfcn{map.intersection}

\subsubsection{Set difference (map.diff)}
\libfcn{map.diff}

\subsubsection{Symmetric set difference (map.symdiff)}
\libfcn{map.symdiff}

\subsubsection{Subset check (map.subset)}
\libfcn{map.subset}

\subsubsection{Disjointness check (map.disjoint)}
\libfcn{map.disjoint}

\subsection{Functional programming}

\subsubsection{Transform map items with a function (map.map)}
\libfcn{map.map}

\subsubsection{Transform map items, providing access to the key (map.mapWithKey)}
\libfcn{map.mapWithKey}

\subsubsection{Filter map items with a function (map.filter)}
\libfcn{map.filter}

\subsubsection{Filter map items, providing access to the key (map.filterWithKey)}
\libfcn{map.filterWithKey}

\subsubsection{Filter and map (map.filterMap)}
\libfcn{map.filterMap}

\subsubsection{Filter and map, providing access to the keys (map.filterMapWithKey)}
\libfcn{map.filterMapWithKey}

\subsubsection{Map and flatten (map.flatMap)}
\libfcn{map.flatMap}

\subsubsection{Map and flatten, providing access to the keys (map.flatMapWithKey)}
\libfcn{map.flatMapWithKey}

\subsubsection{Zip and map (map.zipmap)}
\libfcn{map.zipmap}

\subsubsection{Zip and map, providing access to the keys (map.zipmapWithKey)}
\libfcn{map.zipmapWithKey}

\subsection{Functional tests}

\subsubsection{Pairwise check of two maps (map.corresponds)}
\libfcn{map.corresponds}

\subsubsection{Pairwise check, providing access to the keys (map.correspondsWithKey)}
\libfcn{map.correspondsWithKey}

\pagebreak
\section{Bytes manipulation library}

\subsection{Basic access}

\subsubsection{Length (bytes.len)}
\libfcn{bytes.len}

\subsubsection{Extract subsequence (bytes.subseq)}
\libfcn{bytes.subseq}

\subsubsection{Modify subsequence (bytes.subseqto)}
\libfcn{bytes.subseqto}

\subsection{Test validity}

\subsubsection{Verify ASCII format (bytes.isAscii)}
\libfcn{bytes.isAscii}

\subsubsection{Verify LATIN-1 format (bytes.isLatin1)}
\libfcn{bytes.isLatin1}

\subsubsection{Verify UTF-8 format (bytes.isUtf8)}
\libfcn{bytes.isUtf8}

\subsubsection{Verify UTF-16 format (bytes.isUtf16)}
\libfcn{bytes.isUtf16}

\subsubsection{Verify UTF-16 big endian format (bytes.isUtf16be)}
\libfcn{bytes.isUtf16be}

\subsubsection{Verify UTF-16 little endian format (bytes.isUtf16le)}
\libfcn{bytes.isUtf16le}

\subsection{Decode bytes to strings}

\subsubsection{Decode from ASCII format (bytes.decodeAscii)}
\libfcn{bytes.decodeAscii}

\subsubsection{Decode from LATIN-1 format (bytes.decodeLatin1)}
\libfcn{bytes.decodeLatin1}

\subsubsection{Decode from UTF-8 format (bytes.decodeUtf8)}
\libfcn{bytes.decodeUtf8}

\subsubsection{Decode from UTF-16 format (bytes.decodeUtf16)}
\libfcn{bytes.decodeUtf16}

\subsubsection{Decode from UTF-16 big endian format (bytes.decodeUtf16be)}
\libfcn{bytes.decodeUtf16be}

\subsubsection{Decode from UTF-16 little endian format (bytes.decodeUtf16le)}
\libfcn{bytes.decodeUtf16le}

\subsection{Encode strings to bytes}

\subsubsection{Encode to ASCII format (bytes.encodeAscii)}
\libfcn{bytes.encodeAscii}

\subsubsection{Encode to LATIN-1 format (bytes.encodeLatin1)}
\libfcn{bytes.encodeLatin1}

\subsubsection{Encode to UTF-8 format (bytes.encodeUtf8)}
\libfcn{bytes.encodeUtf8}

\subsubsection{Encode to UTF-16 format (bytes.encodeUtf16)}
\libfcn{bytes.encodeUtf16}

\subsubsection{Encode to UTF-16 big endian format (bytes.encodeUtf16be)}
\libfcn{bytes.encodeUtf16be}

\subsubsection{Encode to UTF-16 little endian format (bytes.encodeUtf16le)}
\libfcn{bytes.encodeUtf16le}

\subsection{Base64 encoding}

\subsubsection{Encode bytes as a base64 string (bytes.toBase64)}
\libfcn{bytes.toBase64}

\subsubsection{Decode base64 string to bytes (bytes.fromBase64)}
\libfcn{bytes.fromBase64}

\pagebreak
\section{Manipulation of other data structures}

\subsection{Fixed}

\subsubsection{Convert to bytes (fixed.toBytes)}
\libfcn{fixed.toBytes}

\subsubsection{Convert from bytes (fixed.fromBytes)}
\libfcn{fixed.fromBytes}

\subsection{Enum}

\subsubsection{String representation (enum.toString)}
\libfcn{enum.toString}

\subsubsection{Integer representation (enum.toInt)}
\libfcn{enum.toInt}

\subsubsection{Number of symbols (enum.numSymbols)}
\libfcn{enum.numSymbols}

\pagebreak
\section{Date/time handling}

PFA does not have a special data type for time (because there is no such type in Avro), so times are represented as the floating-point number of seconds since the beginning of 1970 in UTC.  For whole-numbered seconds, this corresponds to the UNIX timestamp.  Double precision (IEEE 64-bit representation), provides microsecond resolution until May 30, 2514.

\subsection{Extracting conventional time units from timestamp}

Time units within a second (e.g.\ millisecond past the second or microsecond past the second) can be obtained using the modulo function: {\PFAc \{"*", [\{"\%":$\!$ ["timestamp",$\!$ 1.0]\}, 1000]\}} for milliseconds.

\subsubsection{Year from timestamp (time.year)}
\libfcn{time.year}

\subsubsection{Month of year from timestamp (time.monthOfYear)}
\libfcn{time.monthOfYear}

\subsubsection{Day of year from timestamp (time.dayOfYear)}
\libfcn{time.dayOfYear}

\subsubsection{Day of month from timestamp (time.dayOfMonth)}
\libfcn{time.dayOfMonth}

\subsubsection{Day of week from timestamp (time.dayOfWeek)}
\libfcn{time.dayOfWeek}

\subsubsection{Hour of day from timestamp (time.hourOfDay)}
\libfcn{time.hourOfDay}

\subsubsection{Minutes past the hour from timestamp (time.minuteOfHour)}
\libfcn{time.minuteOfHour}

\subsubsection{Seconds past the minute from timestamp (time.secondOfMinute)}
\libfcn{time.secondOfMinute}

\subsection{Constructing timestamp from conventional units}

\subsubsection{Make timestamp (time.makeTimestamp)}
\libfcn{time.makeTimestamp}

\subsection{Querying time intervals}

Since the timestamp is a simple number on a continuous range, one can use greater than or less than to determine if it falls within an absolute interval (e.g.\ between 3 and 5 PM on July 2, 2015).  Often, one wants to know if a timestamp falls within a repeating interval, such as between 3 and 5 PM of {\it any day.}  The following functions provide this kind of access.  (Note: if the interval is non-sensical, such as the 70th minute of an hour, the function returns false, rather than raising an exception.)

\subsubsection{Seconds of minute range (time.isSecondOfMinute)}
\libfcn{time.isSecondOfMinute}

\subsubsection{Minutes of hour range (time.isMinuteOfHour)}
\libfcn{time.isMinuteOfHour}

\subsubsection{Hour of day range (time.isHourOfDay)}
\libfcn{time.isHourOfDay}

\subsubsection{Day of week range (time.isDayOfWeek)}
\libfcn{time.isDayOfWeek}

\subsubsection{Day of month range (time.isDayOfMonth)}
\libfcn{time.isDayOfMonth}

\subsubsection{Month of year range (time.isMonthOfYear)}
\libfcn{time.isMonthOfYear}

\subsubsection{Day of year range (time.isDayOfYear)}
\libfcn{time.isDayOfYear}

\subsubsection{Weekend range (time.isWeekend)}
\libfcn{time.isWeekend}

\subsubsection{Working hours range (time.isWorkHours)}
\libfcn{time.isWorkHours}

\pagebreak

\hypertarget{hsec:impute}{}
\section{Impute library (missing data handling)}
\label{sec:impute}

Some methods for dealing with missing data are inseparable from the statistical model in question, such as adjustment factors for clustering or surrogate predicates for decision trees.  Those that can be separated have been collected here.

``To impute'' means to \href{http://en.wikipedia.org/wiki/Imputation_(statistics)}{replace missing data with substituted values}.

\subsection{Missing values as null}

\subsubsection{Skip record or halt processing (impute.errorOnNull)}
\libfcn{impute.errorOnNull}

\subsubsection{Replace with default (impute.defaultOnNull)}
\libfcn{impute.defaultOnNull}

\subsection{Floating point missing values}

\subsubsection{Check for not-a-number (impute.isnan)}
\libfcn{impute.isnan}

\subsubsection{Check for infinity (impute.isinf)}
\libfcn{impute.isinf}

\subsubsection{Ensure a finite number (impute.isnum)}
\libfcn{impute.isnum}

\subsubsection{Skip record or halt processing (impute.errorOnNonNum)}
\libfcn{impute.errorOnNonNum}

\subsubsection{Replace with default (impute.defaultOnNonNum)}
\libfcn{impute.defaultOnNonNum}

\pagebreak

\section{Interpolation library}

\subsection{Histogram-like binning (interp.bin)}
\libfcn{interp.bin}

\subsection{Nearest point, vector, or abstract type (interp.nearest)}
\libfcn{interp.nearest}

\subsection{Linear interpolation between two nearest 1-dim points (interp.linear)}
\libfcn{interp.linear}

\subsection{Linear interpolation with flat endpoints (interp.linearFlat)}
\libfcn{interp.linearFlat}

\subsection{Linear interpolation with missing values after endpoints (interp.linearMissing)}
\libfcn{interp.linearMissing}

\pagebreak

\section{Probability libraries}

This library contains methods for calculating properties of probability distributions, many of which are used by descriptive statistics and data mining models.

\subsection{Uniform distribution}
\subsubsection{Probability density function (prob.dist.uniformPDF)}
\libfcn{prob.dist.uniformPDF}
\subsubsection{Cumulative distribution function (prob.dist.uniformCDF)}
\libfcn{prob.dist.uniformCDF}
\subsubsection{Quantile function (prob.dist.uniformQF)}
\libfcn{prob.dist.uniformQF}

\subsection{Exponential distribution}
\subsubsection{Probability density function (prob.dist.exponentialPDF)}
\libfcn{prob.dist.exponentialPDF}
\subsubsection{Cumulative distribution function (prob.dist.exponentialCDF)}
\libfcn{prob.dist.exponentialCDF}
\subsubsection{Quantile function (prob.dist.exponentialQF)}
\libfcn{prob.dist.exponentialQF}

\subsection{Gaussian (normal) distribution}
\subsubsection{Probability density function (prob.dist.gaussianLL)}
\libfcn{prob.dist.gaussianLL}
\subsubsection{Cumulative distribution function (prob.dist.gaussianCDF)}
\libfcn{prob.dist.gaussianCDF}
\subsubsection{Quantile function (prob.dist.gaussianQF)}
\libfcn{prob.dist.gaussianQF}

\subsection{Lognormal distribution}
\subsubsection{Probability density function (prob.dist.lognormalPDF)}
\libfcn{prob.dist.lognormalPDF}
\subsubsection{Cumulative distribution function (prob.dist.lognormalCDF)}
\libfcn{prob.dist.lognormalCDF}
\subsubsection{Quantile function (prob.dist.lognormalQF)}
\libfcn{prob.dist.lognormalQF}

\subsection{Cauchy distribution}
\subsubsection{Probability density function (prob.dist.cauchyPDF)}
\libfcn{prob.dist.cauchyPDF}
\subsubsection{Cumulative distribution function (prob.dist.cauchyCDF)}
\libfcn{prob.dist.cauchyCDF}
\subsubsection{Quantile function (prob.dist.cauchyQF)}
\libfcn{prob.dist.cauchyQF}

\subsection{Binomial distribution}
\subsubsection{Probability density function (prob.dist.binomialPDF)}
\libfcn{prob.dist.binomialPDF}
\subsubsection{Cumulative distribution function (prob.dist.binomialCDF)}
\libfcn{prob.dist.binomialCDF}
\subsubsection{Quantile function (prob.dist.binomialQF)}
\libfcn{prob.dist.binomialQF}

\subsection{Negative Binomial}
\subsubsection{Probability density function (prob.dist.negativebinomialPDF)}
\libfcn{prob.dist.negativeBinomialPDF}
\subsubsection{Cumulative distribution function (prob.dist.negativebinomialCDF)}
\libfcn{prob.dist.negativeBinomialCDF}
\subsubsection{Quantile function (prob.dist.negativebinomialQF)}
\libfcn{prob.dist.negativeBinomialQF}

\subsection{Poisson distribution}
\subsubsection{Probability density function (prob.dist.poissonPDF)}
\libfcn{prob.dist.poissonPDF}
\subsubsection{Cumulative distribution function (prob.dist.poissonCDF)}
\libfcn{prob.dist.poissonCDF}
\subsubsection{Quantile function (prob.dist.poissonQF)}
\libfcn{prob.dist.poissonQF}

\subsection{Student's t distribution}
\subsubsection{Probability density function (prob.dist.tPDF)}
\libfcn{prob.dist.tPDF}
\subsubsection{Cumulative distribution function (prob.dist.tCDF)}
\libfcn{prob.dist.tCDF}
\subsubsection{Quantile function (prob.dist.tQF)}
\libfcn{prob.dist.tQF}

\subsection{F distribution}
\subsubsection{Probability density function (prob.dist.fPDF)}
\libfcn{prob.dist.fPDF}
\subsubsection{Cumulative distribution function (prob.dist.fCDF)}
\libfcn{prob.dist.fCDF}
\subsubsection{Quantile function (prob.dist.fQF)}
\libfcn{prob.dist.fQF}

\subsection{Chi-square distribution}
\subsubsection{Probability density function (prob.dist.chi2PDF)}
\libfcn{prob.dist.chi2PDF}
\subsubsection{Cumulative distribution function (prob.dist.chi2CDF)}
\libfcn{prob.dist.chi2CDF}
\subsubsection{Quantile function (prob.dist.chi2QF)}
\libfcn{prob.dist.chi2QF}

\subsection{Beta distribution}
\subsubsection{Probability density function (prob.dist.betaPDF)}
\libfcn{prob.dist.betaPDF}
\subsubsection{Cumulative distribution function (prob.dist.betaCDF)}
\libfcn{prob.dist.betaCDF}
\subsubsection{Quantile function (prob.dist.betaQF)}
\libfcn{prob.dist.betaQF}

\subsection{Gamma distribution}
\subsubsection{Probability density function (prob.dist.gammaPDF)}
\libfcn{prob.dist.gammaPDF}
\subsubsection{Cumulative distribution function (prob.dist.gammaCDF)}
\libfcn{prob.dist.gammaCDF}
\subsubsection{Quantile function (prob.dist.gammaQF)}
\libfcn{prob.dist.gammaQF}

\subsection{Geometric distribution}
\subsubsection{Probability density function (prob.dist.geometricPDF)}
\libfcn{prob.dist.geometricPDF}
\subsubsection{Cumulative distribution function (prob.dist.geometricCDF)}
\libfcn{prob.dist.geometricCDF}
\subsubsection{Quantile function (prob.dist.geometricQF)}
\libfcn{prob.dist.geometricQF}

\subsection{Hypergeometric distribution}
\subsubsection{Probability density function (prob.dist.hypergeometricPDF)}
\libfcn{prob.dist.hypergeometricPDF}
\subsubsection{Cumulative distribution function (prob.dist.hypergeometricCDF)}
\libfcn{prob.dist.hypergeometricCDF}
\subsubsection{Quantile function (prob.dist.hypergeometricQF)}
\libfcn{prob.dist.hypergeometricQF}

\subsection{Weibull distribution}
\subsubsection{Probability density function (prob.dist.weibullPDF)}
\libfcn{prob.dist.weibullPDF}
\subsubsection{Cumulative distribution function (prob.dist.weibullCDF)}
\libfcn{prob.dist.weibullCDF}
\subsubsection{Quantile function (prob.dist.weibullQF)}
\libfcn{prob.dist.weibullQF}

\pagebreak

\section{Descriptive statistics libraries}

This library contains methods for characterizing a dataset empirically.  These are generally more lightweight than data mining models.

\subsection{Statistical tests}

\subsubsection{Kolmogorov-Smirnov test of two distributions (stat.test.kolmogorov)}
\libfcn{stat.test.kolmogorov}

\subsubsection{Compute residual of a fit (stat.test.residual)}
\libfcn{stat.test.residual}

\subsubsection{Compute the pull of a fit (stat.test.pull)}
\libfcn{stat.test.pull}

\subsubsection{Compute the Mahalanobis of a fit (stat.test.mahalanobis)}
\libfcn{stat.test.mahalanobis}

\subsubsection{Update a cumulative $\chi^2$ calculation (stat.test.updateChi2)}
\libfcn{stat.test.updateChi2}

\subsubsection{Compute the reduced $\chi^2$ (stat.test.reducedChi2)}
\libfcn{stat.test.reducedChi2}

\subsubsection{Compute the $\chi^2$ probability (stat.test.chi2Prob)}
\libfcn{stat.test.chi2Prob}

\subsection{Sample statistics}

\subsubsection{Incremental count, mean, and/or variance (stat.sample.update)}
\libfcn{stat.sample.update}

\subsubsection{Incremental covariance matrix (stat.sample.updateCovariance)}
\libfcn{stat.sample.updateCovariance}

\subsubsection{Incremental count, mean, and/or variance in a window (stat.sample.updateWindow)}
\libfcn{stat.sample.updateWindow}

\subsubsection{Exponentially weighted moving average (EWMA) (stat.sample.updateEWMA)}
\libfcn{stat.sample.updateEWMA}

\subsubsection{Doubly exponential average with trend (stat.sample.updateHoltWinters)}
\libfcn{stat.sample.updateHoltWinters}

\subsubsection{Triply exponential average: trend and period (stat.sample.updateHoltWintersPeriodic)}
\libfcn{stat.sample.updateHoltWintersPeriodic}

\subsubsection{Make one forecast from a Holt-Winters state (stat.sample.forecast1HoltWinters)}
\libfcn{stat.sample.forecast1HoltWinters}

\subsubsection{Make many forecasts from a Holt-Winters state (stat.sample.forecastHoltWinters)}
\libfcn{stat.sample.forecastHoltWinters}

\subsubsection{Fill a histogram (stat.sample.fillHistogram)}
\libfcn{stat.sample.fillHistogram}

\subsubsection{Fill a two-dimensional histogram (stat.sample.fillHistogram2d)}
\libfcn{stat.sample.fillHistogram2d}

\subsubsection{Fill a counter/categorical histogram (stat.sample.fillCounter)}
\libfcn{stat.sample.fillCounter}

\subsubsection{Maintain a top-N list (stat.sample.topN)}
\libfcn{stat.sample.topN}

\subsection{Change detection}

\subsubsection{Historical record of triggered events (stat.change.updateTrigger)}
\libfcn{stat.change.updateTrigger}

\subsubsection{Simple difference over uncertainty (stat.change.zValue)}
\libfcn{stat.change.zValue}

\subsubsection{Cumulative sum (stat.change.updateCUSUM)}
\libfcn{stat.change.updateCUSUM}

\pagebreak

\section{Data mining libraries}

This library contains methods of analyzing data using trained models.  Many of these are usually the outputs of machine learning algorithms.

\subsection{Regression}

\subsubsection{Apply the result of a linear regression (model.reg.linear)}
\libfcn{model.reg.linear}

\subsubsection{Propagate uncertainties through a linear regression (model.reg.linearVariance)}
\libfcn{model.reg.linearVariance}

\subsubsection{Fit and predict a Gaussian Process (model.reg.gaussianProcess)}
\libfcn{model.reg.gaussianProcess}

\subsection{Decision and regression Trees}

This library is organized into test functions (for deciding which branch to take from a given node) and walk functions (for repeatedly applying a test function until reaching a leaf). Different combinations of test functions and walk functions generate a large space of tree-scoring algorithms.

For convenience, the simplest case (simpleTree = simpleTest + simpleWalk) is provided as a single function.

\subsubsection{All-in-one function for simplest case (model.tree.simpleTree)}
\libfcn{model.tree.simpleTree}

\subsubsection{Simple test function for a tree node (model.tree.simpleTest)}
\libfcn{model.tree.simpleTest}

\subsubsection{Test function for a tree node with logical operators (model.tree.compoundTest)}
\libfcn{model.tree.compoundTest}

\subsubsection{Test function with missing value handling (model.tree.missingTest)}
\libfcn{model.tree.missingTest}

\subsubsection{Chain of surrogate tests (model.tree.surrogateTest)}
\libfcn{model.tree.surrogateTest}

\subsubsection{Tree walk without explicit missing value handling (model.tree.simpleWalk)}
\libfcn{model.tree.simpleWalk}

\subsubsection{Tree walk with three branches: pass, fail, and missing (model.tree.missingWalk)}
\libfcn{model.tree.missingWalk}

\subsection{Cluster models}

\subsubsection{Closest cluster (model.cluster.closest)}
\libfcn{model.cluster.closest}

\subsubsection{Closest N clusters or N-nearest neighbrs (model.cluster.closestN)}
\libfcn{model.cluster.closestN}

\subsubsection{Random seeds for online clustering (model.cluster.randomSeeds)}
\libfcn{model.cluster.randomSeeds}

\subsubsection{Online clustering with k-means (model.cluster.kmeansIteration)}
\libfcn{model.cluster.kmeansIteration}

\subsubsection{Update cluster using the mean of data points (model.cluster.updateMean)}
\libfcn{model.cluster.updateMean}

\subsection{Nearest neighbor models}

\subsubsection{K nearest points (model.neighbor.nearestK)}
\libfcn{model.neighbor.nearestK}

\subsubsection{All points within R (model.neighbor.ballR)}
\libfcn{model.neighbor.ballR}

\subsubsection{Mean of a sample of points, with weights (model.neighbor.mean)}
\libfcn{model.neighbor.mean}

\subsection{Naive Bayes}

\subsubsection{Bernoulli two-category likelihood (model.naive.bernoulli)}
\libfcn{model.naive.bernoulli}

\subsubsection{Multinomial multi-category likelihood (model.naive.multinomial)}
\libfcn{model.naive.multinomial}

\subsubsection{Gaussian continuous likelihood (model.naive.gaussian)}
\libfcn{model.naive.gaussian}

\subsection{Neural networks}

\subsubsection{Feedforward neural network organized in layers (model.neural.simpleLayers)}
\libfcn{model.neural.simpleLayers}

\subsection{Support vector machines}

\subsubsection{Basic SVM (model.svm.score)}
\libfcn{model.svm.score}

\end{document}
