\usepackage{xstring}

\newcommand{\libfcn}[1]{%
    \par\noindent%
    \IfEqCase*{#1}{%
    {s.translate}{\hypertarget{s.translate}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.translate":$\!$ [s, oldchars, newchars]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc oldchars \rm & string \\  & \PFAc newchars \rm & string \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} For each character in {\PFAp s} that is also in {\PFAp oldchars} with some index {\PFAc i}, replace it with the character at index {\PFAc i} in {\PFAp newchars}.  Any character in {\PFAp s} that is not in {\PFAp oldchars} is unchanged.  Any index {\PFAc i} that is greater than the length of {\PFAp newchars} is replaced with nothing. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This is the behavior of the the Posix command {\PFAc tr}, where {\PFAp s} takes the place of standard input and {\PFAp oldchars} and {\PFAp newchars} are the {\PFAc tr} commandline options.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.argminN}{\hypertarget{a.argminN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argminN":$\!$ [a, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & {\it (returns)} & array of int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the indexes of the {\PFAp n} lowest values in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their indexes will be returned in ascending order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.geomean}{\hypertarget{a.geomean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.geomean":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the geometric mean of numbers in {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Returns {\PFAc NaN} if the array is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.lower}{\hypertarget{s.lower}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.lower":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Convert {\PFAp s} to lower-case. \vspace{0.2 cm} \\ }}%
    {model.tree.simpleWalk}{\hypertarget{model.tree.simpleWalk}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.tree.simpleWalk":$\!$ [datum, treeNode]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & any record {\PFAtp D} \\  & \PFAc treeNode \rm & any record {\PFAtp T} with \{{\PFApf field:}$\!$ string, {\PFApf operator:}$\!$ string, {\PFApf value:}$\!$ any {\PFAtp V}, {\PFApf pass:}$\!$ union of \{{\PFAtp T}, any {\PFAtp S}\}, {\PFApf fail:}$\!$ union of \{{\PFAtp T}, {\PFAtp S}\}\} \\  & {\it (returns)} & {\PFAtp S} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Descend through a tree comparing {\PFAp datum} to each branch with a simple predicate, stopping at a leaf of type {\PFAtp S} (score). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & An element of the dataset to score with the tree.  \\  & \PFAc treeNode \rm & A node of the decision or regression tree.                                                                 \begin{description*}\item[\PFAc field:] Indicates the field of {\PFAp datum} to test.  Fields may have any type. \item[\PFAc operator:] One of ``=='' (equal), ``!='' (not equal), ``<'' (less than), ``<='' (less or equal), ``>'' (greater than), or ``>='' (greater or equal). \item[\PFAc value:] Value for comparison.  Should be the union of or otherwise broader than all {\PFAp datum} fields under consideration. \item[\PFAc pass:] Branch to return if field {\PFApf field} of {\PFAp datum} {\PFAp operator} {\PFAp value} yields {\PFAc true}. \item[\PFAc fail:] Branch to return if field {\PFApf field} of {\PFAp datum} {\PFAp operator} {\PFAp value} yields {\PFAc false}. \end{description*} \\  & {\it (return value)} \rm & The score associated with the destination leaf, which may be any type {\PFAtp S}.  If {\PFAtp S} is a {\PFAt string}, this is generally called a decision tree; if a {\PFAt double}, it is a regression tree; if an {\PFAt array} of {\PFAt double}, a multivariate regression tree, etc. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``no such field'' error if {\PFApf field} is not a field of {\PFAp datum}. \vspace{0.1 cm} \\ Raises an ``invalid comparison operator'' error if {\PFApf operator} is not one of ``=='', ``!='', ``<'', ``<='', ``>'', or ``>=''. \vspace{0.1 cm} \\ Raises a ``bad value type'' error if the {\PFApf field} of {\PFAp datum} cannot be upcast to {\PFAtp V}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.fold}{\hypertarget{a.fold}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.fold":$\!$ [a, zero, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc zero \rm & any {\PFAtp B} \\  & \PFAc fcn \rm & function ({\PFAtp B}, {\PFAtp A}) $\to$ {\PFAtp B} \\  & {\it (returns)} & {\PFAtp B} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and accumulate a tally, starting with {\PFAp zero}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The first parameter of {\PFAp fcn} is the running tally and the second parameter is an element from {\PFAp a}. \vspace{0.1 cm} \\ The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it accumulates from left (beginning) to right (end), called exactly once for each element.  For predictable results, {\PFAp fcn} should be associative with {\PFAp zero} as its identity; that is, {\PFAc fcn(zero, zero) = zero}.  It need not be commutative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.insert}{\hypertarget{a.insert}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.insert":$\!$ [a, index, item]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc index \rm & int \\  & \PFAc item \rm & {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new array by inserting {\PFAp item} at {\PFAp index} of {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), following Python's index behavior. \vspace{0.1 cm} \\ Note: {\PFAp a} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ The length of the returned array is one more than {\PFAp a}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp index} is beyond the range of {\PFAp a}, an ``array out of range'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.flatmap}{\hypertarget{a.flatmap}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.flatmap":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ array of any {\PFAtp B} \\  & {\it (returns)} & array of {\PFAtp B} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and flatten the resulting arrays into a single array. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.filtermap}{\hypertarget{a.filtermap}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.filtermap":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ union of \{any {\PFAtp B}, null\} \\  & {\it (returns)} & array of {\PFAtp B} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and return an array of the results that are not {\PFAc null}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.cos}{\hypertarget{m.cos}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.cos":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the trigonometric cosine of {\PFAp x}, which is assumed to be in radians. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {cmp}{\hypertarget{cmp}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"cmp":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc 1} if {\PFAp x} is greater than {\PFAp y}, {\PFAc -1} if {\PFAp x} is less than {\PFAp y}, and {\PFAc 0} if {\PFAp x} and {\PFAp y} are equal. \vspace{0.2 cm} \\ }}%
    {a.append}{\hypertarget{a.append}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.append":$\!$ [a, item]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc item \rm & {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new array by adding {\PFAp item} at the end of {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp a} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ The length of the returned array is one more than {\PFAp a}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.ln}{\hypertarget{m.ln}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.ln":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the natural logarithm of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is from 0 to infinity (exclusive).  Given zero, the result is negative infinity, and below zero, the result is   Use \end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.argminLT}{\hypertarget{a.argminLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argminLT":$\!$ [a, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the index of the minimum value in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the minimum is not unique, this function returns the index of the first minimal value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.upper}{\hypertarget{s.upper}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.upper":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Convert {\PFAp s} to upper-case. \vspace{0.2 cm} \\ }}%
    {m.expm1}{\hypertarget{m.expm1}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.expm1":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return $e^x - 1$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Avoids round-off or overflow errors in the intermediate steps. \vspace{0.1 cm} \\ The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {*}{\hypertarget{*}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"*":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Multiply {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Float and double overflows do not produce runtime errors but result in positive or negative infinity, which would be carried through any subsequent calculations (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or NaN values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Integer results above or below -2147483648 and 2147483647 (inclusive) produce an ``int overflow'' runtime error. \vspace{0.1 cm} \\ Long-integer results above or below -9223372036854775808 and 9223372036854775807 (inclusive) produce a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {<=}{\hypertarget{<=}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"<=":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is less than or equal to {\PFAp y}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {m.log}{\hypertarget{m.log}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.log":$\!$ [x, base]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc base \rm & int \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the logarithm of {\PFAp x} with a given {\PFAp base}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is from 0 to infinity (exclusive).  Given zero, the result is negative infinity, and below zero, the result is   Use \end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp base} is less than or equal to zero, this function produces a ``base must be positive'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.shuffle}{\hypertarget{a.shuffle}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.shuffle":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array with the same elements as {\PFAp a} but in a random order. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp a} is not changed in-place; this is a side-effect-free function (except for updating the random number generator).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.endswith}{\hypertarget{a.endswith}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.endswith":$\!$ [haystack, needle]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & array of {\PFAtp A} \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & {\PFAtp A} \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if the last (rightmost) subseqence of {\PFAp haystack} is equal to {\PFAp needle}, false otherwise. \vspace{0.2 cm} \\ }}%
    {\%}{\hypertarget{\%}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"\%":$\!$ [k, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc k \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc n \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAp k} modulo {\PFAp n}; the result has the same sign as the modulus {\PFAp n}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This is the behavior of the {\PFAc \%} operator in Python, {\PFAc mod}/{\PFAc modulo} in Ada, Haskell, and Scheme.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.rindex}{\hypertarget{a.rindex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.rindex":$\!$ [haystack, needle]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & array of {\PFAtp A} \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & {\PFAtp A} \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the highest index where {\PFAp haystack} contains {\PFAp needle} or -1 if {\PFAp haystack} does not contain {\PFAp needle}. \vspace{0.2 cm} \\ }}%
    {m.log10}{\hypertarget{m.log10}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.log10":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the logarithm base 10 of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is from 0 to infinity (exclusive).  Given zero, the result is negative infinity, and below zero, the result is   Use \end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.replaceall}{\hypertarget{s.replaceall}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.replaceall":$\!$ [s, original, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc original \rm & string \\  & \PFAc replacement \rm & string \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace every instance of the substring {\PFAp original} from {\PFAp s} with {\PFAp replacement}. \vspace{0.2 cm} \\ }}%
    {a.intersect}{\hypertarget{a.intersect}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.intersect":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array that represents the intersection of {\PFAp a} and {\PFAp b}, treated as sets (ignoring order and duplicates). \vspace{0.2 cm} \\ }}%
    {a.max}{\hypertarget{a.max}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.max":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the maximum value in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {impute.errorOnNull}{\hypertarget{impute.errorOnNull}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"impute.errorOnNull":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & union of \{any {\PFAtp A}, null\} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Skip an action by raising an ``encountered null'' runtime error when {\PFAp x} is {\PFAc null}. \vspace{0.2 cm} \\ }}%
    {m.abs}{\hypertarget{m.abs}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.abs":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the absolute value of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}For exactly one integer value, -2147483648, this function produces an ``int overflow'' runtime error. \vspace{0.1 cm} \\ For exactly one long value, -9223372036854775808, this function produces a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.minNLT}{\hypertarget{a.minNLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.minNLT":$\!$ [a, n, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the {\PFAp n} lowest values in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.repeat}{\hypertarget{s.repeat}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.repeat":$\!$ [s, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc n \rm & int \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Create a string by concatenating {\PFAp s} with itself {\PFAp n} times. \vspace{0.2 cm} \\ }}%
    {m.atan2}{\hypertarget{m.atan2}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.atan2":$\!$ [y, x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc y \rm & double \\  & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the arc-tangent (inverse of the tangent function) of {\PFAp y}/{\PFAp x} without loss of precision for small {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real plane; no pair of inputs is invalid. \vspace{0.1 cm} \\ Note that {\PFAp y} is the first parameter and {\PFAp x} is the second parameter.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.sample.updateMean}{\hypertarget{stat.sample.updateMean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.updateMean":$\!$ [runningSum, w, x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc runningSum \rm & any record {\PFAtp A} with \{{\PFApf sum\_w:}$\!$ double, {\PFApf sum\_wx:}$\!$ double\} \\  & \PFAc w \rm & double \\  & \PFAc x \rm & double \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update a record containing running sums for computing a sample mean. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc runningSum \rm & Record of partial sums: {\PFAc sum\_w} is the sum of weights, {\PFAc sum\_wx} is the sum of weights times sample values.  \\  & \PFAc w \rm & Weight for this sample, which should be 1 for an unweighted mean.  \\  & \PFAc x \rm & Sample value.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Use {\PFAf \hyperlink{stat.sample.mean}{stat.sample.mean}} to get the mean.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.substr}{\hypertarget{s.substr}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.substr":$\!$ [s, start, end]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the substring of {\PFAp s} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.concat}{\hypertarget{a.concat}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.concat":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Concatenate {\PFAp a} and {\PFAp b} to make a new array of the same type. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The length of the returned array is the sum of the lengths of {\PFAp a} and {\PFAp b}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.reduce}{\hypertarget{a.reduce}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.reduce":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and accumulate a tally. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The first parameter of {\PFAp fcn} is the running tally and the second parameter is an element from {\PFAp a}. \vspace{0.1 cm} \\ The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it accumulates from left (beginning) to right (end), called exactly once for each element.  For predictable results, {\PFAp fcn} should be associative.  It need not be commutative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.len}{\hypertarget{s.len}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.len":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the length of string {\PFAp s}. \vspace{0.2 cm} \\ }}%
    {a.subset}{\hypertarget{a.subset}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.subset":$\!$ [little, big]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc little \rm & array of any {\PFAtp A} \\  & \PFAc big \rm & array of {\PFAtp A} \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp little} is a subset of {\PFAp big}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {a.diff}{\hypertarget{a.diff}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.diff":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array that represents the difference of {\PFAp a} and {\PFAp b}, treated as sets (ignoring order and duplicates). \vspace{0.2 cm} \\ }}%
    {m.exp}{\hypertarget{m.exp}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.exp":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAf \hyperlink{m.e}{m.e}} raised to the power of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.argminNLT}{\hypertarget{a.argminNLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argminNLT":$\!$ [a, n, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the indexes of the {\PFAp n} lowest values in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their indexes will be returned in ascending order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.index}{\hypertarget{a.index}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.index":$\!$ [haystack, needle]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & array of {\PFAtp A} \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & {\PFAtp A} \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the lowest index where {\PFAp haystack} contains {\PFAp needle} or -1 if {\PFAp haystack} does not contain {\PFAp needle}. \vspace{0.2 cm} \\ }}%
    {a.maxN}{\hypertarget{a.maxN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.maxN":$\!$ [a, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the {\PFAp n} highest values in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.distinct}{\hypertarget{a.distinct}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.distinct":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array with the same contents as {\PFAp a} but with duplicates removed. \vspace{0.2 cm} \\ }}%
    {a.sum}{\hypertarget{a.sum}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.sum":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} of \{int, long, float, double\} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the sum of numbers in {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Returns zero if the array is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.reduceright}{\hypertarget{a.reduceright}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.reduceright":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and accumulate a tally. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The first parameter of {\PFAp fcn} is an element from {\PFAp a} and the second parameter is the running tally. \vspace{0.1 cm} \\ The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it accumulates from right (end) to left (beginning), called exactly once for each element.  For predictable results, {\PFAp fcn} should be associative.  It need not be commutative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.any}{\hypertarget{a.any}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.any":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp fcn} is {\PFAc true} for any element in {\PFAp a} (logical or). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The number of {\PFAp fcn} calls is not guaranteed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.substrto}{\hypertarget{s.substrto}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.substrto":$\!$ [s, start, end, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\  & \PFAc replacement \rm & string \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace {\PFAp s} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive) with {\PFAp replacement}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.argmin}{\hypertarget{a.argmin}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argmin":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the index of the minimum value in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the minimum is not unique, this function returns the index of the first minimal value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {impute.defaultOnNull}{\hypertarget{impute.defaultOnNull}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"impute.defaultOnNull":$\!$ [x, default]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & union of \{any {\PFAtp A}, null\} \\  & \PFAc default \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace {\PFAc null} values in {\PFAp x} with {\PFAp default}. \vspace{0.2 cm} \\ }}%
    {a.permutations}{\hypertarget{a.permutations}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.permutations":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the permutations of {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This function scales rapidly with the length of the array.  For reasonably large arrays, it will result in timeout exceptions.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.join}{\hypertarget{s.join}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.join":$\!$ [array, sep]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc array \rm & array of string \\  & \PFAc sep \rm & string \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Combine strings from {\PFAp array} into a single string, delimited by {\PFAp sep}. \vspace{0.2 cm} \\ }}%
    {a.slidingWindow}{\hypertarget{a.slidingWindow}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.slidingWindow":$\!$ [a, size, step, allowIncomplete]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc size \rm & int \\  & \PFAc step \rm & int \\  & \PFAc allowIncomplete \rm & boolean \\  & {\it (returns)} & array of array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array of subsequences of {\PFAp a} with length {\PFAp size} that slide through {\PFAp a} in steps of length {\PFAp step} from left to right. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp allowIncomplete} is {\PFAc true}, the last window may be smaller than {\PFAp size}.  If {\PFAc false}, the last window may be skipped.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp size} is non-positive, a ``size < 1'' runtime error is raised. \vspace{0.1 cm} \\ If {\PFAp step} is non-positive, a ``step < 1'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {<}{\hypertarget{<}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"<":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is less than {\PFAp y}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {a.seteq}{\hypertarget{a.seteq}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.seteq":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp a} and {\PFAp b} are equivalent, ignoring order and duplicates, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {s.split}{\hypertarget{s.split}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.split":$\!$ [s, sep]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc sep \rm & string \\  & {\it (returns)} & array of string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Divide a string into an array of substrings, splitting at and removing delimiters {\PFAp sep}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp s} does not contain {\PFAp sep}, this function returns an array whose only element is {\PFAp s}.  If {\PFAp sep} appears at the beginning or end of {\PFAp s}, the array begins with or ends with an empty string.  These conventions match Python's behavior. \end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.all}{\hypertarget{a.all}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.all":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp fcn} is {\PFAc true} for all elements in {\PFAp a} (logical and). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The number of {\PFAp fcn} calls is not guaranteed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {\&}{\hypertarget{\&}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"\&":$\!$ [x, y]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc y \rm & int \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc y \rm & long \\ & {\it (returns)} & long \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Calculate the bitwise-and of {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ }}%
    {a.mode}{\hypertarget{a.mode}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.mode":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the mode (most common) value of {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If several different values are equally common, the median of these is returned.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.lstrip}{\hypertarget{s.lstrip}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.lstrip":$\!$ [s, chars]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc chars \rm & string \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Remove any characters found in {\PFAp chars} from the beginning (left) of {\PFAp s}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order of characters in {\PFAp chars} is irrelevant.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.min}{\hypertarget{a.min}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.min":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the minimum value in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {>=}{\hypertarget{>=}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{">=":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is greater than or equal to {\PFAp y}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {a.combinations}{\hypertarget{a.combinations}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.combinations":$\!$ [a, size]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc size \rm & int \\  & {\it (returns)} & array of array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the unique combinations of {\PFAp a} with length {\PFAp size}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp size} is non-positive, a ``size < 1'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.reverse}{\hypertarget{a.reverse}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.reverse":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the elements of {\PFAp a} in reversed order. \vspace{0.2 cm} \\ }}%
    {m.atan}{\hypertarget{m.atan}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.atan":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the arc-tangent (inverse of the tangent function) of {\PFAp x} as an angle in radians between $-\pi/2$ and $\pi/2$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {min}{\hypertarget{min}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"min":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAp x} if {\PFAp x} < {\PFAp y}, {\PFAp y} otherwise. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}For the minimum of more than two values, see {\PFAf \hyperlink{a.min}{a.min}}\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.replacefirst}{\hypertarget{s.replacefirst}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.replacefirst":$\!$ [s, original, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc original \rm & string \\  & \PFAc replacement \rm & string \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace the first (leftmost) instance of the substring {\PFAp original} from {\PFAp s} with {\PFAp replacement}. \vspace{0.2 cm} \\ }}%
    {m.copysign}{\hypertarget{m.copysign}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.copysign":$\!$ [mag, sign]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc mag \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc sign \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a number with the magnitude of {\PFAp mag} and the sign of {\PFAp sign}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real or integer plane; no pair of inputs is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.sin}{\hypertarget{m.sin}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.sin":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the trigonometric sine of {\PFAp x}, which is assumed to be in radians. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {|}{\hypertarget{|}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"|":$\!$ [x, y]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc y \rm & int \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc y \rm & long \\ & {\it (returns)} & long \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Calculate the bitwise-or of {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ }}%
    {m.cosh}{\hypertarget{m.cosh}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.cosh":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the hyperbolic cosine of {\PFAp x}, which is equal to $\frac{e^x + e^{-x}}{2}$ \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.pi}{\hypertarget{m.pi}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.pi":$\!$ []\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} The double-precision number that is closer than any other to $\pi$, the ratio of a circumference of a circle to its diameter. \vspace{0.2 cm} \\ }}%
    {or}{\hypertarget{or}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"or":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & boolean \\  & \PFAc y \rm & boolean \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if either {\PFAp x} or {\PFAp y} (or both) are {\PFAc true}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp x} is {\PFAc true}, {\PFAp y} won't be evaluated.  (Only relevant for arguments with side effects.)\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.len}{\hypertarget{a.len}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.len":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the length of array {\PFAp a}. \vspace{0.2 cm} \\ }}%
    {s.contains}{\hypertarget{s.contains}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.contains":$\!$ [haystack, needle]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc needle \rm & string \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp haystack} contains {\PFAp needle}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {a.lnsum}{\hypertarget{a.lnsum}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.lnsum":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the sum of the natural logarithm of numbers in {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Returns zero if the array is empty and {\PFAc NaN} if any value in the array is zero or negative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.startswith}{\hypertarget{s.startswith}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.startswith":$\!$ [haystack, needle]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc needle \rm & string \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if the first (leftmost) subseqence of {\PFAp haystack} is equal to {\PFAp needle}, false otherwise. \vspace{0.2 cm} \\ }}%
    {a.maxLT}{\hypertarget{a.maxLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.maxLT":$\!$ [a, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the maximum value in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.argmaxNLT}{\hypertarget{a.argmaxNLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argmaxNLT":$\!$ [a, n, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the indexes of the {\PFAp n} highest values in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their indexes will be returned in ascending order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {-}{\hypertarget{-}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"-":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Subtract {\PFAp y} from {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Float and double overflows do not produce runtime errors but result in positive or negative infinity, which would be carried through any subsequent calculations (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or NaN values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Integer results above or below -2147483648 and 2147483647 (inclusive) produce an ``int overflow'' runtime error. \vspace{0.1 cm} \\ Long-integer results above or below -9223372036854775808 and 9223372036854775807 (inclusive) produce a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.takeWhile}{\hypertarget{a.takeWhile}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.takeWhile":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to elements of {\PFAp a} and create an array of the longest prefix that returns {\PFAc true}, stopping with the first {\PFAc false}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Beyond the prefix, the number of {\PFAp fcn} calls is not guaranteed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.tanh}{\hypertarget{m.tanh}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.tanh":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the hyperbolic tangent of {\PFAp x}, which is equal to $\frac{e^x - e^{-x}}{e^x + e^{-x}}$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.signum}{\hypertarget{m.signum}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.signum":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return 0 if {\PFAp x} is zero, 1 if {\PFAp x} is positive, and -1 if {\PFAp x} is negative. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.hypot}{\hypertarget{m.hypot}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.hypot":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc y \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return $\sqrt{x^2 + y^2}$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Avoids round-off or overflow errors in the intermediate steps. \vspace{0.1 cm} \\ The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.concat}{\hypertarget{s.concat}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.concat":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\  & \PFAc y \rm & string \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Append {\PFAp y} to {\PFAp x} to form a single string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}To concatenate an array of strings, use s.join with an empty string as {\PFAp sep}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {max}{\hypertarget{max}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"max":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAp x} if {\PFAp x} $\geq$ {\PFAp y}, {\PFAp y} otherwise. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}For the maximum of more than two values, see {\PFAf \hyperlink{a.max}{a.max}}\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.replace}{\hypertarget{a.replace}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.replace":$\!$ [a, index, item]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc index \rm & int \\  & \PFAc item \rm & {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new array by replacing {\PFAp index} of {\PFAp a} with {\PFAp item}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), following Python's index behavior. \vspace{0.1 cm} \\ Note: {\PFAp a} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ The length of the returned array is equal to that of {\PFAp a}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp index} is beyond the range of {\PFAp a}, an ``array out of range'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.tan}{\hypertarget{m.tan}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.tan":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the trigonometric tangent of {\PFAp x}, which is assumed to be in radians. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.remove}{\hypertarget{a.remove}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.remove":$\!$ [a, start, end]\} \rm or \PFAc \{"a.remove":$\!$ [a, index]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\ & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc index \rm & int \\ & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new array by removing elements from {\PFAp a} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive) or just a single {\PFAp index}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior. \vspace{0.1 cm} \\ Note: {\PFAp a} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ The length of the returned array is one less than {\PFAp a}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp index} is beyond the range of {\PFAp a}, an ``array out of range'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.groupby}{\hypertarget{a.groupby}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.groupby":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ string \\  & {\it (returns)} & map of array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Groups elements of {\PFAp a} by the string that {\PFAp fcn} maps them to. \vspace{0.2 cm} \\ }}%
    {a.contains}{\hypertarget{a.contains}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.contains":$\!$ [haystack, needle]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & array of {\PFAtp A} \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & {\PFAtp A} \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp haystack} contains {\PFAp needle}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {**}{\hypertarget{**}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"**":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Raise {\PFAp x} to the power {\PFAp n}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Float and double overflows do not produce runtime errors but result in positive or negative infinity, which would be carried through any subsequent calculations (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or NaN values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Integer results above or below -2147483648 and 2147483647 (inclusive) produce an ``int overflow'' runtime error. \vspace{0.1 cm} \\ Long-integer results above or below -9223372036854775808 and 9223372036854775807 (inclusive) produce a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {==}{\hypertarget{==}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"==":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is equal to {\PFAp y}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {s.index}{\hypertarget{s.index}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.index":$\!$ [haystack, needle]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc needle \rm & string \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the lowest index where {\PFAp haystack} contains {\PFAp needle} or -1 if {\PFAp haystack} does not contain {\PFAp needle}. \vspace{0.2 cm} \\ }}%
    {xor}{\hypertarget{xor}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"xor":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & boolean \\  & \PFAc y \rm & boolean \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is {\PFAc true} and {\PFAp y} is {\PFAc false} or if {\PFAp x} is {\PFAc false} and {\PFAp y} is {\PFAc true}, but return {\PFAc false} for any other case. \vspace{0.2 cm} \\ }}%
    {a.subseq}{\hypertarget{a.subseq}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.subseq":$\!$ [a, start, end]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the subsequence of {\PFAp a} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {u-}{\hypertarget{u-}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"u-":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the additive inverse of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}For exactly one integer value, -2147483648, this function produces an ``int overflow'' runtime error. \vspace{0.1 cm} \\ For exactly one long value, -9223372036854775808, this function produces a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.corresponds}{\hypertarget{a.corresponds}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.corresponds":$\!$ [a, b, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of any {\PFAtp B} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp B}) $\to$ boolean \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp fcn} is {\PFAc true} when applied to all pairs of elements, one from {\PFAp a} and the other from {\PFAp b} (logical relation). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The number of {\PFAp fcn} calls is not guaranteed. \vspace{0.1 cm} \\ If the lengths of {\PFAp a} and {\PFAp b} are not equal, this function returns {\PFAc false}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {not}{\hypertarget{not}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"not":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & boolean \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is {\PFAc false} and {\PFAc false} if {\PFAp x} is {\PFAc true}. \vspace{0.2 cm} \\ }}%
    {a.minLT}{\hypertarget{a.minLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.minLT":$\!$ [a, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the minimum value in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.round}{\hypertarget{m.round}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.round":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & long \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the closest whole number to {\PFAp x}, rounding up if the fractional part is exactly one-half. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Equal to {\PFAf \hyperlink{m.floor}{m.floor}} of ({\PFAp x} + 0.5).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Integer results outside of -2147483648 and 2147483647 (inclusive) produce an ``int overflow'' runtime error. \vspace{0.1 cm} \\ Long-integer results outside of -9223372036854775808 and 9223372036854775807 (inclusive) produce a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.sort}{\hypertarget{a.sort}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.sort":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array with the same elements as {\PFAp a} but in ascending order (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp a} is not changed in-place; this is a side-effect-free function.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.mean}{\hypertarget{a.mean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.mean":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the arithmetic mean of numbers in {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Returns {\PFAc NaN} if the array is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.count}{\hypertarget{a.count}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.count":$\!$ [haystack, needle]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & array of {\PFAtp A} \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & {\PFAtp A} \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & function ({\PFAtp A}) $\to$ boolean \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Count the number of times {\PFAp needle} appears in {\PFAp haystack} or the number of times the {\PFAp needle} function evaluates to {\PFAc true}. \vspace{0.2 cm} \\ }}%
    {a.median}{\hypertarget{a.median}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.median":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the value that is in the center of a sorted version of {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} has an odd number of elements, the median is the exact center of the sorted array.  If {\PFAp a} has an even number of elements and is a {\PFAc float} or {\PFAc double}, the median is the average of the two elements closest to the center of the sorted array.  For any other type, the median is the left (first) of the two elements closest to the center of the sorted array.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.ceil}{\hypertarget{m.ceil}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.ceil":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the smallest (closest to negative infinity, not closest to zero) whole number that is greater than or equal to the input. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.e}{\hypertarget{m.e}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.e":$\!$ []\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} The double-precision number that is closer than any other to $e$, the base of natural logarithms. \vspace{0.2 cm} \\ }}%
    {a.filter}{\hypertarget{a.filter}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.filter":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and return an array of the elements for which {\PFAp fcn} returns {\PFAc true}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.asin}{\hypertarget{m.asin}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.asin":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the arc-sine (inverse of the sine function) of {\PFAp x} as an angle in radians between $-\pi/2$ and $\pi/2$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is from -1 to 1 (inclusive).  Beyond this domain, the result is   Use \end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.rindex}{\hypertarget{s.rindex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.rindex":$\!$ [haystack, needle]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc needle \rm & string \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the highest index where {\PFAp haystack} contains {\PFAp needle} or -1 if {\PFAp haystack} does not contain {\PFAp needle}. \vspace{0.2 cm} \\ }}%
    {a.union}{\hypertarget{a.union}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.union":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array that represents the union of {\PFAp a} and {\PFAp b}, treated as sets (ignoring order and duplicates). \vspace{0.2 cm} \\ }}%
    {m.sqrt}{\hypertarget{m.sqrt}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.sqrt":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the positive square root of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is from 0 (inclusive) to infinity.  Beyond this domain, the result is   Use \end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.rint}{\hypertarget{m.rint}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.rint":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the closest whole number to {\PFAp x}, rounding toward the nearest even number if the fractional part is exactly one-half. \vspace{0.2 cm} \\ }}%
    {//}{\hypertarget{//}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"//":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long\} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Divide {\PFAp y} from {\PFAp x}, returning the largest whole number {\PFAc N} for which {\PFAc N} $\leq$ {\PFAp x}/{\PFAp y} (integral floor division). \vspace{0.2 cm} \\ }}%
    {a.map}{\hypertarget{a.map}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.map":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ any {\PFAtp B} \\  & {\it (returns)} & array of {\PFAtp B} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and return an array of the results. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {+}{\hypertarget{+}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"+":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Add {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Float and double overflows do not produce runtime errors but result in positive or negative infinity, which would be carried through any subsequent calculations (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or NaN values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Integer results above or below -2147483648 and 2147483647 (inclusive) produce an ``int overflow'' runtime error. \vspace{0.1 cm} \\ Long-integer results above or below -9223372036854775808 and 9223372036854775807 (inclusive) produce a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {!=}{\hypertarget{!=}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"!=":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is not equal to {\PFAp y}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {stat.sample.mean}{\hypertarget{stat.sample.mean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.mean":$\!$ [runningSum]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc runningSum \rm & any record {\PFAtp A} with \{{\PFApf sum\_w:}$\!$ double, {\PFApf sum\_wx:}$\!$ double\} \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the mean from a {\PFAp runningSum} record. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Use {\PFAf \hyperlink{stat.sample.updateMean}{stat.sample.updateMean}} to fill the record.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.replacelast}{\hypertarget{s.replacelast}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.replacelast":$\!$ [s, original, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc original \rm & string \\  & \PFAc replacement \rm & string \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace the last (rightmost) instance of the substring {\PFAp original} from {\PFAp s} with {\PFAp replacement}. \vspace{0.2 cm} \\ }}%
    {a.argmax}{\hypertarget{a.argmax}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argmax":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the index of the maximum value in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the maximum is not unique, this function returns the index of the first maximal value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.ln1p}{\hypertarget{m.ln1p}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.ln1p":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return $ln(x^2 + 1)$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Avoids round-off or overflow errors in the intermediate steps. \vspace{0.1 cm} \\ The domain of this function is from -1 to infinity (exclusive).  Given -1, the result is negative infinity, and below -1, the result is   Use \end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.argmaxN}{\hypertarget{a.argmaxN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argmaxN":$\!$ [a, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & {\it (returns)} & array of int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the indexes of the {\PFAp n} highest values in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their indexes will be returned in ascending order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.acos}{\hypertarget{m.acos}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.acos":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the arc-cosine (inverse of the cosine function) of {\PFAp x} as an angle in radians between $0$ and $\pi$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is from -1 to 1 (inclusive).  Beyond this domain, the result is   Use \end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.endswith}{\hypertarget{s.endswith}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.endswith":$\!$ [haystack, needle]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc needle \rm & string \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if the last (rightmost) subseqence of {\PFAp haystack} is equal to {\PFAp needle}, false otherwise. \vspace{0.2 cm} \\ }}%
    {m.floor}{\hypertarget{m.floor}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.floor":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the largest (closest to positive infinity) whole number that is less than or equal to the input. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.startswith}{\hypertarget{a.startswith}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.startswith":$\!$ [haystack, needle]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & array of {\PFAtp A} \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & {\PFAtp A} \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if the first (leftmost) subseqence of {\PFAp haystack} is equal to {\PFAp needle}, false otherwise. \vspace{0.2 cm} \\ }}%
    {a.argmaxLT}{\hypertarget{a.argmaxLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argmaxLT":$\!$ [a, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the index of the maximum value in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the maximum is not unique, this function returns the index of the first maximal value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.rstrip}{\hypertarget{s.rstrip}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.rstrip":$\!$ [s, chars]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc chars \rm & string \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Remove any characters found in {\PFAp chars} from the end (right) of {\PFAp s}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order of characters in {\PFAp chars} is irrelevant.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.sinh}{\hypertarget{m.sinh}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.sinh":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the hyperbolic sine of {\PFAp x}, which is equal to $\frac{e^x - e^{-x}}{2}$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {TILDE}{\hypertarget{TILDE}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"\textasciitilde{}":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\ & {\it (returns)} & long \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Calculate the bitwise-not of {\PFAp x}. \vspace{0.2 cm} \\ }}%
    {a.disjoint}{\hypertarget{a.disjoint}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.disjoint":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp a} and {\PFAp b} are disjoint, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {a.product}{\hypertarget{a.product}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.product":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} of \{int, long, float, double\} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the product of numbers in {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Returns one if the array is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.minN}{\hypertarget{a.minN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.minN":$\!$ [a, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the {\PFAp n} lowest values in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.foldright}{\hypertarget{a.foldright}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.foldright":$\!$ [a, zero, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc zero \rm & any {\PFAtp B} \\  & \PFAc fcn \rm & function ({\PFAtp B}, {\PFAtp A}) $\to$ {\PFAtp B} \\  & {\it (returns)} & {\PFAtp B} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and accumulate a tally, starting with {\PFAp zero}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The first parameter of {\PFAp fcn} is an element from {\PFAp a} and the second parameter is the running tally. \vspace{0.1 cm} \\ The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it accumulates from right (end) to left (beginning), called exactly once for each element.  For predictable results, {\PFAp fcn} should be associative with {\PFAp zero} as its identity; that is, {\PFAc fcn(zero, zero) = zero}.  It need not be commutative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.strip}{\hypertarget{s.strip}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.strip":$\!$ [s, chars]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc chars \rm & string \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Remove any characters found in {\PFAp chars} from the beginning or end of {\PFAp s}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order of characters in {\PFAp chars} is irrelevant.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {\^{}}{\hypertarget{\^{}}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"\^{}":$\!$ [x, y]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc y \rm & int \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc y \rm & long \\ & {\it (returns)} & long \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Calculate the bitwise-exclusive-or of {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ }}%
    {a.subseqto}{\hypertarget{a.subseqto}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.subseqto":$\!$ [a, start, end, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\  & \PFAc replacement \rm & array of {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new array by replacing {\PFAp a} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive) with {\PFAp replacement}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior. \vspace{0.1 cm} \\ Note: {\PFAp a} is not changed in-place; this is a side-effect-free function.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.flatten}{\hypertarget{a.flatten}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.flatten":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Concatenate the arrays in {\PFAp a}. \vspace{0.2 cm} \\ }}%
    {and}{\hypertarget{and}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"and":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & boolean \\  & \PFAc y \rm & boolean \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} and {\PFAp y} are both {\PFAc true}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp x} is {\PFAc false}, {\PFAp y} won't be evaluated.  (Only relevant for arguments with side effects.)\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {/}{\hypertarget{/}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"/":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc y \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Divide {\PFAp y} from {\PFAp x}, returning a floating-point number (even if {\PFAp x} and {\PFAp y} are integers). \vspace{0.2 cm} \\ }}%
    {>}{\hypertarget{>}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{">":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is greater than {\PFAp y}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {a.maxNLT}{\hypertarget{a.maxNLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.maxNLT":$\!$ [a, n, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the {\PFAp n} highest values in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {\%\%}{\hypertarget{\%\%}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"\%\%":$\!$ [k, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc k \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc n \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the remainder of {\PFAp k} divided by {\PFAp n}; the result has the same sign as the dividend {\PFAp k}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This is the behavior of the {\PFAc \%} operator in Fortran, C/C++, and Java, {\PFAc rem}/{\PFAc remainder} in Ada, Haskell, and Scheme.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.symdiff}{\hypertarget{a.symdiff}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.symdiff":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array that represents the symmetric difference of {\PFAp a} and {\PFAp b}, treated as sets (ignoring order and duplicates). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The symmetric difference is ({\PFAp a} diff {\PFAp b}) union ({\PFAp b} diff {\PFAp a}).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.tree.predicateWalk}{\hypertarget{model.tree.predicateWalk}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.tree.predicateWalk":$\!$ [datum, treeNode, predicate]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & any record {\PFAtp D} \\  & \PFAc treeNode \rm & any record {\PFAtp T} with \{{\PFApf pass:}$\!$ union of \{{\PFAtp T}, any {\PFAtp S}\}, {\PFApf fail:}$\!$ union of \{{\PFAtp T}, {\PFAtp S}\}\} \\  & \PFAc predicate \rm & function ({\PFAtp D}, {\PFAtp T}) $\to$ boolean \\  & {\it (returns)} & {\PFAtp S} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Descend through a tree comparing {\PFAp datum} to each branch with a user-defined predicate, stopping at a leaf of type {\PFAtp S} (score). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & An element of the dataset to score with the tree.  \\  & \PFAc treeNode \rm & A node of the decision or regression tree.                                \begin{description*}\item[\PFAc pass:] Branch to return if {\PFAc {``predicate'': [``datum'', ``treeNode'']}} yields {\PFAc true}. \item[\PFAc fail:] Branch to return if {\PFAc {``predicate'': [``datum'', ``treeNode'']}} yields {\PFAc false}. \end{description*} \\  & {\it (return value)} \rm & The score associated with the destination leaf, which may be any type {\PFAtp S}.  If {\PFAtp S} is a {\PFAt string}, this is generally called a decision tree; if a {\PFAt double}, it is a regression tree; if an {\PFAt array} of {\PFAt double}, a multivariate regression tree, etc. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {s.count}{\hypertarget{s.count}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.count":$\!$ [haystack, needle]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc needle \rm & string \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Count the number of times {\PFAp needle} appears in {\PFAp haystack}. \vspace{0.2 cm} \\ }}%
    {a.sortLT}{\hypertarget{a.sortLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.sortLT":$\!$ [a, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array with the same elements as {\PFAp a} but in ascending order as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp a} is not changed in-place; this is a side-effect-free function.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.dropWhile}{\hypertarget{a.dropWhile}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.dropWhile":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to elements of {\PFAp a} and create an array of all elements after the longest prefix that returns {\PFAc true}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Beyond the prefix, the number of {\PFAp fcn} calls is not guaranteed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    }[{\bf FIXME: LaTeX error: wrong libfcn name!}]%
}%
