\usepackage{xstring}

\newcommand{\libfcn}[1]{%
    \par\noindent%
    \IfEqCase*{#1}{%
    {prob.dist.gaussianCDF}{\hypertarget{prob.dist.gaussianCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"prob.dist.gaussianCDF":$\!$ [x, mu, sigma]\} \rm or \PFAc \{"prob.dist.gaussianCDF":$\!$ [x, params]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc mu \rm & double \\  & \PFAc sigma \rm & double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc params \rm & any record {\PFAtp A} with \{{\PFApf mean:}$\!$ double, {\PFApf variance:}$\!$ double\} \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the cumultive distribution function (CDF) for the normal distribution, parameterized by {\PFAp mu} and {\PFAp sigma} or a record {\PFAp params}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc mu \rm & Centroid of the distribution (same as {\PFApf mean}).  \\  & \PFAc sigma \rm & Width of the distribution (same as the square root of {\PFApf variance}).  \\  & \PFAc params \rm & Alternate way of specifying the parameters of the distribution; this record could be created by {\PFAf \hyperlink{stat.sample.update}{stat.sample.update}}.  \\  & {\it (return value)} \rm & With $\mu$ = {\PFAp mu} or {\PFApf mean} and $\sigma$ = {\PFAp sigma} or the square root of {\PFApf variance}, this function returns $0.5 * ( 1.0 + \mathrm{Erf}(\frac{x - \mu}{\sigma \sqrt{2}}))$. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {s.translate}{\hypertarget{s.translate}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.translate":$\!$ [s, oldchars, newchars]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc oldchars \rm & string \\  & \PFAc newchars \rm & string \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} For each character in {\PFAp s} that is also in {\PFAp oldchars} with some index {\PFAc i}, replace it with the character at index {\PFAc i} in {\PFAp newchars}.  Any character in {\PFAp s} that is not in {\PFAp oldchars} is unchanged.  Any index {\PFAc i} that is greater than the length of {\PFAp newchars} is replaced with nothing. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This is the behavior of the the Posix command {\PFAc tr}, where {\PFAp s} takes the place of standard input and {\PFAp oldchars} and {\PFAp newchars} are the {\PFAc tr} commandline options.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {\^{}\^{}}{\hypertarget{\^{}\^{}}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"\^{}\^{}":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & boolean \\  & \PFAc y \rm & boolean \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is {\PFAc true} and {\PFAp y} is {\PFAc false} or if {\PFAp x} is {\PFAc false} and {\PFAp y} is {\PFAc true}, but return {\PFAc false} for any other case. \vspace{0.2 cm} \\ }}%
    {bytes.encodeUtf8}{\hypertarget{bytes.encodeUtf8}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.encodeUtf8":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & bytes \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Encode a string as utf-8 bytes. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises an ``invalid string'' error if the string cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.special.erfc}{\hypertarget{m.special.erfc}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.special.erfc":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the complimentary error function of {\PFAp x}. \vspace{0.2 cm} \\ }}%
    {map.mapWithKey}{\hypertarget{map.mapWithKey}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.mapWithKey":$\!$ [m, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function (string, {\PFAtp A}) $\to$ any {\PFAtp B} \\  & {\it (returns)} & map of {\PFAtp B} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each key, value pair of {\PFAp m} and return a map of transformed values (keys are unchanged). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on items in {\PFAp m} is not guaranteed, though it will be called exactly once for each value. \vspace{0.1 cm} \\ To transform both keys and values, consider applying {\PFAf \hyperlink{map.split}{map.split}}, {\PFAf \hyperlink{a.map}{a.map}}, then {\PFAf \hyperlink{map.join}{map.join}}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.filterMapWithIndex}{\hypertarget{a.filterMapWithIndex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.filterMapWithIndex":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function (int, {\PFAtp A}) $\to$ union of \{any {\PFAtp B}, null\} \\  & {\it (returns)} & array of {\PFAtp B} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each index, element pair of {\PFAp a} and return an array of the results that are not {\PFAc null}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.argminN}{\hypertarget{a.argminN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argminN":$\!$ [a, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & {\it (returns)} & array of int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the indexes of the {\PFAp n} lowest values in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their indexes will be returned in ascending order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.cauchyPDF}{\hypertarget{prob.dist.cauchyPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.cauchyPDF":$\!$ [x, location, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc location \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the cauchy distribution parameterized by {\PFAp location} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc location \rm & Location parameter (l).  \\  & \PFAc scale \rm & Scale parameter (s).  \\  & {\it (return value)} \rm & With $location$, $scale$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{1}{(\pi s (1 + (\frac{x - l}{s})^{2})) }$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $scale \leq 0$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.geomean}{\hypertarget{a.geomean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.geomean":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the geometric mean of numbers in {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Returns {\PFAc NaN} if the array is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.disjoint}{\hypertarget{map.disjoint}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.disjoint":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of {\PFAtp A} \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if set {\PFAp a} and set {\PFAp b} are disjoint, {\PFAc false} otherwise, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro. \vspace{0.1 cm} \\ This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {enum.toInt}{\hypertarget{enum.toInt}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"enum.toInt":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any enum {\PFAtp A} \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the integer representation of an enum. \vspace{0.2 cm} \\ }}%
    {s.lower}{\hypertarget{s.lower}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.lower":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Convert {\PFAp s} to lower-case. \vspace{0.2 cm} \\ }}%
    {stat.change.zValue}{\hypertarget{stat.change.zValue}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.change.zValue":$\!$ [x, meanVariance, unbiased]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc meanVariance \rm & any record {\PFAtp A} with \{{\PFApf count:}$\!$ double, {\PFApf mean:}$\!$ double, {\PFApf variance:}$\!$ double\} \\  & \PFAc unbiased \rm & boolean \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Calculate the z-value between {\PFAp x} and a normal distribution with a given mean and variance. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value to test.  \\  & \PFAc meanVariance \rm & A record with {\PFApf count}, {\PFApf mean}, and {\PFApf variance}, such as the output of {\PFAf \hyperlink{stat.sample.Update}{stat.sample.Update}}.  \\  & \PFAc unbiased \rm & If {\PFAc true}, use {\PFApf count} to correct for the bias due to the fact that a variance centered on the mean has one fewer degrees of freedom than the dataset that it was sampled from (Bessel's correction).  \\  & {\it (return value)} \rm & If {\PFAp unbiased} is {\PFAc false}, $(x - mean)/\sqrt{variance}$; otherwise $(x - mean)(1/\sqrt{variance})\sqrt{count/(count - 1)}$. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {la.transpose}{\hypertarget{la.transpose}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.transpose":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\ & {\it (returns)} & array of array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\ & {\it (returns)} & map of map of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Transpose a rectangular matrix. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the matrix has fewer than 1 row or fewer than 1 column, this function raises a ``too few rows/cols'' error. \vspace{0.1 cm} \\ If the columns are ragged (arrays of different lengths or maps with different sets of keys), this function raises a ``ragged columns'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.tree.simpleWalk}{\hypertarget{model.tree.simpleWalk}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.tree.simpleWalk":$\!$ [datum, treeNode, test]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & any record {\PFAtp D} \\  & \PFAc treeNode \rm & any record {\PFAtp T} with \{{\PFApf pass:}$\!$ union of \{{\PFAtp T}, any {\PFAtp S}\}, {\PFApf fail:}$\!$ union of \{{\PFAtp T}, {\PFAtp S}\}\} \\  & \PFAc test \rm & function ({\PFAtp D}, {\PFAtp T}) $\to$ boolean \\  & {\it (returns)} & {\PFAtp S} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Descend through a tree, testing the fields of {\PFAp datum} with the {\PFAp test} function using {\PFAp treeNode} to define the comparison, continuing to {\PFApf pass} or {\PFApf fail} until reaching a leaf node of type {\PFAtp S} (score). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Sample value to test.  \\  & \PFAc treeNode \rm & Node of the tree, which contains a predicate to be interpreted by {\PFAp test}.                                \begin{description*}\item[\PFAc pass:] Branch to follow if {\PFAp test} returns {\PFAc true}. \item[\PFAc fail:] Branch to follow if {\PFAp test} returns {\PFAc false}. \end{description*} \\  & \PFAc test \rm & Test function that converts {\PFAp datum} and {\PFAp treeNode} into {\PFAc true} or {\PFAc false}.  \\  & {\it (return value)} \rm & Leaf node of type {\PFAtp S}, which must be different from the tree nodes.  For a classification tree, {\PFAtp S} could be a string or an enumeration set.  For a regression tree, {\PFAtp S} would be a numerical type.  For a multivariate regression tree, {\PFAtp S} would be an array of numbers, etc. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {a.fold}{\hypertarget{a.fold}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.fold":$\!$ [a, zero, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc zero \rm & any {\PFAtp B} \\  & \PFAc fcn \rm & function ({\PFAtp B}, {\PFAtp A}) $\to$ {\PFAtp B} \\  & {\it (returns)} & {\PFAtp B} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and accumulate a tally, starting with {\PFAp zero}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The first parameter of {\PFAp fcn} is the running tally and the second parameter is an element from {\PFAp a}. \vspace{0.1 cm} \\ The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it accumulates from left (beginning) to right (end), called exactly once for each element.  For predictable results, {\PFAp fcn} should be associative with {\PFAp zero} as its identity; that is, {\PFAc fcn(zero, zero) = zero}.  It need not be commutative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.last}{\hypertarget{a.last}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.last":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the first item of the array. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.insert}{\hypertarget{a.insert}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.insert":$\!$ [a, index, item]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc index \rm & int \\  & \PFAc item \rm & {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new array by inserting {\PFAp item} at {\PFAp index} of {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), following Python's index behavior. \vspace{0.1 cm} \\ Note: {\PFAp a} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ The length of the returned array is one more than {\PFAp a}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp index} is beyond the range of {\PFAp a}, an ``array out of range'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {metric.simpleEuclidean}{\hypertarget{metric.simpleEuclidean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"metric.simpleEuclidean":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc y \rm & array of double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Euclidean metric without a special similarity function and without any handling of missing values. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & First sample vector.  \\  & \PFAc y \rm & Second sample vector.  (Must have the same dimension as {\PFAp x}.)  \\  & {\it (return value)} \rm & Returns $\sqrt{\sum_i (x_i - y_i)^2}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``dimensions of vectors do not match'' if all vectors do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.gaussianQF}{\hypertarget{prob.dist.gaussianQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"prob.dist.gaussianQF":$\!$ [p, mu, sigma]\} \rm or \PFAc \{"prob.dist.gaussianQF":$\!$ [p, params]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc mu \rm & double \\  & \PFAc sigma \rm & double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc params \rm & any record {\PFAtp A} with \{{\PFApf mean:}$\!$ double, {\PFApf variance:}$\!$ double\} \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the normal quantile (QF, the inverse of the CDF) parameterized by {\PFAp mu} and {\PFAp sigma} or a record {\PFAp params}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Probability at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc mu \rm & Centroid of the distribution (same as {\PFApf mean}).  \\  & \PFAc sigma \rm & Width of the distribution (same as the square root of {\PFApf variance}).  \\  & \PFAc params \rm & Alternate way of specifying the parameters of the distribution; this record could be created by {\PFAf \hyperlink{stat.sample.update}{stat.sample.update}}.  \\  & {\it (return value)} \rm & With $\mu$ = {\PFAp mu} or {\PFApf mean} and $\sigma$ = {\PFAp sigma} or the square root of {\PFApf variance}, this function returns $\mu + \sigma \sqrt{2} \mathrm{Erf}^{-1} (2p - 1)$. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {re.groupsall}{\hypertarget{re.groupsall}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.groupsall":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & array of array of array of int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & array of array of array of int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the location indices of each {\PFAp pattern} sub-match (group-match) for each occurance of {\PFAp pattern} in {\PFAp haystack}. \vspace{0.2 cm} \\ }}%
    {rand.choice}{\hypertarget{rand.choice}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"rand.choice":$\!$ [population]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc population \rm & array of any {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random item from a bag of items. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``population must not be empty'' error if {\PFAp population} is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.sample.updateEWMA}{\hypertarget{stat.sample.updateEWMA}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.updateEWMA":$\!$ [x, alpha, state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc alpha \rm & double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf mean:}$\!$ double\} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update the state of an exponentially weighted moving average (EWMA). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample value.  \\  & \PFAc alpha \rm & Weighting factor (usually a constant) between 0 and 1, inclusive.  If {\PFAp alpha} is close to 1, recent data are heavily weighted at the expense of old data; if {\PFAp alpha} is close to 0, the EWMA approaches a simple mean.  \\  & \PFAc state \rm & Record of the previous {\PFApf mean} and {\PFApf variance}.                                \begin{description*}\item[\PFAc mean:] The exponentially weighted mean of {\PFAp x}, weighted by {\PFAp alpha}. \item[\PFAc variance:] The exponentially weighted variance of {\PFAp x}, weighted by {\PFAp alpha}.  This field is optional, but if provided, it must be a {\PFAc double}. \end{description*} \\  & {\it (return value)} \rm & Returns a new record with updated {\PFApf mean} and {\PFApf variance}.  If the input {\PFAp state} has fields other than {\PFApf mean} and {\PFApf variance}, they are copied unaltered to the output state. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp alpha} is less than 0 or greater than 1, an ``alpha out of range'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {cast.unsigned}{\hypertarget{cast.unsigned}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"cast.unsigned":$\!$ [x, bits]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc bits \rm & int \\  & {\it (returns)} & long \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Truncate {\PFAp x} as though its signed long two's complement representation were inserted, bit-for-bit, into an unsigned register that is {\PFAp bits} wide, removing the most significant bits. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The result of this function is always nonnegative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp bits} is less than 1 or greater than 63, an ``unrepresentable unsigned number'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.except}{\hypertarget{map.except}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.except":$\!$ [m, keys]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc keys \rm & array of string \\  & {\it (returns)} & map of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new map, keeping all but {\PFAp keys} from {\PFAp m}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp m} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ If some {\PFAp keys} are not in {\PFAp m}, they are ignored and do not appear in the return value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.cos}{\hypertarget{m.cos}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.cos":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the trigonometric cosine of {\PFAp x}, which is assumed to be in radians. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.replaceall}{\hypertarget{re.replaceall}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.replaceall":$\!$ [pattern, haystack, replacement]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pattern \rm & string \\  & \PFAc haystack \rm & string \\  & \PFAc replacement \rm & string \\ & {\it (returns)} & string \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pattern \rm & bytes \\  & \PFAc haystack \rm & bytes \\  & \PFAc replacement \rm & bytes \\ & {\it (returns)} & bytes \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace the all {\PFAp pattern} matches in {\PFAp haystack} with {\PFAp replacement}. \vspace{0.2 cm} \\ }}%
    {bytes.fromBase64}{\hypertarget{bytes.fromBase64}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.fromBase64":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & bytes \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Convert a base64-encoded string to a bytes object. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises an ``invalid base64'' error if the string is not valid base64.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {cmp}{\hypertarget{cmp}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"cmp":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc 1} if {\PFAp x} is greater than {\PFAp y}, {\PFAc -1} if {\PFAp x} is less than {\PFAp y}, and {\PFAc 0} if {\PFAp x} and {\PFAp y} are equal. \vspace{0.2 cm} \\ }}%
    {a.append}{\hypertarget{a.append}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.append":$\!$ [a, item]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc item \rm & {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new array by adding {\PFAp item} at the end of {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp a} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ The length of the returned array is one more than {\PFAp a}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.ln}{\hypertarget{m.ln}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.ln":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the natural logarithm of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is from 0 to infinity (exclusive).  Given zero, the result is negative infinity, and below zero, the result is {\PFAc NaN}, not an exception (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or {\PFAc NaN} values."\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.argminLT}{\hypertarget{a.argminLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argminLT":$\!$ [a, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the index of the minimum value in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the minimum is not unique, this function returns the index of the first minimal value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.findgroupsall}{\hypertarget{re.findgroupsall}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.findgroupsall":$\!$ [pattern, haystack]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pattern \rm & string \\  & \PFAc haystack \rm & string \\ & {\it (returns)} & array of array of string \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pattern \rm & bytes \\  & \PFAc haystack \rm & bytes \\ & {\it (returns)} & array of array of bytes \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array of strings or bytes for each {\PFAp pattern} sub-match (group-match) at every occurance of {\PFAp pattern} in {\PFAp haystack}. \vspace{0.2 cm} \\ }}%
    {s.upper}{\hypertarget{s.upper}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.upper":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Convert {\PFAp s} to upper-case. \vspace{0.2 cm} \\ }}%
    {m.link.cloglog}{\hypertarget{m.link.cloglog}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.cloglog":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the cloglog function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $1 - \exp(-\exp(x_i))$. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {m.expm1}{\hypertarget{m.expm1}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.expm1":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return $e^x - 1$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Avoids round-off or overflow errors in the intermediate steps. \vspace{0.1 cm} \\ The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.isHourOfDay}{\hypertarget{time.isHourOfDay}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isHourOfDay":$\!$ [ts, low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc low \rm & double \\  & \PFAc high \rm & double \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Checks if a timestamp falls within a time range, specified in terms of hours of the day.  Timestamp is assumed to be in UTC. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Timestamp.  \\  & \PFAc low \rm & Lower boundary of the range.  \\  & \PFAc high \rm & Upper boundary of the range.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``bad time range'' if low $\mathrm{low} \geq \mathrm{high}$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.map}{\hypertarget{map.map}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.map":$\!$ [m, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ any {\PFAtp B} \\  & {\it (returns)} & map of {\PFAtp B} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each value of {\PFAp m} and return a map of transformed values (keys are unchanged). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on items in {\PFAp m} is not guaranteed, though it will be called exactly once for each value. \vspace{0.1 cm} \\ To transform both keys and values, consider applying {\PFAf \hyperlink{map.split}{map.split}}, {\PFAf \hyperlink{a.map}{a.map}}, then {\PFAf \hyperlink{map.join}{map.join}}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {rand.float}{\hypertarget{rand.float}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"rand.float":$\!$ [low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc low \rm & float \\  & \PFAc high \rm & float \\  & {\it (returns)} & float \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random float between {\PFAp low} and {\PFAp high}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``high must be greater than low'' error if {\PFAp high} is less than or equal to {\PFAp low}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {*}{\hypertarget{*}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"*":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Multiply {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Float and double overflows do not produce runtime errors but result in positive or negative infinity, which would be carried through any subsequent calculations (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or NaN values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Integer results above or below -2147483648 and 2147483647 (inclusive) produce an ``int overflow'' runtime error. \vspace{0.1 cm} \\ Long-integer results above or below -9223372036854775808 and 9223372036854775807 (inclusive) produce a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.indexall}{\hypertarget{re.indexall}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.indexall":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & array of array of int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & array of array of int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the location indices of every {\PFAp pattern} match in {\PFAp haystack}. \vspace{0.2 cm} \\ }}%
    {time.minuteOfHour}{\hypertarget{time.minuteOfHour}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.minuteOfHour":$\!$ [ts]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the minute of the hour that the timestamp falls within.  Timestamp is assumed to be in UTC. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Timestamp.  \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {map.values}{\hypertarget{map.values}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.values":$\!$ [m]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the values of a map (in no particular order). \vspace{0.2 cm} \\ }}%
    {model.neighbor.mean}{\hypertarget{model.neighbor.mean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.neighbor.mean":$\!$ [points]\} \rm or \PFAc \{"model.neighbor.mean":$\!$ [points, weight]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc points \rm & array of array of double \\ & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc points \rm & array of array of double \\  & \PFAc weight \rm & function (array of double) $\to$ double \\ & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the vector-wise mean of {\PFAp points}, possibly weighted by {\PFAp weight}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc points \rm & Points from a codebook, for instance from {\PFAf \hyperlink{model.neighbor.nearestK}{model.neighbor.nearestK}}.  \\  & \PFAc weight \rm & Optional weighting function from each element of {\PFAp points} to a value.  If these values do not add up to 1.0, they will be internally normalized.  \\  & {\it (return value)} \rm & The vector-wise mean, which is by construction within the convex hull of the {\PFAp points}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp points} is empty, a ``not enough points'' error will be raised. \vspace{0.1 cm} \\ If the {\PFAp points} have different sizes, an ``inconsistent dimensionality'' error will be raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {<=}{\hypertarget{<=}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"<=":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is less than or equal to {\PFAp y}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {m.log}{\hypertarget{m.log}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.log":$\!$ [x, base]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc base \rm & int \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the logarithm of {\PFAp x} with a given {\PFAp base}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is from 0 to infinity (exclusive).  Given zero, the result is negative infinity, and below zero, the result is {\PFAc NaN}, not an exception (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or {\PFAc NaN} values."\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp base} is less than or equal to zero, this function produces a ``base must be positive'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.cluster.closestN}{\hypertarget{model.cluster.closestN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.cluster.closestN":$\!$ [n, datum, clusters, metric]\} \rm or \PFAc \{"model.cluster.closestN":$\!$ [n, datum, clusters]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc n \rm & int \\  & \PFAc datum \rm & array of any {\PFAtp A} \\  & \PFAc clusters \rm & array of any record {\PFAtp C} with \{{\PFApf center:}$\!$ array of any {\PFAtp B}\} \\  & \PFAc metric \rm & function (array of {\PFAtp A}, array of {\PFAtp B}) $\to$ double \\ & {\it (returns)} & array of {\PFAtp C} \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc n \rm & int \\  & \PFAc datum \rm & array of double \\  & \PFAc clusters \rm & array of any record {\PFAtp C} with \{{\PFApf center:}$\!$ array of double\} \\ & {\it (returns)} & array of {\PFAtp C} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Find the {\PFAp n} clusters {\PFAtp C} whose {\PFApf centers} are closest to the {\PFAp datum}, according to the {\PFAp metric}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc n \rm & Number of clusters to search for.  \\  & \PFAc datum \rm & Sample datum.  \\  & \PFAc clusters \rm & Set of clusters; the record type {\PFAtp C} may contain additional identifying information for post-processing.  \\  & \PFAc metric \rm & Function used to compare each {\PFAp datum} with the {\PFApf center} of the {\PFAp clusters}.  (See, for example, {\PFAf \hyperlink{metric.euclidean}{metric.euclidean}}.)  \\  & {\it (return value)} \rm & An array of the closest cluster records in order from the closest to the farthest.  The length of the array is minimum of {\PFAp n} and the length of {\PFAp clusters}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp metric} is not provided, a Euclidean metric over floating point numbers is assumed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp n} is negative, an ``n must be nonnegative'' error will be raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.shuffle}{\hypertarget{a.shuffle}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.shuffle":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array with the same elements as {\PFAp a} but in a random order. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp a} is not changed in-place; this is a side-effect-free function (except for updating the random number generator).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.endswith}{\hypertarget{a.endswith}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.endswith":$\!$ [haystack, needle]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & array of {\PFAtp A} \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & {\PFAtp A} \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if the last (rightmost) subseqence of {\PFAp haystack} is equal to {\PFAp needle}, false otherwise. \vspace{0.2 cm} \\ }}%
    {\%}{\hypertarget{\%}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"\%":$\!$ [k, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc k \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc n \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAp k} modulo {\PFAp n}; the result has the same sign as the modulus {\PFAp n}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This is the behavior of the {\PFAc \%} operator in Python, {\PFAc mod}/{\PFAc modulo} in Ada, Haskell, and Scheme.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.link.cauchit}{\hypertarget{m.link.cauchit}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.cauchit":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the cauchit function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $0.5 + (1/\pi) \tan^{-1}(x_i)$. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {a.rindex}{\hypertarget{a.rindex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.rindex":$\!$ [haystack, needle]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & array of {\PFAtp A} \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & {\PFAtp A} \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & function ({\PFAtp A}) $\to$ boolean \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the highest index where {\PFAp haystack} contains {\PFAp needle} or the {\PFAp needle} function evaluates to {\PFAc true}, $-1$ if there is no such element. \vspace{0.2 cm} \\ }}%
    {prob.dist.negativeBinomialPDF}{\hypertarget{prob.dist.negativeBinomialPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.negativeBinomialPDF":$\!$ [x, size, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc size \rm & int \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the negative binomial distribution parameterized by {\PFAp size} and {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF (integer) .  \\  & \PFAc size \rm & Size parameter (integer).  Target number of successful trials (n).  \\  & \PFAc prob \rm & Probability of success in each trial (p).  \\  & {\it (return value)} \rm & With $size$, $prob$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{\Gamma(x+n)}{\Gamma(n) x!} p^{n} (1-p)^{x}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $\mathrm{prob} < 0$ OR if $\mathrm{prob} > 1$. \vspace{0.1 cm} \\ Raises ``invalid parameterization'' if $size < 0$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.log10}{\hypertarget{m.log10}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.log10":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the logarithm base 10 of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is from 0 to infinity (exclusive).  Given zero, the result is negative infinity, and below zero, the result is {\PFAc NaN}, not an exception (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or {\PFAc NaN} values."\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.replaceall}{\hypertarget{s.replaceall}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.replaceall":$\!$ [s, original, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc original \rm & string \\  & \PFAc replacement \rm & string \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace every instance of the substring {\PFAp original} from {\PFAp s} with {\PFAp replacement}. \vspace{0.2 cm} \\ }}%
    {cast.fanoutDouble}{\hypertarget{cast.fanoutDouble}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.fanoutDouble":$\!$ [x]\} \rm or \PFAc \{"cast.fanoutDouble":$\!$ [x, dictionary, outOfRange]\} \rm or \PFAc \{"cast.fanoutDouble":$\!$ [x, minimum, maximum, outOfRange]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any enum {\PFAtp A} \\ & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\  & \PFAc dictionary \rm & array of string \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc minimum \rm & int \\  & \PFAc maximum \rm & int \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Fanout {\PFAp x} to an array of booleans, all {\PFAc false} except the matching value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Categorical datum  \\  & \PFAc dictionary \rm & Possible values of {\PFAp x}, which is needed if {\PFAp x} is an arbitrary string.  \\  & \PFAc minimum \rm & Inclusive minimum value of {\PFAp x}.  \\  & \PFAc maximum \rm & Excluded maximum value of {\PFAp x}.  \\  & \PFAc outOfRange \rm & If {\PFAc true}, include an extra item in the output to represent values of {\PFAp x} that are outside of the specified range.  \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {time.isSecondOfMinute}{\hypertarget{time.isSecondOfMinute}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isSecondOfMinute":$\!$ [ts, low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc low \rm & double \\  & \PFAc high \rm & double \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Checks if a timestamp falls within a time range, specified in terms of seconds of the minute.  Timestamp is assumed to be in UTC. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Timestamp.  \\  & \PFAc low \rm & Lower boundary of the range.  \\  & \PFAc high \rm & Upper boundary of the range.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``bad time range'' if low $\mathrm{low} \geq \mathrm{high}$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.reg.residual}{\hypertarget{model.reg.residual}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.reg.residual":$\!$ [observation, prediciton]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & double \\  & \PFAc prediciton \rm & double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & array of double \\  & \PFAc prediciton \rm & array of double \\ & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & map of double \\  & \PFAc prediciton \rm & map of double \\ & {\it (returns)} & map of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compare an observation with its prediction by element-wise subtraction. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc observation \rm & Scalar or vector of observations.  \\  & \PFAc prediction \rm & Scalar or vector of predictions.  \\  & {\it (return value)} \rm & Scalar or vector of {\PFAp observation} minus {\PFAp prediction}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``misaligned prediction'' error if {\PFAp prediction} does not have the same indexes as {\PFAp observation}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.reg.updateChi2}{\hypertarget{model.reg.updateChi2}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.reg.updateChi2":$\!$ [pull, state]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pull \rm & double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf chi2:}$\!$ double, {\PFApf DOF:}$\!$ int\} \\ & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pull \rm & array of double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf chi2:}$\!$ double, {\PFApf DOF:}$\!$ int\} \\ & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pull \rm & map of double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf chi2:}$\!$ double, {\PFApf DOF:}$\!$ int\} \\ & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update the state of a chi-square calculation. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc pull \rm & Observation minus prediction divided by uncertainty.  If this is a scalar, it will be squared and added to the chi-square.  If a vector, each component will be squared and added to the chi-square.  \\  & \PFAc state \rm & Record of the previous {\PFApf chi2} and {\PFApf DOF}.  \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {map.split}{\hypertarget{map.split}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.split":$\!$ [m]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & {\it (returns)} & array of map of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Split the map into an array of maps, each containing only one key-value pair. \vspace{0.2 cm} \\ }}%
    {a.max}{\hypertarget{a.max}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.max":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the maximum value in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.uniformPDF}{\hypertarget{prob.dist.uniformPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.uniformPDF":$\!$ [x, min, max]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc min \rm & double \\  & \PFAc max \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the uniform distribution parameterized by {\PFAp min} and {\PFAp max}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc min \rm & Lower bound.  \\  & \PFAc max \rm & Upper bound.  \\  & {\it (return value)} \rm & With $min$, $max$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{1}{\mathrm{max} - \mathrm{min}}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $min \geq max$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {impute.errorOnNull}{\hypertarget{impute.errorOnNull}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"impute.errorOnNull":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & union of \{any {\PFAtp A}, null\} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Skip an action by raising a runtime error when {\PFAp x} is {\PFAc null}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises an ``encountered null'' error if {\PFAp x} is {\PFAc null}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.abs}{\hypertarget{m.abs}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.abs":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the absolute value of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}For exactly one integer value, -2147483648, this function produces an ``int overflow'' runtime error. \vspace{0.1 cm} \\ For exactly one long value, -9223372036854775808, this function produces a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.special.lnBeta}{\hypertarget{m.special.lnBeta}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.special.lnBeta":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & double \\  & \PFAc b \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the beta function parameterized by {\PFAp a} and {\PFAp b}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & With $a$ and $b$, this function evaluates natural logarithm of the beta function. The beta function is $\int_{0}^{1} t^{a - 1}(1 - t)^{b - 1} dt $. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``domain error'' if $a \leq 0$ or if $b \leq 0$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.minNLT}{\hypertarget{a.minNLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.minNLT":$\!$ [a, n, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the {\PFAp n} lowest values in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {parse.double}{\hypertarget{parse.double}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"parse.double":$\!$ [str]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc str \rm & string \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Parse {\PFAp str} and return its value as a double-precision floating point number. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The string is interpreted as though leading and trailing whitespace were removed and is case-insensitive. \vspace{0.1 cm} \\ If the string is ``nan'', the resulting value is not-a-number and if the string is ``inf'', ``+inf'', or ``-inf'', the resulting value is positive infinity, positive infinity, or negative infinity, respectively (see IEEE 754). \vspace{0.1 cm} \\ If the number's magnitude is too large to be represented as a double-precision float, the resulting value is positive or negative infinity (depending on the sign).  If the numbers magnitude is too small to be represented as a double-precision float, the resulting value is zero.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``not a double-precision float'' if the string does not conform to ``{\PFAc [-+]?[0-9]+(e[-+]?[0-9]+)?}''.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {parse.long}{\hypertarget{parse.long}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"parse.long":$\!$ [str, base]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc str \rm & string \\  & \PFAc base \rm & int \\  & {\it (returns)} & long \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Parse {\PFAp str} and return its value as a long integer with base {\PFAp base}, if possible. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The string is interpreted as though leading and trailing whitespace were removed and is case-insensitive.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``not a long integer'' if the string does not conform to ``{\PFAc [-+]?[0-9a-z]+}'' or the number it evaluates to is too large to represent as a 64-bit integer or uses characters as large as or larger than {\PFAp base} ('0' through '9' encode 0 through 9 and 'a' through 'z' encode 10 through 35). \vspace{0.1 cm} \\ Raises ``base out of range'' if {\PFAp base} is less than 2 or greater than 36.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.mapWithIndex}{\hypertarget{a.mapWithIndex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.mapWithIndex":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function (int, {\PFAtp A}) $\to$ any {\PFAtp B} \\  & {\it (returns)} & array of {\PFAtp B} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to index, element pairs from {\PFAp a} and return an array of the results. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.poissonPDF}{\hypertarget{prob.dist.poissonPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.poissonPDF":$\!$ [k, lambda]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc k \rm & int \\  & \PFAc lambda \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the poisson distribution parameterized by {\PFAp lambda}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc lambda \rm & Mean and variance parameter.  \\  & {\it (return value)} \rm & With $lambda$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{\lambda^{x}}{x!} \mathrm{e}^{-\lambda}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $lambda < 0$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.symdiff}{\hypertarget{map.symdiff}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.symdiff":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of {\PFAtp A} \\  & {\it (returns)} & map of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the difference of sets {\PFAp a} and {\PFAp b}, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro. \vspace{0.1 cm} \\ This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.only}{\hypertarget{map.only}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.only":$\!$ [m, keys]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc keys \rm & array of string \\  & {\it (returns)} & map of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new map, keeping only {\PFAp keys} from {\PFAp m}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp m} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ If some {\PFAp keys} are not in {\PFAp m}, they are ignored and do not appear in the return value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.sample.forecastHoltWinters}{\hypertarget{stat.sample.forecastHoltWinters}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.forecastHoltWinters":$\!$ [n, state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc n \rm & int \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf level:}$\!$ double, {\PFApf trend:}$\!$ double\} \\  & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Forecast {\PFAp n} time-steps from a state record prepared by {\PFAf \hyperlink{stat.state.updateHoltWinters}{stat.state.updateHoltWinters}} or {\PFAf \hyperlink{stat.state.updateHoltWintersPeriodic}{stat.state.updateHoltWintersPeriodic}}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc state \rm & Record of {\PFApf level}, {\PFApf trend}, and possibly {\PFApf cycle} and {\PFApf multiplicative}.                                                      \begin{description*}\item[\PFAc level:] The constant term in an exponentially weighted linear fit of recent data. \item[\PFAc trend:] The linear term in an exponentially weighted linear fit of recent data. \item[\PFAc cycle:] The history of the previous cycle.  This field is optional, but if provided, it must be a {\PFAc double} and must be accompanied by {\PFApf multiplicative}. \item[\PFAc multiplicative:] If {\PFAc true}, interpret {\PFApf cycle} as multiplicative; if {\PFAc false}, interpret it as additive.  This field is optional, but if provided, it must be a {\PFAc boolean} and must be accompanied by {\PFApf cycle}. \end{description*} \\  & {\it (return value)} \rm & Returns a series of predictions for the next {\PFAp n} time-steps. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}For $a_t$ = the {\PFApf level} at a time $t$, $b_t$ = the {\PFApf trend} at a time $t$, and $c_t$ = the {\PFApf cycle} at a time $t$ with period $L$, this function returns $a_t + i b_t$ (non-periodic), $(a_t + i b_t) c_{(t + i) \mbox{mod} n}$ (multiplicative), or $a_t + i b_t + c_{(t + i) \mbox{mod} n}$ (additive) for each $i$ from $1$ to $n$\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFApf cycle} is empty, an ``empty cycle'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.hourOfDay}{\hypertarget{time.hourOfDay}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.hourOfDay":$\!$ [ts]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the hour of the day that the timestamp falls within.  Timestamp is assumed to be in UTC. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Timestamp.  \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {bytes.isUtf16}{\hypertarget{bytes.isUtf16}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"bytes.isUtf16":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Returns {\PFAc true} if {\PFAp x} is valid utf-16 (byte order identified by optional byte-order mark); {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {a.init}{\hypertarget{a.init}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.init":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return all but the last item of the array. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {metric.binarySimilarity}{\hypertarget{metric.binarySimilarity}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"metric.binarySimilarity":$\!$ [x, y, c00, c01, c10, c11, d00, d01, d10, d11]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of boolean \\  & \PFAc y \rm & array of boolean \\  & \PFAc c00 \rm & double \\  & \PFAc c01 \rm & double \\  & \PFAc c10 \rm & double \\  & \PFAc c11 \rm & double \\  & \PFAc d00 \rm & double \\  & \PFAc d01 \rm & double \\  & \PFAc d10 \rm & double \\  & \PFAc d11 \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Genaralized similarity of binary vectors, using {\PFAp c00}, {\PFAp c01}, {\PFAp c10}, {\PFAp c11}, {\PFAp d00}, {\PFAp d01}, {\PFAp d10}, and {\PFAp d11} as parameters to reproduce all other binary similarity metrics. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & First sample vector.  \\  & \PFAc y \rm & Second sample vector.  (Must have the same dimension as {\PFAp x}.)  \\  & {\it (return value)} \rm & Where $a_{11}$ is the number of {\PFAp x}, {\PFAp y} coordinate pairs that are equal to {\PFAc true, true}, $a_{10}$ is the number of {\PFAc true, false}, $a_{01}$ is the number of {\PFAc false, true}, and $a_{00}$ is the number of {\PFAc false, false}, this function returns $(c_{11}a_{11} + c_{10}a_{10} + c_{01}a_{01} + c_{00}a_{00})/(d_{11}a_{11} + d_{10}a_{10} + d_{01}a_{01} + d_{00}a_{00})$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``dimensions of vectors do not match'' if {\PFAp x} and {\PFAp y} do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.add}{\hypertarget{map.add}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"map.add":$\!$ [m, key, value]\} \rm or \PFAc \{"map.add":$\!$ [m, item]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc key \rm & string \\  & \PFAc value \rm & {\PFAtp A} \\ & {\it (returns)} & map of {\PFAtp A} \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc item \rm & {\PFAtp A} \\ & {\it (returns)} & map of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new map by adding the {\PFAp key} {\PFAp value} pair to {\PFAp m} or a new set by adding the {\PFAp item} to set {\PFAp m}, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp m} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ If {\PFAp key} is in {\PFAp m}, its value will be replaced. \vspace{0.1 cm} \\ The serialization format for keys of sets is base64-encoded Avro.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.repeat}{\hypertarget{s.repeat}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.repeat":$\!$ [s, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc n \rm & int \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Create a string by concatenating {\PFAp s} with itself {\PFAp n} times. \vspace{0.2 cm} \\ }}%
    {model.reg.linear}{\hypertarget{model.reg.linear}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.reg.linear":$\!$ [datum, model]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc model \rm & any record {\PFAtp M} with \{{\PFApf coeff:}$\!$ array of double, {\PFApf const:}$\!$ double\} \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc model \rm & any record {\PFAtp M} with \{{\PFApf coeff:}$\!$ array of array of double, {\PFApf const:}$\!$ array of double\} \\ & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & map of double \\  & \PFAc model \rm & any record {\PFAtp M} with \{{\PFApf coeff:}$\!$ map of double, {\PFApf const:}$\!$ double\} \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & map of double \\  & \PFAc model \rm & any record {\PFAtp M} with \{{\PFApf coeff:}$\!$ map of map of double, {\PFApf const:}$\!$ map of double\} \\ & {\it (returns)} & map of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply matrix {\PFAp model} to independent variables {\PFAp datum} to predict the dependent, predicted variables. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Vector of independent variables with $d$ dimensions.  \\  & \PFAc model \rm & Parameters of the linear model.                                \begin{description*}\item[\PFAc coeff:] Vector or matrix of coefficients that multiply the input variables, which has $p$ rows and $d$ columns. \item[\PFAc const:] Scalar or vector of constant offsets, which has $p$ dimensions. \end{description*} \\  & {\it (return value)} \rm & Returns a $p$ dimensional vector of dependent, predicted variables. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The vectors and matrix may be expressed as arrays (indexed by integers) or maps (indexed by strings). \vspace{0.1 cm} \\ The simpler signature is may be used in the $p = 1$case.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``misaligned coeff'' error if any row of {\PFApf coeff} does not have the same indexes as {\PFAp datum}. \vspace{0.1 cm} \\ Raises a ``misaligned const'' error if {\PFApf const} does not have the same indexes as {\PFAp datum}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.atan2}{\hypertarget{m.atan2}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.atan2":$\!$ [y, x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc y \rm & double \\  & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the arc-tangent (inverse of the tangent function) of {\PFAp y}/{\PFAp x} without loss of precision for small {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real plane; no pair of inputs is invalid. \vspace{0.1 cm} \\ Note that {\PFAp y} is the first parameter and {\PFAp x} is the second parameter.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.substr}{\hypertarget{s.substr}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.substr":$\!$ [s, start, end]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the substring of {\PFAp s} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.concat}{\hypertarget{a.concat}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.concat":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Concatenate {\PFAp a} and {\PFAp b} to make a new array of the same type. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The length of the returned array is the sum of the lengths of {\PFAp a} and {\PFAp b}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.reduce}{\hypertarget{a.reduce}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.reduce":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and accumulate a tally. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The first parameter of {\PFAp fcn} is the running tally and the second parameter is an element from {\PFAp a}. \vspace{0.1 cm} \\ The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it accumulates from left (beginning) to right (end), called exactly once for each element.  For predictable results, {\PFAp fcn} should be associative.  It need not be commutative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.len}{\hypertarget{s.len}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.len":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the length of string {\PFAp s}. \vspace{0.2 cm} \\ }}%
    {a.subset}{\hypertarget{a.subset}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.subset":$\!$ [little, big]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc little \rm & array of any {\PFAtp A} \\  & \PFAc big \rm & array of {\PFAtp A} \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp little} is a subset of {\PFAp big}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {model.reg.pull}{\hypertarget{model.reg.pull}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.reg.pull":$\!$ [observation, prediciton, uncertainty]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & double \\  & \PFAc prediciton \rm & double \\  & \PFAc uncertainty \rm & double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & array of double \\  & \PFAc prediciton \rm & array of double \\  & \PFAc uncertainty \rm & array of double \\ & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & map of double \\  & \PFAc prediciton \rm & map of double \\  & \PFAc uncertainty \rm & map of double \\ & {\it (returns)} & map of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compare an observation with its prediction by element-wise subtraction, weighted by element-wise uncertainties. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc observation \rm & Scalar or vector of observations.  \\  & \PFAc prediction \rm & Scalar or vector of predictions.  \\  & \PFAc uncertainty \rm & Scalar or vector of predictions.  \\  & {\it (return value)} \rm & Scalar or vector of {\PFAp observation} minus {\PFAp prediction} divided by {\PFAp uncertainty}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``misaligned prediction'' error if {\PFAp prediction} does not have the same indexes as {\PFAp observation}. \vspace{0.1 cm} \\ Raises a ``misaligned uncertainty'' error if {\PFAp prediction} does not have the same indexes as {\PFAp uncertainty}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.diff}{\hypertarget{map.diff}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.diff":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of {\PFAtp A} \\  & {\it (returns)} & map of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the difference of sets {\PFAp a} and {\PFAp b}, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro. \vspace{0.1 cm} \\ This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.diff}{\hypertarget{a.diff}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.diff":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array that represents the difference of {\PFAp a} and {\PFAp b}, treated as sets (ignoring order and duplicates). \vspace{0.2 cm} \\ }}%
    {m.exp}{\hypertarget{m.exp}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.exp":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAf \hyperlink{m.e}{m.e}} raised to the power of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {impute.isnan}{\hypertarget{impute.isnan}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"impute.isnan":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is {\PFAc nan}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {a.argminNLT}{\hypertarget{a.argminNLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argminNLT":$\!$ [a, n, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the indexes of the {\PFAp n} lowest values in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their indexes will be returned in ascending order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.index}{\hypertarget{a.index}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.index":$\!$ [haystack, needle]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & array of {\PFAtp A} \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & {\PFAtp A} \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & function ({\PFAtp A}) $\to$ boolean \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the lowest index where {\PFAp haystack} contains {\PFAp needle} or the {\PFAp needle} function evaluates to {\PFAc true}, $-1$ if there is no such element. \vspace{0.2 cm} \\ }}%
    {time.isWorkHours}{\hypertarget{time.isWorkHours}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isWorkHours":$\!$ [ts]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Returns True if the timestamp falls between 9AM (inclusive) and 5PM (exclusive) on Monday through Friday, otherwise False.  Timestamp is assumed to be in UTC. \vspace{0.2 cm} \\ }}%
    {time.isDayOfMonth}{\hypertarget{time.isDayOfMonth}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isDayOfMonth":$\!$ [ts, low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc low \rm & double \\  & \PFAc high \rm & double \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Checks if a timestamp falls within a time range, specified in terms of days of the month.  Timestamp is assumed to be in UTC. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Timestamp.  \\  & \PFAc low \rm & Lower boundary of the range.  \\  & \PFAc high \rm & Upper boundary of the range.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``bad time range'' if low $\mathrm{low} \geq \mathrm{high}$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.len}{\hypertarget{bytes.len}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.len":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the length of byte array {\PFAp x}. \vspace{0.2 cm} \\ }}%
    {a.maxN}{\hypertarget{a.maxN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.maxN":$\!$ [a, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the {\PFAp n} highest values in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {cast.double}{\hypertarget{cast.double}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.double":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Cast {\PFAp x} to a double-precision floating point number. \vspace{0.2 cm} \\ }}%
    {time.dayOfWeek}{\hypertarget{time.dayOfWeek}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.dayOfWeek":$\!$ [ts]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the day of the week that the timestamp falls within.  Timestamp is assumed to be in UTC.  Monday equals 0, Sunday = 6. \vspace{0.2 cm} \\ }}%
    {time.isMonthOfYear}{\hypertarget{time.isMonthOfYear}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isMonthOfYear":$\!$ [ts, low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc low \rm & double \\  & \PFAc high \rm & double \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Checks if a timestamp falls within a time range, specified in terms of months of the year.  Timestamp is assumed to be in UTC. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Timestamp.  \\  & \PFAc low \rm & Lower boundary of the range.  \\  & \PFAc high \rm & Upper boundary of the range.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``bad time range'' if low $\mathrm{low} \geq \mathrm{high}$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.weibullCDF}{\hypertarget{prob.dist.weibullCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.weibullCDF":$\!$ [x, shape, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc shape \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the weibull distribution parameterized by {\PFAp shape} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc shape \rm & Shape parameter.  \\  & \PFAc scale \rm & Scale parameter.  \\  & {\it (return value)} \rm & With $shape$, $scale$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X~\leq~x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if the $shape \leq 0$ OR if $scale \leq 0$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.distinct}{\hypertarget{a.distinct}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.distinct":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array with the same contents as {\PFAp a} but with duplicates removed. \vspace{0.2 cm} \\ }}%
    {a.sum}{\hypertarget{a.sum}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.sum":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} of \{int, long, float, double\} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the sum of numbers in {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Returns zero if the array is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.cauchyQF}{\hypertarget{prob.dist.cauchyQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.cauchyQF":$\!$ [p, location, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc location \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the cauchy distribution parameterized by {\PFAp location} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc location \rm & Location parameter.  \\  & \PFAc scale \rm & Scale parameter.  \\  & {\it (return value)} \rm & With $location$, $scale$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X \leq x) = p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $scale \leq 0$. \vspace{0.1 cm} \\ Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.number}{\hypertarget{s.number}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"s.number":$\!$ [x]\} \rm or \PFAc \{"s.number":$\!$ [x, width, zeroPad]\} \rm or \PFAc \{"s.number":$\!$ [x, width, precision]\} \rm or \PFAc \{"s.number":$\!$ [x, width, precision, minNoExp, maxNoExp]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\ & {\it (returns)} & string \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc width \rm & int \\  & \PFAc zeroPad \rm & boolean \\ & {\it (returns)} & string \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc width \rm & union of \{int, null\} \\  & \PFAc precision \rm & union of \{int, null\} \\ & {\it (returns)} & string \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc width \rm & union of \{int, null\} \\  & \PFAc precision \rm & union of \{int, null\} \\  & \PFAc minNoExp \rm & double \\  & \PFAc maxNoExp \rm & double \\ & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Format a number as a decimal string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & The number.  Note that different signatures apply to integers and floating point numbers.  \\  & \PFAc width \rm & Width of the string.  If negative, left-justify.  If omitted, the string will be as wide as it needs to be to provide the precision.  \\  & \PFAc zeroPad \rm & If true, pad the integer with zeros to fill up to {\PFAp width}.  \\  & \PFAc precision \rm & Optional precision with which to represent the number.  If omitted, at most six digits after the decimal point will be shown, unless they are zero.  \\  & \PFAc minNoExp \rm & Minimum absolute value that is not presented in scientific notation; 0.0001 if omitted.  \\  & \PFAc maxNoExp \rm & Maxiumum absolute value that is not presented in scientific notation; 100000 if omitted.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the {\PFAp precision} requires more space than {\PFAp width}, the string will be wide enough to accommodate the {\PFAp precision}. \vspace{0.1 cm} \\ Floating point numbers always have a decimal point with at least one digit after the decimal, even if it is zero. \vspace{0.1 cm} \\ Exponents are represented by a lowercase ``e'' which is always followed by a sign, whether positive or negative, and an exponent of two or more digits (single-digit exponents are zero-padded). \vspace{0.1 cm} \\ The base of a number is preceded by a ``-'' if negative, but not a ``+'' if positive. \vspace{0.1 cm} \\ Special floating point values are represented in the following ways: negative zero as zero (no negative sign), not a number as ``nan'', positive infinity as ``inf'', and negative infinity as ``-inf'' (lowercase).  They follow the same precision and width rules as normal numbers, where applicable.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp width} is negative and {\PFAp zeroPad} is {\PFAc true}, a ``negative width cannot be used with zero-padding'' error is raised. \vspace{0.1 cm} \\ If {\PFAp precision} is provided and is less than zero, a ``negative precision'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {rand.int}{\hypertarget{rand.int}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"rand.int":$\!$ []\} \rm or \PFAc \{"rand.int":$\!$ [low, high]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc low \rm & int \\  & \PFAc high \rm & int \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random integer, either on the entire entire 32-bit range or between {\PFAp low} (inclusive) and {\PFAp high} (exclusive). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``high must be greater than low'' error if {\PFAp high} is less than or equal to {\PFAp low}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.any}{\hypertarget{a.any}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.any":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp fcn} is {\PFAc true} for any element in {\PFAp a} (logical or). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The number of {\PFAp fcn} calls is not guaranteed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.substrto}{\hypertarget{s.substrto}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.substrto":$\!$ [s, start, end, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\  & \PFAc replacement \rm & string \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace {\PFAp s} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive) with {\PFAp replacement}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.argmin}{\hypertarget{a.argmin}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argmin":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the index of the minimum value in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the minimum is not unique, this function returns the index of the first minimal value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {impute.defaultOnNull}{\hypertarget{impute.defaultOnNull}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"impute.defaultOnNull":$\!$ [x, default]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & union of \{any {\PFAtp A}, null\} \\  & \PFAc default \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace {\PFAc null} values in {\PFAp x} with {\PFAp default}. \vspace{0.2 cm} \\ }}%
    {s.hex}{\hypertarget{s.hex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"s.hex":$\!$ [x]\} \rm or \PFAc \{"s.hex":$\!$ [x, width, zeroPad]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\ & {\it (returns)} & string \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc width \rm & int \\  & \PFAc zeroPad \rm & boolean \\ & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Format an unsigned number as a hexidecimal string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & The number.  \\  & \PFAc width \rm & Width of the string.  If negative, left-justify.  If omitted, the string will be as wide as it needs to be to provide the precision.  \\  & \PFAc zeroPad \rm & If true, pad the integer with zeros to fill up to {\PFAp width}.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the {\PFAp precision} requires more space than {\PFAp width}, the string will be wide enough to accommodate the {\PFAp precision}. \vspace{0.1 cm} \\ Digits ``a'' (decimal 10) through ``f'' (decimal 15) are represented by lowercase letters.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp width} is negative and {\PFAp zeroPad} is {\PFAc true}, a ``negative width cannot be used with zero-padding'' error is raised. \vspace{0.1 cm} \\ If {\PFAp x} is negative, a ``negative number'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.split}{\hypertarget{re.split}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.split":$\!$ [pattern, haystack]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pattern \rm & string \\  & \PFAc haystack \rm & string \\ & {\it (returns)} & array of string \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pattern \rm & bytes \\  & \PFAc haystack \rm & bytes \\ & {\it (returns)} & array of bytes \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Break {\PFAp haystack} into an array of strings or bytes on the separator defined by {\PFAp pattern}. \vspace{0.2 cm} \\ }}%
    {la.eigenBasis}{\hypertarget{la.eigenBasis}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.eigenBasis":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\ & {\it (returns)} & array of array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\ & {\it (returns)} & map of map of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the eigenvalues and eigenvectors of a real, symmetric matrix {\PFAp x} (which are all real). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & A matrix in which each row (first level of array or map hierarchy) is a normalized eigenvector of {\PFAp x} divided by the square root of the corresponding eigenvalue (The sign is chosen such that the first component is positive.).  If provided as an array, the rows are in decreasing order of eigenvalue (increasing order of inverse square root eigenvalue).  If provided as a map, the rows are keyed by string representations of integers starting with {\PFAc ``0''}, and increasing row keys are in decreasing order of eigenvalue. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp x} is the covariance matrix of a zero-mean dataset, the matrix that this function returns would transform the dataset to one with unit variances and zero covariances. \vspace{0.1 cm} \\ If {\PFAp x} is not symmetric or not exactly symmetric, it will first be symmetrized ($(x + x^T)/2$).  For example, a matrix represented by only the upper triangle (other elements are zero or missing from the map) becomes a symmetric matrix with the upper triangle unchanged.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the matrix has fewer than 1 row or fewer than 1 column, this function raises a ``too few rows/cols'' error. \vspace{0.1 cm} \\ If {\PFAp x} is an array with ragged columns (arrays of different lengths), this function raises a ``ragged columns'' error. \vspace{0.1 cm} \\ If {\PFAp x} is not a square matrix, this function raises a ``non-square matrix'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.permutations}{\hypertarget{a.permutations}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.permutations":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the permutations of {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This function scales rapidly with the length of the array.  For reasonably large arrays, it will result in timeout exceptions.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.join}{\hypertarget{map.join}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.join":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of map of any {\PFAtp A} \\  & {\it (returns)} & map of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Join an array of maps into one map, overlaying from left to right. \vspace{0.2 cm} \\ }}%
    {s.join}{\hypertarget{s.join}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.join":$\!$ [array, sep]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc array \rm & array of string \\  & \PFAc sep \rm & string \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Combine strings from {\PFAp array} into a single string, delimited by {\PFAp sep}. \vspace{0.2 cm} \\ }}%
    {a.slidingWindow}{\hypertarget{a.slidingWindow}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.slidingWindow":$\!$ [a, size, step, allowIncomplete]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc size \rm & int \\  & \PFAc step \rm & int \\  & \PFAc allowIncomplete \rm & boolean \\  & {\it (returns)} & array of array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array of subsequences of {\PFAp a} with length {\PFAp size} that slide through {\PFAp a} in steps of length {\PFAp step} from left to right. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp allowIncomplete} is {\PFAc true}, the last window may be smaller than {\PFAp size}.  If {\PFAc false}, the last window may be skipped.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp size} is non-positive, a ``size < 1'' runtime error is raised. \vspace{0.1 cm} \\ If {\PFAp step} is non-positive, a ``step < 1'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.flatMap}{\hypertarget{a.flatMap}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.flatMap":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ array of any {\PFAtp B} \\  & {\it (returns)} & array of {\PFAtp B} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and flatten the resulting arrays into a single array. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.filterWithIndex}{\hypertarget{a.filterWithIndex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.filterWithIndex":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function (int, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each index, element pair of {\PFAp a} and return an array of the elements for which {\PFAp fcn} returns {\PFAc true}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {<}{\hypertarget{<}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"<":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is less than {\PFAp y}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {m.link.loglog}{\hypertarget{m.link.loglog}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.loglog":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the loglog function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $\exp(-\exp(x_i))$. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {re.groups}{\hypertarget{re.groups}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.groups":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & array of array of int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & array of array of int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the location indices of each {\PFAp pattern} sub-match (group-match) in {\PFAp haystack}. \vspace{0.2 cm} \\ }}%
    {prob.dist.hypergeometricCDF}{\hypertarget{prob.dist.hypergeometricCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.hypergeometricCDF":$\!$ [x, m, n, k]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc m \rm & int \\  & \PFAc n \rm & int \\  & \PFAc k \rm & int \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the hypergeometric distribution parameterized by {\PFAp m}, {\PFAp n} and {\PFAp k}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & The number of white balls drawn without replacement.  \\  & \PFAc m \rm & The number of white balls in the urn.  \\  & \PFAc n \rm & The number of black balls in the urn.  \\  & \PFAc k \rm & The number of balls drawn from the urn.  \\  & {\it (return value)} \rm & With $m$, $n$ and $k$ at $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if the $\mathrm{m} + \mathrm{n} > \mathrm{k}$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.tree.missingTest}{\hypertarget{model.tree.missingTest}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.tree.missingTest":$\!$ [datum, comparison]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & any record {\PFAtp D} \\  & \PFAc comparison \rm & any record {\PFAtp T} with \{{\PFApf field:}$\!$ enum F of fields of D, {\PFApf operator:}$\!$ string, {\PFApf value:}$\!$ any {\PFAtp V}\} \\  & {\it (returns)} & union of \{null, boolean\} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Determine if {\PFAp datum} passes a test defined by {\PFAp comparison}, allowing for missing values. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Sample value to test.  \\  & \PFAc comparison \rm & Record that describes a test.                                           \begin{description*}\item[\PFAc field:] Field name from {\PFAp datum}: the enumeration type must include all fields of {\PFAtp D} in their declaration order. \item[\PFAc operator:] One of the following: ``=='' (equal), ``!='' (not equal), ``<'' (less than), ``<='' (less or equal), ``>'' (greater than), ``>='' (greater or equal), ``in'' (member of a set), ``notIn'' (not a member of a set), ``alwaysTrue'' (ignore {\PFApf value}, return {\PFAc true}), ``alwaysFalse'' (ignore {\PFApf value}, return {\PFAc false}). \item[\PFAc value:] Value to which the field of {\PFAp datum} is compared. \end{description*} \\  & {\it (return value)} \rm & If the field of {\PFAp datum} is {\PFAc null}, this function returns {\PFAc null} (unknown test result).  Otherwise, it returns {\PFAp datum} field <op> {\PFApf value}, where <op> is the {\PFApf operator} \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises an ``invalid comparison operator'' if {\PFApf operator} is not one of ``=='', ``!='', ``<'', ``<='', ``>'', ``>='', ``in'', ``notIn'', ``alwaysTrue'', ``alwaysFalse''. \vspace{0.1 cm} \\ Raises a ``bad value type'' if the {\PFApf field} of {\PFAp datum} and {\PFAtp V} are not both numbers and the {\PFApf field} cannot be upcast to {\PFAtp V}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {la.add}{\hypertarget{la.add}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.add":$\!$ [x, y]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc y \rm & array of double \\ & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc y \rm & array of array of double \\ & {\it (returns)} & array of array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\  & \PFAc y \rm & map of double \\ & {\it (returns)} & map of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc y \rm & map of map of double \\ & {\it (returns)} & map of map of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Add two vectors or matrices {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which elements are computed is not specified, and may be in parallel.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}In the array signature, if any element in {\PFAp x} does not have a corresponding element in {\PFAp y} (or vice-versa), this function raises a ``misaligned matrices'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.monthOfYear}{\hypertarget{time.monthOfYear}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.monthOfYear":$\!$ [ts]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the month that the timestamp falls within.  Timestamp is assumed to be in UTC.  January equals 1, December equals 12. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Timestamp.  \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {time.isNonWorkHours}{\hypertarget{time.isNonWorkHours}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isNonWorkHours":$\!$ [ts]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Returns True if the timestamp falls before 9AM (exclusive) or after 5PM (inclusive) on Monday through Friday, otherwise False.  Also returns false if the timestamp falls at any time on weekend days.  Timestamp is assumed to be in UTC. \vspace{0.2 cm} \\ }}%
    {bytes.encodeLatin1}{\hypertarget{bytes.encodeLatin1}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.encodeLatin1":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & bytes \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Encode a string as latin-1 (ISO-8859-1) bytes. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises an ``invalid string'' error if the string cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.seteq}{\hypertarget{a.seteq}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.seteq":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp a} and {\PFAp b} are equivalent, ignoring order and duplicates, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {a.intersection}{\hypertarget{a.intersection}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.intersection":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array that represents the intersection of {\PFAp a} and {\PFAp b}, treated as sets (ignoring order and duplicates). \vspace{0.2 cm} \\ }}%
    {bytes.decodeLatin1}{\hypertarget{bytes.decodeLatin1}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.decodeLatin1":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Decode a bytes object as a latin-1 (ISO-8859-1) string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises an ``invalid bytes'' error if the bytes cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.reg.linearVariance}{\hypertarget{model.reg.linearVariance}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.reg.linearVariance":$\!$ [datum, model]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc model \rm & any record {\PFAtp M} with \{{\PFApf covar:}$\!$ array of array of double\} \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc model \rm & any record {\PFAtp M} with \{{\PFApf covar:}$\!$ array of array of array of double\} \\ & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & map of double \\  & \PFAc model \rm & any record {\PFAtp M} with \{{\PFApf covar:}$\!$ map of map of double\} \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & map of double \\  & \PFAc model \rm & any record {\PFAtp M} with \{{\PFApf covar:}$\!$ map of map of map of double\} \\ & {\it (returns)} & map of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Propagate variances from {\PFAp model} {\PFApf covar} (covariance matrix) to the dependent, predicted variable(s). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Vector of independent variables $\vec{o}$ with $d$ dimensions.  \\  & \PFAc model \rm & Parameters of the linear model.                     \begin{description*}\item[\PFAc covar:] Covariance matrix $C$ or array/map of covariance matrices, one for each dependent, predicted variable.  Each matrix has $d + 1$ rows and $d + 1$ columns: the last or empty string-key row and column corresponds to the model's constant term.  If there are $p$ dependent, predicted variables, the outermost array/map has $p$ items. \end{description*} \\  & {\it (return value)} \rm & Propagated variance(s) $\vec{o}^T C \vec{o}$ for each dependent, predicted variable. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The ``error'' or ``uncertainty'' in the predicted variable(s) is the square root of this value/these values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``misaligned covariance'' error if any covariance matrix does not have the same indexes as {\PFAp datum} plus the implicit index for a constant (last in array signature, empty string-key in map signature).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.fCDF}{\hypertarget{prob.dist.fCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.fCDF":$\!$ [x, df1, df2]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc df1 \rm & int \\  & \PFAc df2 \rm & int \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the F distribution parameterized by {\PFAp df1} and {\PFAp df2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc df1 \rm & Numerator degrees of freedom parameter.  \\  & \PFAc df2 \rm & Denominator degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $df1$, $df2$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if the $df1 \leq 0$ OR if $df2 \leq 0$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.split}{\hypertarget{s.split}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.split":$\!$ [s, sep]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc sep \rm & string \\  & {\it (returns)} & array of string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Divide a string into an array of substrings, splitting at and removing delimiters {\PFAp sep}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp s} does not contain {\PFAp sep}, this function returns an array whose only element is {\PFAp s}.  If {\PFAp sep} appears at the beginning or end of {\PFAp s}, the array begins with or ends with an empty string.  These conventions match Python's behavior. \end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {test.kolmogorov}{\hypertarget{test.kolmogorov}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"test.kolmogorov":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc y \rm & array of double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compare two datasets using the Kolmogorov-Smirnov test to determine if they might have been drawn from the same parent distribution. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & A bag of data.  \\  & \PFAc y \rm & Another bag of data.  \\  & {\it (return value)} \rm & Returns a value between 0.0 and 1.0 representing the cumulative probability that {\PFAp x} and {\PFAp y} were drawn from the same distribution: 1.0 indicates a perfect match. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If both datasets are empty, this function returns 1.0\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.tree.simpleTest}{\hypertarget{model.tree.simpleTest}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.tree.simpleTest":$\!$ [datum, comparison]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & any record {\PFAtp D} \\  & \PFAc comparison \rm & any record {\PFAtp T} with \{{\PFApf field:}$\!$ enum F of fields of D, {\PFApf operator:}$\!$ string, {\PFApf value:}$\!$ any {\PFAtp V}\} \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Determine if {\PFAp datum} passes a test defined by {\PFAp comparison}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Sample value to test.  \\  & \PFAc comparison \rm & Record that describes a test.                                           \begin{description*}\item[\PFAc field:] Field name from {\PFAp datum}: the enumeration type must include all fields of {\PFAtp D} in their declaration order. \item[\PFAc operator:] One of the following: ``=='' (equal), ``!='' (not equal), ``<'' (less than), ``<='' (less or equal), ``>'' (greater than), ``>='' (greater or equal), ``in'' (member of a set), ``notIn'' (not a member of a set), ``alwaysTrue'' (ignore {\PFApf value}, return {\PFAc true}), ``alwaysFalse'' (ignore {\PFApf value}, return {\PFAc false}), ``isMissing'' (ignore {\PFApf value}, return {\PFAc true} iff the field of {\PFAp datum} is {\PFAc null}), and ``notMissing'' (ignore {\PFApf value}, return {\PFAc false} iff the field of {\PFAp datum} is {\PFAc null}). \item[\PFAc value:] Value to which the field of {\PFAp datum} is compared. \end{description*} \\  & {\it (return value)} \rm & Returns {\PFAc true} if the field of {\PFAp datum} <op> {\PFApf value} is {\PFAc true}, {\PFAc false} otherwise, where <op> is the {\PFApf operator}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises an ``invalid comparison operator'' if {\PFApf operator} is not one of ``=='', ``!='', ``<'', ``<='', ``>'', ``>='', ``in'', ``notIn'', ``alwaysTrue'', ``alwaysFalse'', ``isMissing'', ``notMissing''. \vspace{0.1 cm} \\ Raises a ``bad value type'' if the {\PFApf field} of {\PFAp datum} and {\PFAtp V} are not both numbers and the {\PFApf field} cannot be upcast to {\PFAtp V}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.tPDF}{\hypertarget{prob.dist.tPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.tPDF":$\!$ [x, df]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc df \rm & int \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the student's t distribution parameterized by {\PFAp df} and {\PFAp x2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc df \rm & Degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $df$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{\Gamma(\frac{\mathrm{df}+1}{2})}{\sqrt{\mathrm{df}\pi} \Gamma{\frac{\mathrm{df}}{2}}}(1 + x^{\frac{2}{n}})^{-\frac{\mathrm{df} + 1}{2}}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $df \leq 0$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.all}{\hypertarget{a.all}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.all":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp fcn} is {\PFAc true} for all elements in {\PFAp a} (logical and). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The number of {\PFAp fcn} calls is not guaranteed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {la.det}{\hypertarget{la.det}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.det":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the determinant of a matrix. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the matrix has fewer than 1 row or fewer than 1 column, this function raises a ``too few rows/cols'' error. \vspace{0.1 cm} \\ If {\PFAp x} is an array with ragged columns (arrays of different lengths), this function raises a ``ragged columns'' error. \vspace{0.1 cm} \\ In the array signature, if {\PFAp x} is not a square matrix, this function raises a ``non-square matrix'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {\&}{\hypertarget{\&}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"\&":$\!$ [x, y]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc y \rm & int \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc y \rm & long \\ & {\it (returns)} & long \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Calculate the bitwise-and of {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ }}%
    {map.fromset}{\hypertarget{map.fromset}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.fromset":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & map of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Convert a set of objects into an array of objects, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro. \vspace{0.1 cm} \\ This function does not verify that the serialized objects (keys) and objects (values) match: it considers only values, not keys.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {rand.choices}{\hypertarget{rand.choices}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"rand.choices":$\!$ [size, population]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc size \rm & int \\  & \PFAc population \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array of random items (with replacement) from a bag of items. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``population must not be empty'' error if {\PFAp population} is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.exponentialPDF}{\hypertarget{prob.dist.exponentialPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.exponentialPDF":$\!$ [x, lambda]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc lambda \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the exponential distribution parameterized by {\PFAp lambda}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc lambda \rm & Rate parameter.  \\  & {\it (return value)} \rm & With $lambda$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\lambda \mathrm{e}^{- \lambda x}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $lambda < 0$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.mode}{\hypertarget{a.mode}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.mode":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the mode (most common) value of {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If several different values are equally common, the median of these is returned.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.lstrip}{\hypertarget{s.lstrip}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.lstrip":$\!$ [s, chars]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc chars \rm & string \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Remove any characters found in {\PFAp chars} from the beginning (left) of {\PFAp s}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order of characters in {\PFAp chars} is irrelevant.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {metric.jaccard}{\hypertarget{metric.jaccard}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"metric.jaccard":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of boolean \\  & \PFAc y \rm & array of boolean \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Jaccard similarity of binary vectors. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & First sample vector.  \\  & \PFAc y \rm & Second sample vector.  (Must have the same dimension as {\PFAp x}.)  \\  & {\it (return value)} \rm & Where $a_{11}$ is the number of {\PFAp x}, {\PFAp y} coordinate pairs that are equal to {\PFAc true, true}, $a_{10}$ is the number of {\PFAc true, false}, $a_{01}$ is the number of {\PFAc false, true}, and $a_{00}$ is the number of {\PFAc false, false}, this function returns $a_{11}/(a_{11} + a_{10} + a_{01})$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``dimensions of vectors do not match'' if {\PFAp x} and {\PFAp y} do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {!}{\hypertarget{!}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"!":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & boolean \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is {\PFAc false} and {\PFAc false} if {\PFAp x} is {\PFAc true}. \vspace{0.2 cm} \\ }}%
    {stat.sample.update}{\hypertarget{stat.sample.update}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.update":$\!$ [x, w, state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc w \rm & double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf count:}$\!$ double\} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update the state of a counter, a counter and a mean, or a counter, mean, and variance. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample value.  \\  & \PFAc w \rm & Sample weight; set to 1 for no weights.  \\  & \PFAc state \rm & Record of the previous {\PFApf count}, {\PFApf mean}, and/or {\PFApf variance}.                                           \begin{description*}\item[\PFAc count:] The sum of weights {\PFAp w}. \item[\PFAc mean:] The mean of {\PFAp x}, weighted by {\PFAp w}.  This field is optional, but if provided, it must be a {\PFAc double}. \item[\PFAc variance:] The variance of $x - \mbox{mean}$, weighted by {\PFAp w}.  This field is optional, but if it is provided, it must be a {\PFAc double}, and there must be a {\PFApf mean} as well.  No attempt is made to unbias the estimator, so multiply this by $\mbox{count}/(\mbox{count} - 1)$ to correct for the bias due to centering on the mean. \end{description*} \\  & {\it (return value)} \rm & Returns an updated version of {\PFAp state} with {\PFApf count} incremented by {\PFAp w}, {\PFApf mean} updated to the current mean of all {\PFAp x}, and {\PFApf variance} updated to the current variance of all {\PFAp x}.  If the {\PFAp state} has fields other than {\PFApf count}, {\PFApf mean}, and {\PFApf variance}, they are copied unaltered to the output state. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {prob.dist.geometricCDF}{\hypertarget{prob.dist.geometricCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.geometricCDF":$\!$ [x, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the geometric distribution parameterized by {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc prob \rm & Probability of success of each trial.  \\  & {\it (return value)} \rm & With $prob$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $\mathrm{prob} \leq 0$ OR if $\mathrm{prob} > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.isUtf16be}{\hypertarget{bytes.isUtf16be}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"bytes.isUtf16be":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Returns {\PFAc true} if {\PFAp x} is valid big endian utf-16; {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {prob.dist.chi2PDF}{\hypertarget{prob.dist.chi2PDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.chi2PDF":$\!$ [x, df]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc df \rm & int \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the Chi-squared distribution parameterized by its degrees of freedom {\PFAp df}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc df \rm & Degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $df$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{1}{2^{\frac{\mathrm{df}}{2}} \Gamma(\frac{\mathrm{df}}{2})} x^{\frac{\mathrm{df}}{2}-1}\mathrm{e}^{-\frac{x}{2}}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if {\PFAp df} < 0.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.rindex}{\hypertarget{re.rindex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.rindex":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & array of int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & array of int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the location indices of the last {\PFAp pattern} match in {\PFAp haystack}. \vspace{0.2 cm} \\ }}%
    {prob.dist.gammaCDF}{\hypertarget{prob.dist.gammaCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.gammaCDF":$\!$ [x, shape, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc shape \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the gamma distribution parameterized by {\PFAp shape} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc shape \rm & Shape parameter.  \\  & \PFAc scale \rm & Scale parameter.  \\  & {\it (return value)} \rm & With $shape$, $scale$ and $x$, this function returns the value $p$ where $p = F_{X}(x)~= P(X~\leq~x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if the $shape < 0$ OR if $scale < 0$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {cast.float}{\hypertarget{cast.float}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.float":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\ & {\it (returns)} & float \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\ & {\it (returns)} & float \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & float \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & float \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Cast {\PFAp x} to a single-precision floating point number, rounding if necessary. \vspace{0.2 cm} \\ }}%
    {map.flatMapWithKey}{\hypertarget{map.flatMapWithKey}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.flatMapWithKey":$\!$ [m, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function (string, {\PFAtp A}) $\to$ map of any {\PFAtp B} \\  & {\it (returns)} & map of {\PFAtp B} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each key-value pair of {\PFAp m} and return a map of overlaid results. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on items in {\PFAp m} is not guaranteed, though it will be called exactly once for each value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.containsKey}{\hypertarget{map.containsKey}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"map.containsKey":$\!$ [m, key]\} \rm or \PFAc \{"map.containsKey":$\!$ [m, fcn]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc key \rm & string \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function (string) $\to$ boolean \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if the keys of {\PFAp m} contains {\PFAp key} or {\PFAp fcn} evaluates to {\PFAc true} for some key of {\PFAp m}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {prob.dist.poissonQF}{\hypertarget{prob.dist.poissonQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.poissonQF":$\!$ [p, lambda]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc lambda \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the poisson distribution parameterized by {\PFAp lambda}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc lambda \rm & Mean and variance parameter.  \\  & {\it (return value)} \rm & With $lambda$, $lambda$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X \leq x) = p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $lambda < 0$. \vspace{0.1 cm} \\ Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.tree.surrogateTest}{\hypertarget{model.tree.surrogateTest}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.tree.surrogateTest":$\!$ [datum, comparisons, missingTest]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & any record {\PFAtp D} \\  & \PFAc comparisons \rm & array of any record {\PFAtp T} \\  & \PFAc missingTest \rm & function ({\PFAtp D}, {\PFAtp T}) $\to$ union of \{null, boolean\} \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp missingTest} to an array of {\PFAp comparisons} until one yields a non-null result. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Sample value to test.  \\  & \PFAc comparisons \rm & Records that describe the tests.  \\  & {\it (return value)} \rm & Returns the value of the first test that returns {\PFAc true} or {\PFAc false}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If all tests return {\PFAc null}, this function raises a ``no successful surrogate'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.fPDF}{\hypertarget{prob.dist.fPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.fPDF":$\!$ [x, df1, df2]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc df1 \rm & int \\  & \PFAc df2 \rm & int \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the F distribution parameterized by {\PFAp df1} and {\PFAp df2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc df1 \rm & Numerator degrees of freedom parameter (d1).  \\  & \PFAc df2 \rm & Denominator degrees of freedom parameter (d2).  \\  & {\it (return value)} \rm & With $df1$, $df2$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{\Gamma(\frac{d1 + d2}{2})}{\Gamma(\frac{d1}{2})\Gamma(\frac{d2}{2})} \frac{d1}{d2}^{\frac{d1}{2}-1}(1 + \frac{d1}{d2} x)^{-\frac{d1 + d2}{2}}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if the $df1 \leq 0$ OR if $df2 \leq 0$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.neighbor.ballR}{\hypertarget{model.neighbor.ballR}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.neighbor.ballR":$\!$ [r, datum, codebook, metric]\} \rm or \PFAc \{"model.neighbor.ballR":$\!$ [r, datum, codebook]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc r \rm & double \\  & \PFAc datum \rm & any {\PFAtp A} \\  & \PFAc codebook \rm & array of any {\PFAtp B} \\  & \PFAc metric \rm & function ({\PFAtp A}, {\PFAtp B}) $\to$ double \\ & {\it (returns)} & array of {\PFAtp B} \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc r \rm & double \\  & \PFAc datum \rm & array of double \\  & \PFAc codebook \rm & array of array of double \\ & {\it (returns)} & array of array of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Find the items in {\PFAp codebook} that are within {\PFAp r} of the {\PFAp datum}, according to the {\PFAp metric}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc r \rm & Maximum distance (exclusive) of points to return.  \\  & \PFAc datum \rm & Sample datum.  \\  & \PFAc codebook \rm & Set of training data that is compared to the {\PFAp datum}.  \\  & \PFAc metric \rm & Function used to compare each {\PFAp datum} to each element of the {\PFAp codebook}.  (See, for example, {\PFAf \hyperlink{metric.euclidean}{metric.euclidean}}.)  \\  & {\it (return value)} \rm & An array of the {\PFAp codebook} elements within a distance {\PFAp r} in any order.  The length of the array could be as low as zero or as high as the length of {\PFAp codebook}. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {a.min}{\hypertarget{a.min}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.min":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the minimum value in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.decodeUtf16}{\hypertarget{bytes.decodeUtf16}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.decodeUtf16":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Decode a bytes object as a utf-16 (byte order identified by optional byte-order mark) string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises an ``invalid bytes'' error if the bytes cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {||}{\hypertarget{||}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"||":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & boolean \\  & \PFAc y \rm & boolean \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if either {\PFAp x} or {\PFAp y} (or both) are {\PFAc true}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp x} is {\PFAc true}, {\PFAp y} won't be evaluated.  (Only relevant for arguments with side effects.)\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.union}{\hypertarget{map.union}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.union":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of {\PFAtp A} \\  & {\it (returns)} & map of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the union of sets {\PFAp a} and {\PFAp b}, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro. \vspace{0.1 cm} \\ This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {>=}{\hypertarget{>=}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{">=":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is greater than or equal to {\PFAp y}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {map.update}{\hypertarget{map.update}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.update":$\!$ [base, overlay]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc base \rm & map of any {\PFAtp A} \\  & \PFAc overlay \rm & map of {\PFAtp A} \\  & {\it (returns)} & map of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new map with key-value pairs from {\PFAp overlay} in place of or in addition to key-value pairs from {\PFAp base}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp m} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ Keys of {\PFAp overlay} that are not in {\PFAp base} are added to those in {\PFAp base} and keys of {\PFAp overlay} that are in {\PFAp base} supersede those in {\PFAp base}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.combinations}{\hypertarget{a.combinations}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.combinations":$\!$ [a, size]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc size \rm & int \\  & {\it (returns)} & array of array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the unique combinations of {\PFAp a} with length {\PFAp size}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp size} is non-positive, a ``size < 1'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.reverse}{\hypertarget{a.reverse}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.reverse":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the elements of {\PFAp a} in reversed order. \vspace{0.2 cm} \\ }}%
    {rand.bytes}{\hypertarget{rand.bytes}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"rand.bytes":$\!$ [size]\} \rm or \PFAc \{"rand.bytes":$\!$ [size, population]\} \rm or \PFAc \{"rand.bytes":$\!$ [size, low, high]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc size \rm & int \\ & {\it (returns)} & bytes \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc size \rm & int \\  & \PFAc population \rm & bytes \\ & {\it (returns)} & bytes \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc size \rm & int \\  & \PFAc low \rm & int \\  & \PFAc high \rm & int \\ & {\it (returns)} & bytes \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAp size} random bytes from a range, if provided. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc size \rm & Number of bytes in the result.  \\  & \PFAc population \rm & Bag of bytes to choose from.  Bytes repeated $N$ times in the {\PFAp population} have probability $N$/{\PFAp size}, but order is irrelevant.  \\  & \PFAc low \rm & Minimum byte value to sample (inclusive).  \\  & \PFAc high \rm & Maximum byte value to sample (exclusive).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``size must be positive'' error if {\PFAp size} is less than or equal to zero. \vspace{0.1 cm} \\ Raises a ``high must be greater than low'' error if {\PFAp high} is less than or equal to {\PFAp low}. \vspace{0.1 cm} \\ Raises an ``invalid byte'' error if {\PFAp low} is less than 0 or greater than 255 or if {\PFAp high} is less than 0 or greater than 256.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.atan}{\hypertarget{m.atan}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.atan":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the arc-tangent (inverse of the tangent function) of {\PFAp x} as an angle in radians between $-\pi/2$ and $\pi/2$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.betaQF}{\hypertarget{prob.dist.betaQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.betaQF":$\!$ [p, shape1, shape2]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc shape1 \rm & double \\  & \PFAc shape2 \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the beta distribution parameterized by {\PFAp shape1} and {\PFAp shape2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc shape1 \rm & First shape parameter.  \\  & \PFAc shape2 \rm & Second shape parameter.  \\  & {\it (return value)} \rm & With $shape1$, $shape2$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X \leq x) = p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if the $a \leq 0$ OR if $b \leq 0$. \vspace{0.1 cm} \\ Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {la.inverse}{\hypertarget{la.inverse}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.inverse":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\ & {\it (returns)} & array of array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\ & {\it (returns)} & map of map of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the inverse (or Moore-Penrose pseudoinverse, if not square) of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the matrix has fewer than 1 row or fewer than 1 column, this function raises a ``too few rows/cols'' error. \vspace{0.1 cm} \\ If {\PFAp x} is an array with ragged columns (arrays of different lengths), this function raises a ``ragged columns'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {min}{\hypertarget{min}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"min":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAp x} if {\PFAp x} < {\PFAp y}, {\PFAp y} otherwise. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}For the minimum of more than two values, see {\PFAf \hyperlink{a.min}{a.min}}\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {enum.toString}{\hypertarget{enum.toString}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"enum.toString":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any enum {\PFAtp A} \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the string representation of an enum. \vspace{0.2 cm} \\ }}%
    {prob.dist.gaussianLL}{\hypertarget{prob.dist.gaussianLL}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"prob.dist.gaussianLL":$\!$ [x, mu, sigma]\} \rm or \PFAc \{"prob.dist.gaussianLL":$\!$ [x, params]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc mu \rm & double \\  & \PFAc sigma \rm & double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc params \rm & any record {\PFAtp A} with \{{\PFApf mean:}$\!$ double, {\PFApf variance:}$\!$ double\} \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the log-likelihood of a Gaussian (normal) distribution parameterized by {\PFAp mu} and {\PFAp sigma} or a record {\PFAp params}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the log-likelihood.  \\  & \PFAc mu \rm & Centroid of the distribution (same as {\PFApf mean}).  \\  & \PFAc sigma \rm & Width of the distribution (same as the square root of {\PFApf variance}).  \\  & \PFAc params \rm & Alternate way of specifying the parameters of the distribution; this record could be created by {\PFAf \hyperlink{stat.sample.update}{stat.sample.update}}.  \\  & {\it (return value)} \rm & With $\mu$ = {\PFAp mu} or {\PFApf mean} and $\sigma$ = {\PFAp sigma} or the square root of {\PFApf variance}, this function returns $-(x - \mu)^2/(2 \sigma^2) - \log(\sigma \sqrt{2\pi})$. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {s.replacefirst}{\hypertarget{s.replacefirst}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.replacefirst":$\!$ [s, original, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc original \rm & string \\  & \PFAc replacement \rm & string \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace the first (leftmost) instance of the substring {\PFAp original} from {\PFAp s} with {\PFAp replacement}. \vspace{0.2 cm} \\ }}%
    {prob.dist.betaPDF}{\hypertarget{prob.dist.betaPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.betaPDF":$\!$ [x, shape1, shape2]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc shape1 \rm & double \\  & \PFAc shape2 \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the beta distribution parameterized by {\PFAp shape1} and {\PFAp shape2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF, defined between zero and one.  \\  & \PFAc shape1 \rm & First shape parameter (a).  \\  & \PFAc shape2 \rm & Second shape parameter (b).  \\  & {\it (return value)} \rm & With $shape1$, $shape2$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{\Gamma(a + n)}{\Gamma(a)\Gamma(b)} x^{a-1}(1-x)^{b-1}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $a \leq 0$ OR if $b \leq 0$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.change.updateCUSUM}{\hypertarget{stat.change.updateCUSUM}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.change.updateCUSUM":$\!$ [logLikelihoodRatio, last, reset]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc logLikelihoodRatio \rm & double \\  & \PFAc last \rm & double \\  & \PFAc reset \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update a cumulative sum (CUSUM) to detect the transition of a dataset from one distribution to another. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc logLikelihoodRatio \rm & The logarithm of the ratio of the likelihood of a value for the alterate and baseline distributions: $\ln(\mbox{alt}_{L}/\mbox{base}_{L})$, which is $\mbox{alt}_{LL} - \mbox{base}_{LL}$ where $L$ is likelihood and $LL$ is log-likelihood.  Consider using something like {\PFAc {``-'': [{``prob.dist.gaussianLL'': [...]}, {``prob.dist.gaussianLL'': [...]}]}}.  \\  & \PFAc last \rm & The previous return value from this function.  \\  & \PFAc reset \rm & A low value (usually consistent with the baseline hypothesis, such as 0) at which the cumulative sum resets, rather than accumulate very low values and become insensitive to future changes.  \\  & {\it (return value)} \rm & An incremented cumulative sum.  The output is $\max\{logLikelihoodRatio + last, reset\}$. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {prob.dist.binomialPDF}{\hypertarget{prob.dist.binomialPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.binomialPDF":$\!$ [x, size, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc size \rm & int \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the binomial distribution parameterized by {\PFAp size} and {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc size \rm & The number of trials (n).  \\  & \PFAc prob \rm & The probability of success in each trial (p).  \\  & {\it (return value)} \rm & With $size$, $prob$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\mathrm{choose}(n, x) p^{x} (1 - p)^{n - x}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $size < 0$ OR if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.copysign}{\hypertarget{m.copysign}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.copysign":$\!$ [mag, sign]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc mag \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc sign \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a number with the magnitude of {\PFAp mag} and the sign of {\PFAp sign}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real or integer plane; no pair of inputs is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.subset}{\hypertarget{map.subset}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.subset":$\!$ [little, big]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc little \rm & map of any {\PFAtp A} \\  & \PFAc big \rm & map of {\PFAtp A} \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if set {\PFAp little} is a subset of set {\PFAp big}, {\PFAc false} otherwise, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro. \vspace{0.1 cm} \\ This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.sin}{\hypertarget{m.sin}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.sin":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the trigonometric sine of {\PFAp x}, which is assumed to be in radians. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {|}{\hypertarget{|}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"|":$\!$ [x, y]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc y \rm & int \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc y \rm & long \\ & {\it (returns)} & long \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Calculate the bitwise-or of {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ }}%
    {m.cosh}{\hypertarget{m.cosh}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.cosh":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the hyperbolic cosine of {\PFAp x}, which is equal to $\frac{e^x + e^{-x}}{2}$ \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {la.map}{\hypertarget{la.map}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.map":$\!$ [x, fcn]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc fcn \rm & function (double) $\to$ double \\ & {\it (returns)} & array of array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc fcn \rm & function (double) $\to$ double \\ & {\it (returns)} & map of map of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element from {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This can be used to perform scalar multiplication on a matrix: supply a function that multiplies each element by a constant. \vspace{0.1 cm} \\ The order in which elements are computed is not specified, and may be in parallel.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.pi}{\hypertarget{m.pi}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.pi":$\!$ []\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} The double-precision number that is closer than any other to $\pi$, the ratio of a circumference of a circle to its diameter. \vspace{0.2 cm} \\ }}%
    {re.findgroupsfirst}{\hypertarget{re.findgroupsfirst}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.findgroupsfirst":$\!$ [pattern, haystack]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pattern \rm & string \\  & \PFAc haystack \rm & string \\ & {\it (returns)} & array of string \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pattern \rm & bytes \\  & \PFAc haystack \rm & bytes \\ & {\it (returns)} & array of bytes \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array of strings or bytes for each {\PFAp pattern} sub-match (group-match) at the first occurance of {\PFAp pattern} in {\PFAp haystack}. \vspace{0.2 cm} \\ }}%
    {metric.simpleMatching}{\hypertarget{metric.simpleMatching}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"metric.simpleMatching":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of boolean \\  & \PFAc y \rm & array of boolean \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Simple metric on binary vectors. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & First sample vector.  \\  & \PFAc y \rm & Second sample vector.  (Must have the same dimension as {\PFAp x}.)  \\  & {\it (return value)} \rm & Where $a_{11}$ is the number of {\PFAp x}, {\PFAp y} coordinate pairs that are equal to {\PFAc true, true}, $a_{10}$ is the number of {\PFAc true, false}, $a_{01}$ is the number of {\PFAc false, true}, and $a_{00}$ is the number of {\PFAc false, false}, this function returns $(a_{11} + a_{00})/(a_{11} + a_{10} + a_{01} + a_{00})$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``dimensions of vectors do not match'' if {\PFAp x} and {\PFAp y} do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {cast.signed}{\hypertarget{cast.signed}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"cast.signed":$\!$ [x, bits]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc bits \rm & int \\  & {\it (returns)} & long \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Truncate {\PFAp x} as though its signed long two's complement representation were inserted, bit-for-bit, into a signed two's complement representation that is {\PFAp bits} wide, removing the most significant bits. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The result of this function may be negative, zero, or positive.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp bits} is less than 2 or greater than 64, an ``unrepresentable unsigned number'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.cauchyCDF}{\hypertarget{prob.dist.cauchyCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.cauchyCDF":$\!$ [x, location, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc location \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the cauchy distribution parameterized by {\PFAp location} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc location \rm & Location parameter.  \\  & \PFAc scale \rm & Scale parameter.  \\  & {\it (return value)} \rm & With $location$, $scale$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $scale \leq 0$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {impute.isinf}{\hypertarget{impute.isinf}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"impute.isinf":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is positive or negative infinity, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {cast.fanoutLong}{\hypertarget{cast.fanoutLong}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.fanoutLong":$\!$ [x]\} \rm or \PFAc \{"cast.fanoutLong":$\!$ [x, dictionary, outOfRange]\} \rm or \PFAc \{"cast.fanoutLong":$\!$ [x, minimum, maximum, outOfRange]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any enum {\PFAtp A} \\ & {\it (returns)} & array of long \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\  & \PFAc dictionary \rm & array of string \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of long \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc minimum \rm & int \\  & \PFAc maximum \rm & int \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of long \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Fanout {\PFAp x} to an array of booleans, all {\PFAc false} except the matching value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Categorical datum  \\  & \PFAc dictionary \rm & Possible values of {\PFAp x}, which is needed if {\PFAp x} is an arbitrary string.  \\  & \PFAc minimum \rm & Inclusive minimum value of {\PFAp x}.  \\  & \PFAc maximum \rm & Excluded maximum value of {\PFAp x}.  \\  & \PFAc outOfRange \rm & If {\PFAc true}, include an extra item in the output to represent values of {\PFAp x} that are outside of the specified range.  \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {la.dot}{\hypertarget{la.dot}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.dot":$\!$ [x, y]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc y \rm & array of double \\ & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc y \rm & map of double \\ & {\it (returns)} & map of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc y \rm & array of array of double \\ & {\it (returns)} & array of array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc y \rm & map of map of double \\ & {\it (returns)} & map of map of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Multiply two matrices or a matrix and a vector, which may be represented as dense arrays or potentially sparse maps. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Like most functions that deal with matrices, this function has an array signature and a map signature.  In the array signature, the number of columns of {\PFAp x} must be equal to the number of rows (or the number of elements) of {\PFAp y}.  In the map signature, missing values are assumed to be zero. \vspace{0.1 cm} \\ Matrices supplied as maps may be computed using sparse methods.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}In the array signature, if the dimensions of {\PFAp x} do not correspond to the dimension(s) of {\PFAp y}, this function raises a ``misaligned matrices'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.len}{\hypertarget{a.len}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.len":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the length of array {\PFAp a}. \vspace{0.2 cm} \\ }}%
    {metric.gaussianSimilarity}{\hypertarget{metric.gaussianSimilarity}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"metric.gaussianSimilarity":$\!$ [x, y, sigma]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc y \rm & double \\  & \PFAc sigma \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Similarity function (1-dimensional metric) that returns $\exp(-\ln(2) (x - y)^2 / \mbox{sigma}^2)$. \vspace{0.2 cm} \\ }}%
    {la.trace}{\hypertarget{la.trace}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.trace":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the trace of a matrix (sum of diagonal elements). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp x} is an array with ragged columns (arrays of different lengths), this function raises a ``ragged columns'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.index}{\hypertarget{re.index}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.index":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & array of int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & array of int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the indices in {\PFAp haystack} of the begining and end of the first match defined by {\PFAp pattern}. \vspace{0.2 cm} \\ }}%
    {interp.nearest}{\hypertarget{interp.nearest}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"interp.nearest":$\!$ [x, table]\} \rm or \PFAc \{"interp.nearest":$\!$ [x, table, metric]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ double, {\PFApf to:}$\!$ any {\PFAtp T}\} \\ & {\it (returns)} & {\PFAtp T} \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ array of double, {\PFApf to:}$\!$ any {\PFAtp T}\} \\ & {\it (returns)} & {\PFAtp T} \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp X1} \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ any {\PFAtp X2}, {\PFApf to:}$\!$ any {\PFAtp T}\} \\  & \PFAc metric \rm & function ({\PFAtp X1}, {\PFAtp X2}) $\to$ double \\ & {\it (returns)} & {\PFAtp T} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Finds the closest {\PFApf x} value in the {\PFAp table} to the input {\PFAp x} and returns the corresponding {\PFApf to} value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Any ties in distance are resolved in favor of the first instance in the {\PFAp table}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``table must have at least one entry'' error if {\PFAp table} has fewer than one entry. \vspace{0.1 cm} \\ Raises an ``inconsistent dimensionality'' error if any input {\PFAp x} and record {\PFApf x} have different numbers of dimensions.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.binomialQF}{\hypertarget{prob.dist.binomialQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.binomialQF":$\!$ [p, size, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc size \rm & int \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the binomial distribution parameterized by {\PFAp size} and {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc size \rm & The number of trials.  \\  & \PFAc prob \rm & The probability of success in each trial.  \\  & {\it (return value)} \rm & With $size$, $prob$ and $p$, this function returns the value $x$ such that $F_{X}(x)~:= P(X~\leq~x)~=~p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $size < 0$ OR if $prob < 0$ OR if $prob > 1$. \vspace{0.1 cm} \\ Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.cluster.randomSeeds}{\hypertarget{model.cluster.randomSeeds}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.cluster.randomSeeds":$\!$ [data, k, newCluster]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc data \rm & array of array of any {\PFAtp A} \\  & \PFAc k \rm & int \\  & \PFAc newCluster \rm & function (int, array of {\PFAtp A}) $\to$ any record {\PFAtp C} with \{{\PFApf center:}$\!$ array of any {\PFAtp B}\} \\  & {\it (returns)} & array of {\PFAtp C} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Call {\PFAp newCluster} to create {\PFAp k} cluster records with random, unique cluster centers drawn from {\PFAp data}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc data \rm & Sample data.  \\  & \PFAc k \rm & Number of times to call {\PFAp newCluster}.  \\  & \PFAc newCluster \rm & Function that creates a cluster record, given an index (ranges from zero up to but not including {\PFAp k}) and a random vector from {\PFAp data}.  \\  & {\it (return value)} \rm & The cluster records created by {\PFAp newCluster}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``k must be greater than zero'' error if {\PFAp k} is less than or equal to zero. \vspace{0.1 cm} \\ Raises a ``not enough unique points'' error if {\PFAp data} has fewer than {\PFAp k} unique elements. \vspace{0.1 cm} \\ Raises a ``dimensions of vectors do not match'' error if the elements of {\PFAp data} are not all the same size.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.contains}{\hypertarget{s.contains}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.contains":$\!$ [haystack, needle]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc needle \rm & string \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp haystack} contains {\PFAp needle}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {a.lnsum}{\hypertarget{a.lnsum}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.lnsum":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the sum of the natural logarithm of numbers in {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Returns zero if the array is empty and {\PFAc NaN} if any value in the array is zero or negative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.year}{\hypertarget{time.year}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.year":$\!$ [ts]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the year that the timestamp falls within.  Timestamp is assumed to be in UTC. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Timestamp  \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {prob.dist.uniformQF}{\hypertarget{prob.dist.uniformQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.uniformQF":$\!$ [p, min, max]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc min \rm & double \\  & \PFAc max \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the uniform distribution parameterized by {\PFAp min} and {\PFAp max}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc min \rm & Lower bound.  \\  & \PFAc max \rm & Upper bound.  \\  & {\it (return value)} \rm & With $min$, $max$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X~\leq~x)~=~p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $min \geq max$. \vspace{0.1 cm} \\ Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {impute.defaultOnNonNum}{\hypertarget{impute.defaultOnNonNum}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"impute.defaultOnNonNum":$\!$ [x, default]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\  & \PFAc default \rm & float \\ & {\it (returns)} & float \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc default \rm & double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Pass through {\PFAp x} if it is neither {\PFAc nan} nor infinite, and return {\PFAp default} otherwise. \vspace{0.2 cm} \\ }}%
    {la.truncate}{\hypertarget{la.truncate}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.truncate":$\!$ [x, keep]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc keep \rm & int \\ & {\it (returns)} & array of array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc keep \rm & array of string \\ & {\it (returns)} & map of map of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Remove rows from a matrix so that it becomes a projection operator. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & The matrix to truncate.  \\  & \PFAc keep \rm & If {\PFAp x} is an array, this is the number of rows to keep, starting with the first row.  If {\PFAp x} is a map, this is the set of keys to keep.  If {\PFAp keep} is larger than the number of rows or is not a subset of the keys, the excess is ignored.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}In Principle Component Analysis (PCA), this would be applied to the eigenbasis transformation ({\PFAf \hyperlink{la.eigenBasis}{la.eigenBasis}}) to keep only a specified number (or set) of transformed components.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the matrix has fewer than 1 row or fewer than 1 column, this function raises a ``too few rows/cols'' error. \vspace{0.1 cm} \\ If {\PFAp x} is an array with ragged columns (arrays of different lengths), this function raises a ``ragged columns'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {parse.int}{\hypertarget{parse.int}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"parse.int":$\!$ [str, base]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc str \rm & string \\  & \PFAc base \rm & int \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Parse {\PFAp str} and return its value as an integer with base {\PFAp base}, if possible. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The string is interpreted as though leading and trailing whitespace were removed and is case-insensitive.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``not an integer'' if the string does not conform to ``{\PFAc [-+]?[0-9a-z]+}'' or the number it evaluates to is too large to represent as a 32-bit integer or uses characters as large as or larger than {\PFAp base} ('0' through '9' encode 0 through 9 and 'a' through 'z' encode 10 through 35). \vspace{0.1 cm} \\ Raises ``base out of range'' if {\PFAp base} is less than 2 or greater than 36.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.sample.updateHoltWintersPeriodic}{\hypertarget{stat.sample.updateHoltWintersPeriodic}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.updateHoltWintersPeriodic":$\!$ [x, alpha, beta, gamma, state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc alpha \rm & double \\  & \PFAc beta \rm & double \\  & \PFAc gamma \rm & double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf level:}$\!$ double, {\PFApf trend:}$\!$ double, {\PFApf cycle:}$\!$ array of double, {\PFApf multiplicative:}$\!$ boolean\} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update the state of a time series analysis with an exponentially weighted periodic-plus-linear fit. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample value.  \\  & \PFAc alpha \rm & Weighting factor (usually a constant) between 0 and 1, inclusive, that governs the responsiveness of the {\PFApf level}.  If {\PFAp alpha} is close to 1, recent data are heavily weighted at the expense of old data.  \\  & \PFAc beta \rm & Weighting factor (usually a constant) between 0 and 1, inclusive, that governs the responsiveness of the {\PFApf trend}.  If {\PFAp beta} is close to 1, recent data are heavily weighted at the expense of old data.  \\  & \PFAc gamma \rm & Weighting factor (usually a constant) between 0 and 1, inclusive, that governs the responsiveness of the {\PFApf cycle}.  If {\PFAp gamma} is close to 1, recent data are heavily weighted at the expense of old data.  \\  & \PFAc state \rm & Record of the previous {\PFApf level}, {\PFApf trend}, and {\PFApf cycle}.                                                      \begin{description*}\item[\PFAc level:] The constant term in an exponentially weighted linear fit of recent data, weighted by {\PFAp alpha}. \item[\PFAc trend:] The linear term in an exponentially weighted linear fit of recent data, weighted by {\PFAp beta}. \item[\PFAc cycle:] The history of the previous cycle, weighted by {\PFAp gamma}.  If the length of this array is $L$, then the built-in period is $L$ time steps long. \item[\PFAc multiplicative:] If {\PFAc true}, interpret {\PFApf cycle} as multiplicative; if {\PFAc false}, interpret it as additive. \end{description*} \\  & {\it (return value)} \rm & Returns an updated version of the {\PFAp state}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Use {\PFAf \hyperlink{stat.sample.forecast1HoltWinters}{stat.sample.forecast1HoltWinters}} or {\PFAf \hyperlink{stat.sample.forecastHoltWinters}{stat.sample.forecastHoltWinters}} to make predictions from the state record. \vspace{0.1 cm} \\ For $a_t$ = the {\PFApf level} at a time $t$, $b_t$ = the {\PFApf trend} at a time $t$, and $c_t$ = the {\PFApf cycle} at a time $t$ with period $L$, $a_t = \alpha x_t / c_{t-L} + (1 - \alpha)(a_{t-1} + b_{t-1})$, $b_t = \beta (a_t - a_{t-1}) + (1 - \beta) b_{t-1}$, and $c_t = \gamma x_t / a_t + (1 - \gamma) c_{t-L}$ for the multiplicative case and $a_t = \alpha (x_t - c_{t-L}) + (1 - \alpha)(a_{t-1} + b_{t-1})$, $b_t = \beta (a_t - a_{t-1}) + (1 - \beta) b_{t-1}$, and $c_t = \gamma (x_t - a_t) + (1 - \gamma) c_{t-L}$ for the additive case. \vspace{0.1 cm} \\ In each call to this function, {\PFApf cycle} is rotated left, such that the first item is $c_t$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp alpha} is less than 0 or greater than 1, an ``alpha out of range'' error is raised. \vspace{0.1 cm} \\ If {\PFAp beta} is less than 0 or greater than 1, an ``beta out of range'' error is raised. \vspace{0.1 cm} \\ If {\PFAp gamm} is less than 0 or greater than 1, an ``gamma out of range'' error is raised. \vspace{0.1 cm} \\ If {\PFApf cycle} is empty, an ``empty cycle'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.startswith}{\hypertarget{s.startswith}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.startswith":$\!$ [haystack, needle]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc needle \rm & string \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if the first (leftmost) subseqence of {\PFAp haystack} is equal to {\PFAp needle}, false otherwise. \vspace{0.2 cm} \\ }}%
    {map.in}{\hypertarget{map.in}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.in":$\!$ [s, x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & map of any {\PFAtp A} \\  & \PFAc x \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is contained in set {\PFAp s}, {\PFAc false} otherwise, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro. \vspace{0.1 cm} \\ This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.lognormalPDF}{\hypertarget{prob.dist.lognormalPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.lognormalPDF":$\!$ [x, meanlog, sdlog]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc meanlog \rm & double \\  & \PFAc sdlog \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the lognormal distribution parameterized by {\PFAp meanlog} and {\PFAp sdlog}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc meanlog \rm & Mean of the distribution on the log scale ($\mu$).  \\  & \PFAc sdlog \rm & Standard deviation of the distribution on the log scale ($\sigma$).  \\  & {\it (return value)} \rm & With $meanlog$, $sdlog$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{1}{\sqrt{2 \pi} \sigma x} \mathrm{e}^{-\frac{\mathrm{log}(x) - \mu}{2 \sigma^{2}}}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $sdlog \leq 0$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {la.symmetric}{\hypertarget{la.symmetric}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.symmetric":$\!$ [x, tolerance]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc tolerance \rm & double \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc tolerance \rm & double \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Determine if a matrix is symmetric withing tolerance. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Returns {\PFAc true} if the absolute value of element $i$, $j$ minus element $j$, $i$ is less than {\PFAp tolerance}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the matrix has fewer than 1 row or fewer than 1 column, this function raises a ``too few rows/cols'' error. \vspace{0.1 cm} \\ If {\PFAp x} is an array with ragged columns (arrays of different lengths), this function raises a ``ragged columns'' error. \vspace{0.1 cm} \\ If {\PFAp x} is not a square matrix, this function raises a ``non-square matrix'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {rand.double}{\hypertarget{rand.double}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"rand.double":$\!$ [low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc low \rm & double \\  & \PFAc high \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random double between {\PFAp low} and {\PFAp high}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``high must be greater than low'' error if {\PFAp high} is less than or equal to {\PFAp low}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.filterMap}{\hypertarget{map.filterMap}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.filterMap":$\!$ [m, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ union of \{any {\PFAtp B}, null\} \\  & {\it (returns)} & map of {\PFAtp B} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each value of {\PFAp m} and return a map of the results that are not {\PFAc null}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on items in {\PFAp m} is not guaranteed, though it will be called exactly once for each value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {parse.float}{\hypertarget{parse.float}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"parse.float":$\!$ [str]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc str \rm & string \\  & {\it (returns)} & float \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Parse {\PFAp str} and return its value as a single-precision floating point number. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The string is interpreted as though leading and trailing whitespace were removed and is case-insensitive. \vspace{0.1 cm} \\ If the string is ``nan'', the resulting value is not-a-number and if the string is ``inf'', ``+inf'', or ``-inf'', the resulting value is positive infinity, positive infinity, or negative infinity, respectively (see IEEE 754). \vspace{0.1 cm} \\ If the number's magnitude is too large to be represented as a single-precision float, the resulting value is positive or negative infinity (depending on the sign).  If the numbers magnitude is too small to be represented as a single-precision float, the resulting value is zero.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``not a single-precision float'' if the string does not conform to ``{\PFAc [-+]?[0-9]+(e[-+]?[0-9]+)?}''.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.maxLT}{\hypertarget{a.maxLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.maxLT":$\!$ [a, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the maximum value in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {impute.isnum}{\hypertarget{impute.isnum}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"impute.isnum":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is neither {\PFAc nan} nor infinite, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {model.cluster.closest}{\hypertarget{model.cluster.closest}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.cluster.closest":$\!$ [datum, clusters, metric]\} \rm or \PFAc \{"model.cluster.closest":$\!$ [datum, clusters]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of any {\PFAtp A} \\  & \PFAc clusters \rm & array of any record {\PFAtp C} with \{{\PFApf center:}$\!$ array of any {\PFAtp B}\} \\  & \PFAc metric \rm & function (array of {\PFAtp A}, array of {\PFAtp B}) $\to$ double \\ & {\it (returns)} & {\PFAtp C} \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc clusters \rm & array of any record {\PFAtp C} with \{{\PFApf center:}$\!$ array of double\} \\ & {\it (returns)} & {\PFAtp C} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Find the cluster {\PFAtp C} whose {\PFApf center} is closest to the {\PFAp datum}, according to the {\PFAp metric}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Sample datum.  \\  & \PFAc clusters \rm & Set of clusters; the record type {\PFAtp C} may contain additional identifying information for post-processing.  \\  & \PFAc metric \rm & Function used to compare each {\PFAp datum} with the {\PFApf center} of the {\PFAp clusters}.  (See, for example, {\PFAf \hyperlink{metric.euclidean}{metric.euclidean}}.)  \\  & {\it (return value)} \rm & Returns the closest cluster record. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp metric} is not provided, a Euclidean metric over floating point numbers is assumed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``no clusters'' error if {\PFAp clusters} is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.encodeUtf16be}{\hypertarget{bytes.encodeUtf16be}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.encodeUtf16be":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & bytes \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Encode a string as big endian utf-16 bytes. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises an ``invalid string'' error if the string cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.argmaxNLT}{\hypertarget{a.argmaxNLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argmaxNLT":$\!$ [a, n, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the indexes of the {\PFAp n} highest values in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their indexes will be returned in ascending order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {cast.int}{\hypertarget{cast.int}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.int":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Cast {\PFAp x} to an integer, rounding if necessary. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Results outside of -2147483648 and 2147483647 (inclusive) produce an ``int overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {-}{\hypertarget{-}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"-":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Subtract {\PFAp y} from {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Float and double overflows do not produce runtime errors but result in positive or negative infinity, which would be carried through any subsequent calculations (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or NaN values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Integer results above or below -2147483648 and 2147483647 (inclusive) produce an ``int overflow'' runtime error. \vspace{0.1 cm} \\ Long-integer results above or below -9223372036854775808 and 9223372036854775807 (inclusive) produce a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.isAscii}{\hypertarget{bytes.isAscii}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"bytes.isAscii":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Returns {\PFAc true} if {\PFAp x} is valid ASCII; {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {time.dayOfYear}{\hypertarget{time.dayOfYear}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.dayOfYear":$\!$ [ts]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the day of the year that the timestamp falls within.  Timestamp is assumed to be in UTC. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Timestamp.  \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {cast.fanoutBoolean}{\hypertarget{cast.fanoutBoolean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.fanoutBoolean":$\!$ [x]\} \rm or \PFAc \{"cast.fanoutBoolean":$\!$ [x, dictionary, outOfRange]\} \rm or \PFAc \{"cast.fanoutBoolean":$\!$ [x, minimum, maximum, outOfRange]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any enum {\PFAtp A} \\ & {\it (returns)} & array of boolean \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\  & \PFAc dictionary \rm & array of string \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of boolean \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc minimum \rm & int \\  & \PFAc maximum \rm & int \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Fanout {\PFAp x} to an array of booleans, all {\PFAc false} except the matching value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Categorical datum  \\  & \PFAc dictionary \rm & Possible values of {\PFAp x}, which is needed if {\PFAp x} is an arbitrary string.  \\  & \PFAc minimum \rm & Inclusive minimum value of {\PFAp x}.  \\  & \PFAc maximum \rm & Excluded maximum value of {\PFAp x}.  \\  & \PFAc outOfRange \rm & If {\PFAc true}, include an extra item in the output to represent values of {\PFAp x} that are outside of the specified range.  \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {a.takeWhile}{\hypertarget{a.takeWhile}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.takeWhile":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to elements of {\PFAp a} and create an array of the longest prefix that returns {\PFAc true}, stopping with the first {\PFAc false}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Beyond the prefix, the number of {\PFAp fcn} calls is not guaranteed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.cycle}{\hypertarget{a.cycle}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.cycle":$\!$ [a, item, maxLength]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc item \rm & {\PFAtp A} \\  & \PFAc maxLength \rm & int \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new array by adding {\PFAp item} at the end of {\PFAp a}, but keep the length less than or equal to {\PFAp maxLength} by removing items from the beginning. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp a} is not changed in-place; this is a side-effect-free function.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp maxLength} is less than 0, this function raises a ``maxLength out of range'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.reg.mahalanobis}{\hypertarget{model.reg.mahalanobis}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.reg.mahalanobis":$\!$ [observation, prediction, covariance]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & array of double \\  & \PFAc prediction \rm & array of double \\  & \PFAc covariance \rm & array of array of double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & map of double \\  & \PFAc prediction \rm & map of double \\  & \PFAc covariance \rm & map of map of double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compare an observation with its prediction by computing the Mahalanobis distance for a given covariance matrix. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc observation \rm & Vector of observations $\vec{o}$.  \\  & \PFAc prediction \rm & Vector of predictions $\vec{p}$.  \\  & \PFAc covariance \rm & Matrix of covariance $C$.  \\  & {\it (return value)} \rm & Scalar result of a similarity transformation: $\sqrt{(\vec{o} - \vec{p})^T C^{-1} (\vec{o} - \vec{p})}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``too few rows/cols'' error if {\PFAp observation} has fewer than one element. \vspace{0.1 cm} \\ Raises a ``misaligned prediction'' error if {\PFAp prediction} does not have the same indexes as {\PFAp observation}. \vspace{0.1 cm} \\ Raises a ``misaligned covariance'' error if {\PFAp covariance} does not have the same indexes as {\PFAp observation}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.fQF}{\hypertarget{prob.dist.fQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.fQF":$\!$ [p, df1, df2]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc df1 \rm & int \\  & \PFAc df2 \rm & int \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the F distribution parameterized by {\PFAp df1} and {\PFAp df2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc df1 \rm & Numerator degrees of freedom parameter.  \\  & \PFAc df2 \rm & Denominator degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $df1$, $df2$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X~\leq~x)~=~p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if the $df1 \leq 0$ OR if $df2 \leq 0$. \vspace{0.1 cm} \\ Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.remove}{\hypertarget{map.remove}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.remove":$\!$ [m, key]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc key \rm & string \\  & {\it (returns)} & map of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new map by removing {\PFAp key} from {\PFAp m}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp m} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ If {\PFAp key} is not in {\PFAp m}, the return value is simply {\PFAp m}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {cast.fanoutFloat}{\hypertarget{cast.fanoutFloat}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.fanoutFloat":$\!$ [x]\} \rm or \PFAc \{"cast.fanoutFloat":$\!$ [x, dictionary, outOfRange]\} \rm or \PFAc \{"cast.fanoutFloat":$\!$ [x, minimum, maximum, outOfRange]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any enum {\PFAtp A} \\ & {\it (returns)} & array of float \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\  & \PFAc dictionary \rm & array of string \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of float \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc minimum \rm & int \\  & \PFAc maximum \rm & int \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of float \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Fanout {\PFAp x} to an array of booleans, all {\PFAc false} except the matching value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Categorical datum  \\  & \PFAc dictionary \rm & Possible values of {\PFAp x}, which is needed if {\PFAp x} is an arbitrary string.  \\  & \PFAc minimum \rm & Inclusive minimum value of {\PFAp x}.  \\  & \PFAc maximum \rm & Excluded maximum value of {\PFAp x}.  \\  & \PFAc outOfRange \rm & If {\PFAc true}, include an extra item in the output to represent values of {\PFAp x} that are outside of the specified range.  \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {prob.dist.betaCDF}{\hypertarget{prob.dist.betaCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.betaCDF":$\!$ [x, shape1, shape2]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc shape1 \rm & double \\  & \PFAc shape2 \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the beta distribution parameterized by {\PFAp shape1} and {\PFAp shape2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc shape1 \rm & First shape parameter (a).  \\  & \PFAc shape2 \rm & Second shape parameter (b).  \\  & {\it (return value)} \rm & With $shape1$, $shape2$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $a \leq 0$ OR if $b \leq 0$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.isDayOfWeek}{\hypertarget{time.isDayOfWeek}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isDayOfWeek":$\!$ [ts, low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc low \rm & double \\  & \PFAc high \rm & double \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Checks if a timestamp falls within a time range, specified in terms of days of the week.  Timestamp is assumed to be in UTC. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Timestamp.  \\  & \PFAc low \rm & Lower boundary of the range.  \\  & \PFAc high \rm & Upper boundary of the range.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``bad time range'' if low $\mathrm{low} \geq \mathrm{high}$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.tail}{\hypertarget{a.tail}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.tail":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return all but the first item of the array. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.flatMapWithIndex}{\hypertarget{a.flatMapWithIndex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.flatMapWithIndex":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function (int, {\PFAtp A}) $\to$ array of any {\PFAtp B} \\  & {\it (returns)} & array of {\PFAtp B} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each index, element pair of {\PFAp a} and flatten the resulting arrays into a single array. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.naive.gaussian}{\hypertarget{model.naive.gaussian}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.naive.gaussian":$\!$ [datum, classModel]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc classModel \rm & array of any record {\PFAtp A} with \{{\PFApf mean:}$\!$ double, {\PFApf variance:}$\!$ double\} \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & map of double \\  & \PFAc classModel \rm & map of any record {\PFAtp A} with \{{\PFApf mean:}$\!$ double, {\PFApf variance:}$\!$ double\} \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Score {\PFAp datum} using a Gaussian Naive Bayes model. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm &  Vector of independent variables with $d$ dimensions.   \\  & \PFAc classModel \rm &  Array or map of $d$ records, each containing the {\PFAp mean} and {\PFAp variance} of each of independent variable, for one class.   \\  & {\it (return value)} \rm & Returns the unscaled log-likelihood that {\PFAp datum} is a member of the class specified by {\PFAp classModel}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\PFAp datum} or {\PFAp classModel} may be expressed as arrays (indexed by integers), or maps (indexed by strings).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``datum and classModel have different misaligned'' error if {\PFAp datum} and {\PFAp classModel} have different lengths, of if their keys if using the map signature don't match one to one. \vspace{0.1 cm} \\ Raises a ``variance less than or equal to zero'' error if a variance inside of {\PFAp classModel} is incorrectly specified.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {rand.sample}{\hypertarget{rand.sample}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"rand.sample":$\!$ [size, population]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc size \rm & int \\  & \PFAc population \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array of random items (without replacement) from a bag of items. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``population must not be empty'' error if {\PFAp population} is empty. \vspace{0.1 cm} \\ Raises a ``population smaller than requested subsample'' error if the size of {\PFAp population} is less than {\PFAp size}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.tanh}{\hypertarget{m.tanh}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.tanh":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the hyperbolic tangent of {\PFAp x}, which is equal to $\frac{e^x - e^{-x}}{e^x + e^{-x}}$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.foldRight}{\hypertarget{a.foldRight}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.foldRight":$\!$ [a, zero, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc zero \rm & any {\PFAtp B} \\  & \PFAc fcn \rm & function ({\PFAtp B}, {\PFAtp A}) $\to$ {\PFAtp B} \\  & {\it (returns)} & {\PFAtp B} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and accumulate a tally, starting with {\PFAp zero}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The first parameter of {\PFAp fcn} is an element from {\PFAp a} and the second parameter is the running tally. \vspace{0.1 cm} \\ The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it accumulates from right (end) to left (beginning), called exactly once for each element.  For predictable results, {\PFAp fcn} should be associative with {\PFAp zero} as its identity; that is, {\PFAc fcn(zero, zero) = zero}.  It need not be commutative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.correspondsWithKey}{\hypertarget{map.correspondsWithKey}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.correspondsWithKey":$\!$ [a, b, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of any {\PFAtp B} \\  & \PFAc fcn \rm & function (string, {\PFAtp A}, {\PFAtp B}) $\to$ boolean \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp fcn} is {\PFAc true} when applied to all triples of key, value from {\PFAp a}, value from {\PFAp b} (logical relation). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The number of {\PFAp fcn} calls is not guaranteed. \vspace{0.1 cm} \\ If the key sets of {\PFAp a} and {\PFAp b} are not equal, this function returns {\PFAc false}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.signum}{\hypertarget{m.signum}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.signum":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return 0 if {\PFAp x} is zero, 1 if {\PFAp x} is positive, and -1 if {\PFAp x} is negative. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.filterMap}{\hypertarget{a.filterMap}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.filterMap":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ union of \{any {\PFAtp B}, null\} \\  & {\it (returns)} & array of {\PFAtp B} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and return an array of the results that are not {\PFAc null}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.binomialCDF}{\hypertarget{prob.dist.binomialCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.binomialCDF":$\!$ [x, size, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc size \rm & int \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the binomial distribution parameterized by {\PFAp size} and {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc size \rm & The number of trials.  \\  & \PFAc prob \rm & The probability of success in each trial.  \\  & {\it (return value)} \rm & With $size$, $prob$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $size < 0$ OR if $prob < 0$ OR if $prob > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.subseqto}{\hypertarget{bytes.subseqto}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.subseqto":$\!$ [x, start, end, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\  & \PFAc replacement \rm & bytes \\  & {\it (returns)} & bytes \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace {\PFAp x} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive) with {\PFAp replacement}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.hypot}{\hypertarget{m.hypot}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.hypot":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc y \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return $\sqrt{x^2 + y^2}$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Avoids round-off or overflow errors in the intermediate steps. \vspace{0.1 cm} \\ The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.contains}{\hypertarget{re.contains}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.contains":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return true if {\PFAp pattern} matches anywhere within {\PFAp haystack}, otherwise return false. \vspace{0.2 cm} \\ }}%
    {s.concat}{\hypertarget{s.concat}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.concat":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\  & \PFAc y \rm & string \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Append {\PFAp y} to {\PFAp x} to form a single string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}To concatenate an array of strings, use s.join with an empty string as {\PFAp sep}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {max}{\hypertarget{max}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"max":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAp x} if {\PFAp x} $\geq$ {\PFAp y}, {\PFAp y} otherwise. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}For the maximum of more than two values, see {\PFAf \hyperlink{a.max}{a.max}}\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.sample.fillHistogram2d}{\hypertarget{stat.sample.fillHistogram2d}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.fillHistogram2d":$\!$ [x, y, w, histogram]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc y \rm & double \\  & \PFAc w \rm & double \\  & \PFAc histogram \rm & any record {\PFAtp A} with \{{\PFApf xnumbins:}$\!$ int, {\PFApf xlow:}$\!$ double, {\PFApf xhigh:}$\!$ double, {\PFApf ynumbins:}$\!$ int, {\PFApf ylow:}$\!$ double, {\PFApf yhigh:}$\!$ double, {\PFApf values:}$\!$ array of array of double\} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update a two-dimensional histogram by filling it with one value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample x value.  \\  & \PFAc y \rm & Sample y value.  \\  & \PFAc w \rm & Sample weight; set to 1 for no weights.  \\  & \PFAc histogram \rm & The histogram prior to filling.                                                                                                                                                                 \begin{description*}\item[\PFAc xnumbins:] The number of bins in the x dimension. \item[\PFAc xlow:] The low edge of the histogram range in the x dimension (inclusive). \item[\PFAc xhigh:] The high edge of the histogram range in the x dimension (exclusive). \item[\PFAc ynumbins:] The number of bins in the y dimension. \item[\PFAc ylow:] The low edge of the histogram range in the y dimension (inclusive). \item[\PFAc yhigh:] The high edge of the histogram range in the y dimension (exclusive). \item[\PFAc values:] Histogram contents, which are updated by this function.  The outer array iterates over {\PFAp x} and the inner array iterates over {\PFAp y}. \item[\PFAc underunderflow:] If present, this double-valued field counts instances in which {\PFAp x} is less than {\PFApf xlow} and {\PFAp y} is less than {\PFApf ylow}. \item[\PFAc undermidflow:] If present, this double-valued field counts instances in which {\PFAp x} is less than {\PFApf xlow} and {\PFAp y} between {\PFApf ylow} (inclusive) and {\PFApf yhigh} (exclusive). \item[\PFAc underoverflow:] If present, this double-valued field counts instances in which {\PFAp x} is less than {\PFApf xlow} and {\PFAp y} is greater than or equal to {\PFApf yhigh}. \item[\PFAc midunderflow:] If present, this double-valued field counts instances in which {\PFAp x} is between {\PFApf xlow} (inclusive) and {\PFApf xhigh} (exclusive) and {\PFAp y} is less than {\PFApf ylow}. \item[\PFAc midoverflow:] If present, this double-valued field counts instances in which {\PFAp x} is between {\PFApf xlow} (inclusive) and {\PFApf xhigh} (exclusive) and {\PFAp y} is greater than or equal to {\PFApf yhigh}. \item[\PFAc overunderflow:] If present, this double-valued field counts instances in which {\PFAp x} is greater than or equal to {\PFApf xhigh} and {\PFAp y} is less than {\PFApf ylow}. \item[\PFAc overmidflow:] If present, this double-valued field counts instances in which {\PFAp x} is greater than or equal to {\PFApf xhigh} and {\PFAp y} between {\PFApf ylow} (inclusive) and {\PFApf yhigh} (exclusive). \item[\PFAc overoverflow:] If present, this double-valued field counts instances in which {\PFAp x} is greater than or equal to {\PFApf xhigh} and {\PFAp y} is greater than or equal to {\PFApf yhigh}. \item[\PFAc nanflow:] If present, this double-valued field counts instances in which {\PFAp x} or {\PFAp y} is {\PFAc nan}.  {\PFAc nan} values would never enter any other counter. \item[\PFAc infflow:] If present, this double-valued field counts instances in which {\PFAp x} or {\PFAp y} is infinite.  Infinite values would only enter the other under/mid/overflow counters if {\PFApf infflow} were not present, so that they are not double-counted. \end{description*} \\  & {\it (return value)} \rm & Returns an updated version of {\PFAp histogram}: all fields are unchanged except for {\PFApf values} and the under/mid/over/nan/infflow counters. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp x} is infinite and {\PFAp y} is {\PFAc nan} or {\PFAp x} is {\PFAc nan} and {\PFAp y} is infinite, the entry is counted as {\PFAc nan}, rather than infinite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the length of {\PFApf values} is not equal to {\PFApf xnumbins} or the length of any element of {\PFApf values} is not equal to {\PFApf ynumbins}, then a ``wrong histogram size'' error is raised. \vspace{0.1 cm} \\ If {\PFApf xlow} is greater than or equal to {\PFApf xhigh} or if {\PFApf ylow} is greater than or equal to {\PFApf yhigh}, then a ``bad histogram range'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.fromUTCToLocal}{\hypertarget{time.fromUTCToLocal}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.fromUTCToLocal":$\!$ [ts, offset]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc offset \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Converts a timestamp specified in the local time via an offset from UTC to UTC. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Timestamp in UTC.  \\  & \PFAc offset \rm & The UTC offset in the local time.  \\  & {\it (return value)} \rm & A timestamp in the local time. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {a.replace}{\hypertarget{a.replace}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.replace":$\!$ [a, index, item]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc index \rm & int \\  & \PFAc item \rm & {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new array by replacing {\PFAp index} of {\PFAp a} with {\PFAp item}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), following Python's index behavior. \vspace{0.1 cm} \\ Note: {\PFAp a} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ The length of the returned array is equal to that of {\PFAp a}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp index} is beyond the range of {\PFAp a}, an ``array out of range'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.replacefirst}{\hypertarget{re.replacefirst}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.replacefirst":$\!$ [pattern, haystack, replacement]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pattern \rm & string \\  & \PFAc haystack \rm & string \\  & \PFAc replacement \rm & string \\ & {\it (returns)} & string \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pattern \rm & bytes \\  & \PFAc haystack \rm & bytes \\  & \PFAc replacement \rm & bytes \\ & {\it (returns)} & bytes \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace the first {\PFAp pattern} match in {\PFAp haystack} with {\PFAp replacement}. \vspace{0.2 cm} \\ }}%
    {bytes.decodeUtf16le}{\hypertarget{bytes.decodeUtf16le}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.decodeUtf16le":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Decode a bytes object as a little endian utf-16 string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises an ``invalid bytes'' error if the bytes cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.tCDF}{\hypertarget{prob.dist.tCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.tCDF":$\!$ [x, df]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc df \rm & int \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the student's t distribution parameterized by {\PFAp df} and {\PFAp x2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc df \rm & Degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $df$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $df \leq 0$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.tan}{\hypertarget{m.tan}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.tan":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the trigonometric tangent of {\PFAp x}, which is assumed to be in radians. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.makeTimestamp}{\hypertarget{time.makeTimestamp}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.makeTimestamp":$\!$ [year, month, day, hour, minute, second, millisecond]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc year \rm & int \\  & \PFAc month \rm & int \\  & \PFAc day \rm & int \\  & \PFAc hour \rm & int \\  & \PFAc minute \rm & int \\  & \PFAc second \rm & int \\  & \PFAc millisecond \rm & int \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Given the date and time in UTC that this time occurs in, return the timestamp in UTC of this date and time. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc year \rm & The year, e.g. 2015.  \\  & \PFAc month \rm & The month of the year.  \\  & \PFAc day \rm & The day of the month.  \\  & \PFAc hour \rm & The hour of the day.  \\  & \PFAc minute \rm & The minute of the hour.  \\  & \PFAc second \rm & The second of the minute.  \\  & \PFAc millisecond \rm & The millisecond of the second.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``timestamp undefined for given parameters'' if any one (or more) of the inputs have impossible values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.remove}{\hypertarget{a.remove}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.remove":$\!$ [a, start, end]\} \rm or \PFAc \{"a.remove":$\!$ [a, index]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\ & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc index \rm & int \\ & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new array by removing elements from {\PFAp a} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive) or just a single {\PFAp index}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior. \vspace{0.1 cm} \\ Note: {\PFAp a} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ The length of the returned array is one less than {\PFAp a}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp index} is beyond the range of {\PFAp a}, an ``array out of range'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.replacelast}{\hypertarget{re.replacelast}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.replacelast":$\!$ [pattern, haystack, replacement]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pattern \rm & string \\  & \PFAc haystack \rm & string \\  & \PFAc replacement \rm & string \\ & {\it (returns)} & string \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pattern \rm & bytes \\  & \PFAc haystack \rm & bytes \\  & \PFAc replacement \rm & bytes \\ & {\it (returns)} & bytes \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace the last {\PFAp pattern} match in {\PFAp haystack} with {\PFAp replacement}. \vspace{0.2 cm} \\ }}%
    {map.filter}{\hypertarget{map.filter}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.filter":$\!$ [m, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & map of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each value of {\PFAp m} and return a map of the values for which {\PFAp fcn} returns {\PFAc true} (keys are unchanged). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on items in {\PFAp m} is not guaranteed, though it will be called exactly once for each value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.groupby}{\hypertarget{a.groupby}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.groupby":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ string \\  & {\it (returns)} & map of array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Groups elements of {\PFAp a} by the string that {\PFAp fcn} maps them to. \vspace{0.2 cm} \\ }}%
    {stat.sample.updateCovariance}{\hypertarget{stat.sample.updateCovariance}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"stat.sample.updateCovariance":$\!$ [x, w, state]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc w \rm & double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf count:}$\!$ double, {\PFApf mean:}$\!$ array of double, {\PFApf covariance:}$\!$ array of array of double\} \\ & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\  & \PFAc w \rm & double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf count:}$\!$ map of map of double, {\PFApf mean:}$\!$ map of double, {\PFApf covariance:}$\!$ map of map of double\} \\ & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update the state of a covariance calculation. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample vector, expressed as an array or map; must have at least two components.  \\  & \PFAc w \rm & Sample weight; set to 1 for no weights.  \\  & \PFAc state \rm & Record of the previous {\PFApf count}, {\PFApf mean}, and {\PFApf covariance}.                                           \begin{description*}\item[\PFAc count:] The sum of weights {\PFAp w}.  If {\PFAp x} is an array, then {\PFApf count} is a single value representing the sum of weights for all records seen so far.  If {\PFAp x} is a map, then {\PFApf count} is a matrix in which entry $i$, $j$ is the sum of weights for records in which key $i$ and key $j$ both appear in {\PFAp x}. \item[\PFAc mean:] The componentwise mean of {\PFAp x}, weighted by {\PFAp w}. \item[\PFAc covariance:] The covariance matrix of all pairs of components of {\PFAp x}, weighted by {\PFAp w}.  If {\PFAp x} is an array, this matrix is represented by a list of lists.  If {\PFAp x} is a map, this matrix is represented by a map of maps. \end{description*} \\  & {\it (return value)} \rm & Returns an updated version of {\PFAp state} with {\PFApf count} incremented by {\PFAp w}, {\PFApf mean} updated to the current componentwise mean of all {\PFAp x}, and {\PFApf covariance} updated to the current covariance matrix of all {\PFAp x}.  If the {\PFAp state} has fields other than {\PFApf count}, {\PFApf mean}, and {\PFApf covariance}, they are copied unaltered to the output state. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Like most functions that deal with matrices, this function has an array signature and a map signature.  In the array signature, indexes of {\PFAp x} correspond to the same indexes of {\PFApf mean} and rows and columns of {\PFApf covariance}, where a row is an index of {\PFApf covariance} and a column is an index of an element of {\PFApf covariance}.  In the map signature, keys of {\PFAp x} correspond to the same keys of {\PFApf mean}, as well as rows and columns of {\PFApf count} and {\PFApf covariance}, where a row is a key of the object and a column is a key of a value of the object.  In the array signature, all arrays must have equal length (including the nested arrays within {\PFApf covariance}) and all components are updated with each call.  In the map signature, a previously unseen key in {\PFAp x} creates a new key in {\PFApf mean} with value {\PFAp x}, a new row and column in {\PFApf count} with value {\PFAp w} for all key pairs existing in {\PFAp x} and zero for key pairs not in {\PFAp x}, as well as a new row and column in {\PFApf covariance} filled with zeros. \vspace{0.1 cm} \\ In the map signature, missing keys in {\PFAp x} are equivalent to contributions with zero weight.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp state} is {\PFAc null} and the record type has fields other than {\PFApf count}, {\PFApf mean}, and {\PFApf covariance}, then a ``cannot initialize unrecognized fields'' error is raised.  Unrecognized fields are only allowed if an initial record is provided. \vspace{0.1 cm} \\ If {\PFAp x} has fewer than 2 components, a ``too few components'' error is raised. \vspace{0.1 cm} \\ If {\PFAp x}, {\PFApf mean}, and {\PFApf covariance} are arrays with unequal lengths, an ``unequal length arrays'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.hypergeometricPDF}{\hypertarget{prob.dist.hypergeometricPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.hypergeometricPDF":$\!$ [x, m, n, k]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc m \rm & int \\  & \PFAc n \rm & int \\  & \PFAc k \rm & int \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the hypergeometric distribution parameterized by {\PFAp m}, {\PFAp n} and {\PFAp k}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & The number of white balls drawn without replacement from the urn.  \\  & \PFAc m \rm & The number of white balls in the urn.  \\  & \PFAc n \rm & The number of black balls in the urn.  \\  & \PFAc k \rm & The number of balls drawn from the urn.  \\  & {\it (return value)} \rm & With $m$, $n$ and $k$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{\mathrm{choose}(m, x) \mathrm{choose}(n, k-x)}{\mathrm{choose}(m+n, k)} $.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if the $\mathrm{m} + \mathrm{n} > \mathrm{k}$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.contains}{\hypertarget{a.contains}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.contains":$\!$ [haystack, needle]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & array of {\PFAtp A} \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & {\PFAtp A} \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & function ({\PFAtp A}) $\to$ boolean \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp haystack} contains {\PFAp needle} or the {\PFAp needle} function evaluates to {\PFAc true}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {**}{\hypertarget{**}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"**":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Raise {\PFAp x} to the power {\PFAp n}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Float and double overflows do not produce runtime errors but result in positive or negative infinity, which would be carried through any subsequent calculations (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or NaN values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Integer results above or below -2147483648 and 2147483647 (inclusive) produce an ``int overflow'' runtime error. \vspace{0.1 cm} \\ Long-integer results above or below -9223372036854775808 and 9223372036854775807 (inclusive) produce a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.encodeUtf16le}{\hypertarget{bytes.encodeUtf16le}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.encodeUtf16le":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & bytes \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Encode a string as little endian utf-16 bytes. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises an ``invalid string'' error if the string cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.negativeBinomialQF}{\hypertarget{prob.dist.negativeBinomialQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.negativeBinomialQF":$\!$ [p, size, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc size \rm & int \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the negative binomial distribution parameterized by {\PFAp size} and {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc size \rm & Size parameter (integer).  Target number of successful trials.  \\  & \PFAc prob \rm & Probability of success in each trial.  \\  & {\it (return value)} \rm & With $size$, $prob$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X \leq x) = p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $\mathrm{prob} < 0$ OR if $\mathrm{prob} > 1$. \vspace{0.1 cm} \\ Raises ``invalid parameterization'' if $size \leq 0$ OR if $size$ is not an integer. \vspace{0.1 cm} \\ Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.gammaPDF}{\hypertarget{prob.dist.gammaPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.gammaPDF":$\!$ [x, shape, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc shape \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the gamma distribution parameterized by {\PFAp shape} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc shape \rm & Shape parameter (a).  \\  & \PFAc scale \rm & Scale parameter (s).  \\  & {\it (return value)} \rm & With $shape$, $scale$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{1}{s^{a} \Gamma(a)} x^{a - 1} \mathrm{e}^{-\frac{x}{s}}  $. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if the $shape < 0$ OR if $scale < 0$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {==}{\hypertarget{==}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"==":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is equal to {\PFAp y}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {prob.dist.lognormalCDF}{\hypertarget{prob.dist.lognormalCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.lognormalCDF":$\!$ [x, meanlog, sdlog]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc meanlog \rm & double \\  & \PFAc sdlog \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the lognormal distribution parameterized by {\PFAp meanlog} and {\PFAp sdlog}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc meanlog \rm & Mean of the distribution on the log scale.  \\  & \PFAc sdlog \rm & Standard deviation of the distribution on the log scale.  \\  & {\it (return value)} \rm & With $meanlog$, $sdlog$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $sdlog \leq 0$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.index}{\hypertarget{s.index}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.index":$\!$ [haystack, needle]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc needle \rm & string \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the lowest index where {\PFAp haystack} contains {\PFAp needle} or -1 if {\PFAp haystack} does not contain {\PFAp needle}. \vspace{0.2 cm} \\ }}%
    {map.containsValue}{\hypertarget{map.containsValue}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"map.containsValue":$\!$ [m, value]\} \rm or \PFAc \{"map.containsValue":$\!$ [m, fcn]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc value \rm & {\PFAtp A} \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if the values of {\PFAp m} contains {\PFAp value} or {\PFAp fcn} evaluates to {\PFAc true} for some key of {\PFAp m}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {model.reg.reducedChi2}{\hypertarget{model.reg.reducedChi2}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.reg.reducedChi2":$\!$ [state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf chi2:}$\!$ double, {\PFApf DOF:}$\!$ int\} \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the reduced chi-square, which is {\PFApf chi2}/{\PFApf DOF}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc state \rm & Record of the {\PFApf chi2} and {\PFApf DOF}.  \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {cast.fanoutInt}{\hypertarget{cast.fanoutInt}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.fanoutInt":$\!$ [x]\} \rm or \PFAc \{"cast.fanoutInt":$\!$ [x, dictionary, outOfRange]\} \rm or \PFAc \{"cast.fanoutInt":$\!$ [x, minimum, maximum, outOfRange]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any enum {\PFAtp A} \\ & {\it (returns)} & array of int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\  & \PFAc dictionary \rm & array of string \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc minimum \rm & int \\  & \PFAc maximum \rm & int \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Fanout {\PFAp x} to an array of booleans, all {\PFAc false} except the matching value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Categorical datum  \\  & \PFAc dictionary \rm & Possible values of {\PFAp x}, which is needed if {\PFAp x} is an arbitrary string.  \\  & \PFAc minimum \rm & Inclusive minimum value of {\PFAp x}.  \\  & \PFAc maximum \rm & Excluded maximum value of {\PFAp x}.  \\  & \PFAc outOfRange \rm & If {\PFAc true}, include an extra item in the output to represent values of {\PFAp x} that are outside of the specified range.  \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {metric.minkowski}{\hypertarget{metric.minkowski}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"metric.minkowski":$\!$ [similarity, x, y, p]\} \rm or \PFAc \{"metric.minkowski":$\!$ [similarity, x, y, p, missingWeight]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (double, double) $\to$ double \\  & \PFAc x \rm & array of union of \{null, double\} \\  & \PFAc y \rm & array of union of \{null, double\} \\  & \PFAc p \rm & double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (double, double) $\to$ double \\  & \PFAc x \rm & array of union of \{null, double\} \\  & \PFAc y \rm & array of union of \{null, double\} \\  & \PFAc p \rm & double \\  & \PFAc missingWeight \rm & array of double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Minkowski metric, also known as the p-norm, a generalized norm whose limits include Euclidean, Chebyshev, and Taxicab. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc similarity \rm & Similarity function (1-dimensional metric) that quantifies the distance between components of {\PFAp x} and components of {\PFAp y}.  \\  & \PFAc x \rm & First sample vector, which may have missing values.  \\  & \PFAc y \rm & Second sample vector, which may have missing values.  (Must have the same dimension as {\PFAp x}.)  \\  & \PFAc missingWeight \rm & Optional missing-value weights: a vector with the same dimension as {\PFAp x} and {\PFAp y} that determines the normalized contribution of missing values in the sum.  If not provided, missing-value weights of 1.0 are assumed.  \\  & {\it (return value)} \rm & With $I(x_i,y_i)$ = 0 if component $i$ of {\PFAp x} or {\PFAp y} is missing, 1 otherwise, this function returns $((\sum_i I(x_i,y_i) \mbox{similarity}(x_i,y_i)^p)(\sum_i q_i)/(\sum_i I(x_i,y_i) q_i))^{1/p}$ where $q_i$ are components of the missing-value weights.  Without missing values, it is $(\sum_i \mbox{similarity}(x_i,y_i)^p)^{1/p}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``dimensions of vectors do not match'' if all vectors do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {interp.linearFlat}{\hypertarget{interp.linearFlat}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"interp.linearFlat":$\!$ [x, table]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ double, {\PFApf to:}$\!$ double\} \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ double, {\PFApf to:}$\!$ array of double\} \\ & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Like {\PFAf \hyperlink{interp.linear}{interp.linear}}, but returns the closest entry's {\PFApf to} if the input {\PFAp x} is beyond the {\PFAp table}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Any ties in distance are resolved in favor of the first instance in the {\PFAp table}. \vspace{0.1 cm} \\ If the {\PFApf to} values are arrays, each component will be interpolated.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``table must have at least two entries'' error if {\PFAp table} has fewer than two entries. \vspace{0.1 cm} \\ Raises an ``inconsistent dimensionality'' error if the {\PFApf to} values of the two closest entries have different numbers of dimensions.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.special.nChooseK}{\hypertarget{m.special.nChooseK}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.special.nChooseK":$\!$ [n, k]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc n \rm & int \\  & \PFAc k \rm & int \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:}  The number of ways to choose {\PFAp k} elements from a set of {\PFAp n} elements. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc n \rm & Total number of elements.  \\  & \PFAc k \rm & Numer of elements chosen.  \\  & {\it (return value)} \rm & With $n$ and $k$, this function evaluates the binomial coefficient. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``domain error'' if $k \leq 0$ and $n \leq k$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.weibullQF}{\hypertarget{prob.dist.weibullQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.weibullQF":$\!$ [p, shape, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc shape \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the weibull distribution parameterized by {\PFAp shape} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc shape \rm & Shape parameter.  \\  & \PFAc scale \rm & Scale parameter.  \\  & {\it (return value)} \rm & With $shape$, $scale$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X~\leq~x)~=~p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if the $shape \leq 0$ OR if $scale \leq 0$. \vspace{0.1 cm} \\ Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.logsumexp}{\hypertarget{a.logsumexp}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.logsumexp":$\!$ [datum]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:}  Compute $z = \\sum_{n = 1}^{N} exp{x_n}$ in a numerically stable way.  \vspace{0.2 cm} \\ }}%
    {a.subseq}{\hypertarget{a.subseq}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.subseq":$\!$ [a, start, end]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the subsequence of {\PFAp a} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {enum.numSymbols}{\hypertarget{enum.numSymbols}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"enum.numSymbols":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any enum {\PFAtp A} \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the number of symbols associated with this enum (a constant). \vspace{0.2 cm} \\ }}%
    {m.link.tanh}{\hypertarget{m.link.tanh}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.tanh":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the hyperbolic tangent function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $\tanh(x_i)$. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {time.isDayOfYear}{\hypertarget{time.isDayOfYear}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isDayOfYear":$\!$ [ts, low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc low \rm & double \\  & \PFAc high \rm & double \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Checks if a timestamp falls within a time range, specified in terms of days of the year.  Timestamp is assumed to be in UTC. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Timestamp.  \\  & \PFAc low \rm & Lower boundary of the range.  \\  & \PFAc high \rm & Upper boundary of the range.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``bad time range'' if low $\mathrm{low} \geq \mathrm{high}$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.poissonCDF}{\hypertarget{prob.dist.poissonCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.poissonCDF":$\!$ [k, lambda]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc k \rm & double \\  & \PFAc lambda \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the poisson distribution parameterized by {\PFAp lambda}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc lambda \rm & Mean and variance parameter.  \\  & {\it (return value)} \rm & With $lambda$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $lambda < 0$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {u-}{\hypertarget{u-}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"u-":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the additive inverse of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}For exactly one integer value, -2147483648, this function produces an ``int overflow'' runtime error. \vspace{0.1 cm} \\ For exactly one long value, -9223372036854775808, this function produces a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.neural.simpleLayers}{\hypertarget{model.neural.simpleLayers}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.neural.simpleLayers":$\!$ [datum, model, activation]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc model \rm & array of any record {\PFAtp M} with \{{\PFApf weights:}$\!$ array of array of double, {\PFApf bias:}$\!$ array of double\} \\  & \PFAc activation \rm & function (double) $\to$ double \\  & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply a feedforward artificial neural network {\PFAp model} to an input {\PFAp datum}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Length {\PFAp d} vector of independent variables.  \\  & \PFAc model \rm & Array containing the parameters of each layer of the feedforward neural network model.  \\  & \PFAc activation \rm & Function applied at the output of each node, except the last.  Usually an ``S''-shaped sigmoid or hyperbolic tangent.  \\  & {\it (return value)} \rm & Returns an array of network outputs.  For a neural network with a single neuron in the last layer (single output), this is an array of length one. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``no layers'' error if the length of model is zero. \vspace{0.1 cm} \\ Raises a ``weights, bias, or datum misaligned'' error if there is any misalignment between inputs and outputs through the layers of the network.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {la.zipmap}{\hypertarget{la.zipmap}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.zipmap":$\!$ [x, y, fcn]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc y \rm & array of array of double \\  & \PFAc fcn \rm & function (double, double) $\to$ double \\ & {\it (returns)} & array of array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc y \rm & map of map of double \\  & \PFAc fcn \rm & function (double, double) $\to$ double \\ & {\it (returns)} & map of map of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each pair of elements from {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This can be used to perform matrix addition: supply a function that adds each pair of elements. \vspace{0.1 cm} \\ Like most functions that deal with matrices, this function has an array signature and a map signature.  In the array signature, the number of rows and columns in {\PFAp x} must be equal to the number of rows and columns of {\PFAp y}, respectively.  In the map signature, missing row-column combinations are assumed to be zero. \vspace{0.1 cm} \\ The order in which elements are computed is not specified, and may be in parallel.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}In the array signature, if any element in {\PFAp x} does not have a corresponding element in {\PFAp y} (or vice-versa), this function raises a ``misaligned matrices'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.corresponds}{\hypertarget{a.corresponds}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.corresponds":$\!$ [a, b, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of any {\PFAtp B} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp B}) $\to$ boolean \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp fcn} is {\PFAc true} when applied to all pairs of elements, one from {\PFAp a} and the other from {\PFAp b} (logical relation). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The number of {\PFAp fcn} calls is not guaranteed. \vspace{0.1 cm} \\ If the lengths of {\PFAp a} and {\PFAp b} are not equal, this function returns {\PFAc false}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.naive.multinomial}{\hypertarget{model.naive.multinomial}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.naive.multinomial":$\!$ [datum, classModel]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of int \\  & \PFAc classModel \rm & array of double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & map of int \\  & \PFAc classModel \rm & map of double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Score {\PFAp datum} using a Multinomial Naive Bayes model. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Vector of independent variables with $d$ dimensions.   \\  & \PFAc classModel \rm & Array or map of multinomial ($d$ different) likelihoods of each independent variable for this class.   \\  & {\it (return value)} \rm & Returns the unscaled log-likelihood of {\PFAp datum} for this class. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\PFAp datum} or {\PFAp classModel} may be expressed as arrays (indexed by integers), or maps (indexed by strings).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``datum and classModel misaligned'' error if when using the map signature the keys of {\PFAp datum} and {\PFAp classModel} don't match one to one, of if when using the array signature they are different lengths. \vspace{0.1 cm} \\ Raises a ``probability in classModel cannot be less than 0, greater than 1, or when normalized return NaN'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.gammaQF}{\hypertarget{prob.dist.gammaQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.gammaQF":$\!$ [p, shape, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc shape \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the gamma distribution parameterized by {\PFAp shape} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc shape \rm & Shape parameter.  \\  & \PFAc scale \rm & Scale parameter.  \\  & {\it (return value)} \rm & With $shape$, $scale$ and $p$, this function returns the value $x$ such that $F_{X}(x)~:= P(X~\leq~x)~=~p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if the $shape < 0$ OR if $scale < 0$. \vspace{0.1 cm} \\ Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {rand.gaussian}{\hypertarget{rand.gaussian}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"rand.gaussian":$\!$ [mu, sigma]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc mu \rm & double \\  & \PFAc sigma \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random number from a Gaussian (normal) distribution with mean {\PFAp mu} and standard deviation {\PFAp sigma}. \vspace{0.2 cm} \\ }}%
    {map.toset}{\hypertarget{map.toset}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.toset":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & map of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Convert an array of objects into a set of objects, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.minLT}{\hypertarget{a.minLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.minLT":$\!$ [a, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the minimum value in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.link.logit}{\hypertarget{m.link.logit}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.logit":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the logit function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $1 / (1 + \exp(-x_i))$. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {bytes.isUtf16le}{\hypertarget{bytes.isUtf16le}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"bytes.isUtf16le":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Returns {\PFAc true} if {\PFAp x} is valid little endian utf-16; {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {impute.errorOnNonNum}{\hypertarget{impute.errorOnNonNum}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"impute.errorOnNonNum":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & float \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Pass through {\PFAp x} if it is neither {\PFAc nan} nor infinite, but raise an error otherwise. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises an ``encountered nan'' if {\PFAp x} is {\PFAc nan}. \vspace{0.1 cm} \\ Raises an ``encountered +inf'' if {\PFAp x} is positive infinity. \vspace{0.1 cm} \\ Raises an ``encountered -inf'' if {\PFAp x} is negative infinity.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.findall}{\hypertarget{re.findall}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.findall":$\!$ [pattern, haystack]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pattern \rm & string \\  & \PFAc haystack \rm & string \\ & {\it (returns)} & array of string \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pattern \rm & bytes \\  & \PFAc haystack \rm & bytes \\ & {\it (returns)} & array of bytes \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array containing each string that {\PFAp pattern} matched in {\PFAp haystack}. \vspace{0.2 cm} \\ }}%
    {m.round}{\hypertarget{m.round}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.round":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & long \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the closest whole number to {\PFAp x}, rounding up if the fractional part is exactly one-half. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Equal to {\PFAf \hyperlink{m.floor}{m.floor}} of ({\PFAp x} + 0.5).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Integer results outside of -2147483648 and 2147483647 (inclusive) produce an ``int overflow'' runtime error. \vspace{0.1 cm} \\ Long-integer results outside of -9223372036854775808 and 9223372036854775807 (inclusive) produce a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.sample.forecast1HoltWinters}{\hypertarget{stat.sample.forecast1HoltWinters}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.forecast1HoltWinters":$\!$ [state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf level:}$\!$ double, {\PFApf trend:}$\!$ double\} \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Forecast one time-step from a state record prepared by {\PFAf \hyperlink{stat.state.updateHoltWinters}{stat.state.updateHoltWinters}} or {\PFAf \hyperlink{stat.state.updateHoltWintersPeriodic}{stat.state.updateHoltWintersPeriodic}}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc state \rm & Record of {\PFApf level}, {\PFApf trend}, and possibly {\PFApf cycle} and {\PFApf multiplicative}.                                                      \begin{description*}\item[\PFAc level:] The constant term in an exponentially weighted linear fit of recent data. \item[\PFAc trend:] The linear term in an exponentially weighted linear fit of recent data. \item[\PFAc cycle:] The history of the previous cycle.  This field is optional, but if provided, it must be a {\PFAc double} and must be accompanied by {\PFApf multiplicative}. \item[\PFAc multiplicative:] If {\PFAc true}, interpret {\PFApf cycle} as multiplicative; if {\PFAc false}, interpret it as additive.  This field is optional, but if provided, it must be a {\PFAc boolean} and must be accompanied by {\PFApf cycle}. \end{description*} \\  & {\it (return value)} \rm & Returns a prediction of the next time-step. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}For $a_t$ = the {\PFApf level} at a time $t$, $b_t$ = the {\PFApf trend} at a time $t$, and $c_t$ = the {\PFApf cycle} at a time $t$ with period $L$, this function returns $a_t + b_t$ (non-periodic), $(a_t + b_t) c_{t+1}$ (multiplicative), or $a_t + b_t + c_{t+1}$ (additive) for each $i$ from $0$ to $n - 1$\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFApf cycle} is empty, an ``empty cycle'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {fixed.toBytes}{\hypertarget{fixed.toBytes}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"fixed.toBytes":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any fixed {\PFAtp A} \\  & {\it (returns)} & bytes \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Convert fixed-length, named bytes into arbitrary-length, anonymous bytes. \vspace{0.2 cm} \\ }}%
    {fixed.fromBytes}{\hypertarget{fixed.fromBytes}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"fixed.fromBytes":$\!$ [original, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc original \rm & any fixed {\PFAtp A} \\  & \PFAc replacement \rm & bytes \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Overlay {\PFAp replacement} on top of {\PFAp original}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp replacement} is shorter than {\PFAp original}, the bytes beyond {\PFAp replacement}'s length are taken from {\PFAp original}. \vspace{0.1 cm} \\ If {\PFAp replacement} is longer than {\PFAp original}, the excess bytes are truncated.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.geometricPDF}{\hypertarget{prob.dist.geometricPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.geometricPDF":$\!$ [x, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the geometric distribution parameterized by {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc prob \rm & Probability of success of each trial (p).  \\  & {\it (return value)} \rm & With $prob$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $p (1 - p)^{x}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $\mathrm{prob} \leq 0$ OR if $\mathrm{prob} > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.sort}{\hypertarget{a.sort}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.sort":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array with the same elements as {\PFAp a} but in ascending order (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp a} is not changed in-place; this is a side-effect-free function.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {metric.squaredEuclidean}{\hypertarget{metric.squaredEuclidean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"metric.squaredEuclidean":$\!$ [similarity, x, y]\} \rm or \PFAc \{"metric.squaredEuclidean":$\!$ [similarity, x, y, missingWeight]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (double, double) $\to$ double \\  & \PFAc x \rm & array of union of \{null, double\} \\  & \PFAc y \rm & array of union of \{null, double\} \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (double, double) $\to$ double \\  & \PFAc x \rm & array of union of \{null, double\} \\  & \PFAc y \rm & array of union of \{null, double\} \\  & \PFAc missingWeight \rm & array of double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Euclidean metric squared, which has the same ordering as the Euclidean metric, but avoids a square root calculation. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc similarity \rm & Similarity function (1-dimensional metric) that quantifies the distance between components of {\PFAp x} and components of {\PFAp y}.  \\  & \PFAc x \rm & First sample vector, which may have missing values.  \\  & \PFAc y \rm & Second sample vector, which may have missing values.  (Must have the same dimension as {\PFAp x}.)  \\  & \PFAc missingWeight \rm & Optional missing-value weights: a vector with the same dimension as {\PFAp x} and {\PFAp y} that determines the normalized contribution of missing values in the sum.  If not provided, missing-value weights of 1.0 are assumed.  \\  & {\it (return value)} \rm & With $I(x_i,y_i)$ = 0 if component $i$ of {\PFAp x} or {\PFAp y} is missing, 1 otherwise, this function returns $(\sum_i I(x_i,y_i) \mbox{similarity}(x_i,y_i)^2)(\sum_i q_i)/(\sum_i I(x_i,y_i) q_i)$ where $q_i$ are components of the missing-value weights.  Without missing values, it is $\sum_i \mbox{similarity}(x_i,y_i)^2$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``dimensions of vectors do not match'' if all vectors do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.mean}{\hypertarget{a.mean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.mean":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the arithmetic mean of numbers in {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Returns {\PFAc NaN} if the array is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.count}{\hypertarget{a.count}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.count":$\!$ [haystack, needle]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & array of {\PFAtp A} \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & {\PFAtp A} \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & function ({\PFAtp A}) $\to$ boolean \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Count the number of times {\PFAp needle} appears in {\PFAp haystack} or the number of times the {\PFAp needle} function evaluates to {\PFAc true}. \vspace{0.2 cm} \\ }}%
    {a.median}{\hypertarget{a.median}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.median":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the value that is in the center of a sorted version of {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} has an odd number of elements, the median is the exact center of the sorted array.  If {\PFAp a} has an even number of elements and is a {\PFAc float} or {\PFAc double}, the median is the average of the two elements closest to the center of the sorted array.  For any other type, the median is the left (first) of the two elements closest to the center of the sorted array.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.ceil}{\hypertarget{m.ceil}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.ceil":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the smallest (closest to negative infinity, not closest to zero) whole number that is greater than or equal to the input. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.tQF}{\hypertarget{prob.dist.tQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.tQF":$\!$ [p, df]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc df \rm & int \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the student's t distribution parameterized by {\PFAp df} and {\PFAp x2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc df \rm & Degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $df$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X \leq x) = p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $df \leq 0$. \vspace{0.1 cm} \\ Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {metric.chebyshev}{\hypertarget{metric.chebyshev}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"metric.chebyshev":$\!$ [similarity, x, y]\} \rm or \PFAc \{"metric.chebyshev":$\!$ [similarity, x, y, missingWeight]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (double, double) $\to$ double \\  & \PFAc x \rm & array of union of \{null, double\} \\  & \PFAc y \rm & array of union of \{null, double\} \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (double, double) $\to$ double \\  & \PFAc x \rm & array of union of \{null, double\} \\  & \PFAc y \rm & array of union of \{null, double\} \\  & \PFAc missingWeight \rm & array of double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Chebyshev metric, also known as the infinity norm or chessboard distance (since it is the number of moves required for a chess king to travel between two points). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc similarity \rm & Similarity function (1-dimensional metric) that quantifies the distance between components of {\PFAp x} and components of {\PFAp y}.  \\  & \PFAc x \rm & First sample vector, which may have missing values.  \\  & \PFAc y \rm & Second sample vector, which may have missing values.  (Must have the same dimension as {\PFAp x}.)  \\  & \PFAc missingWeight \rm & Optional missing-value weights: a vector with the same dimension as {\PFAp x} and {\PFAp y} that determines the normalized contribution of missing values in the sum.  If not provided, missing-value weights of 1.0 are assumed.  \\  & {\it (return value)} \rm & With $I(x_i,y_i)$ = 0 if component $i$ of {\PFAp x} or {\PFAp y} is missing, 1 otherwise, this function returns $(\max_i I(x_i,y_i) \mbox{similarity}(x_i,y_i))(\sum_i q_i)/(\sum_i I(x_i,y_i) q_i)$ where $q_i$ are components of the missing-value weights.  Without missing values, it is $\max_i \mbox{similarity}(x_i,y_i)$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``dimensions of vectors do not match'' if all vectors do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.e}{\hypertarget{m.e}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.e":$\!$ []\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} The double-precision number that is closer than any other to $e$, the base of natural logarithms. \vspace{0.2 cm} \\ }}%
    {bytes.encodeUtf16}{\hypertarget{bytes.encodeUtf16}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.encodeUtf16":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & bytes \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Encode a string as utf-16 (byte order identified by optional byte-order mark) bytes. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises an ``invalid string'' error if the string cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {interp.linearMissing}{\hypertarget{interp.linearMissing}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"interp.linearMissing":$\!$ [x, table]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ double, {\PFApf to:}$\!$ double\} \\ & {\it (returns)} & union of \{null, double\} \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ double, {\PFApf to:}$\!$ array of double\} \\ & {\it (returns)} & union of \{null, array of double\} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Like {\PFAf \hyperlink{interp.linear}{interp.linear}}, but returns a missing value ({\PFAc null}) if the input {\PFAp x} is beyond the {\PFAp table}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Any ties in distance are resolved in favor of the first instance in the {\PFAp table}. \vspace{0.1 cm} \\ If the {\PFApf to} values are arrays, each component will be interpolated.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``table must have at least two entries'' error if {\PFAp table} has fewer than two entries. \vspace{0.1 cm} \\ Raises an ``inconsistent dimensionality'' error if the {\PFApf to} values of the two closest entries have different numbers of dimensions.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.filter}{\hypertarget{a.filter}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.filter":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and return an array of the elements for which {\PFAp fcn} returns {\PFAc true}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.asin}{\hypertarget{m.asin}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.asin":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the arc-sine (inverse of the sine function) of {\PFAp x} as an angle in radians between $-\pi/2$ and $\pi/2$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is from -1 to 1 (inclusive).  Beyond this domain, the result is {\PFAc NaN}, not an exception (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or {\PFAc NaN} values."\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.subseq}{\hypertarget{bytes.subseq}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.subseq":$\!$ [x, start, end]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\  & {\it (returns)} & bytes \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the subsequence of {\PFAp x} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {cast.long}{\hypertarget{cast.long}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.long":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\ & {\it (returns)} & long \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\ & {\it (returns)} & long \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & long \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & long \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Cast {\PFAp x} to a 64-bit integer, rounding if necessary. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Results outside of -9223372036854775808 and 9223372036854775807 (inclusive) produce a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.rindex}{\hypertarget{s.rindex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.rindex":$\!$ [haystack, needle]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc needle \rm & string \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the highest index where {\PFAp haystack} contains {\PFAp needle} or -1 if {\PFAp haystack} does not contain {\PFAp needle}. \vspace{0.2 cm} \\ }}%
    {a.union}{\hypertarget{a.union}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.union":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array that represents the union of {\PFAp a} and {\PFAp b}, treated as sets (ignoring order and duplicates). \vspace{0.2 cm} \\ }}%
    {a.reduceRight}{\hypertarget{a.reduceRight}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.reduceRight":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and accumulate a tally. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The first parameter of {\PFAp fcn} is an element from {\PFAp a} and the second parameter is the running tally. \vspace{0.1 cm} \\ The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it accumulates from right (end) to left (beginning), called exactly once for each element.  For predictable results, {\PFAp fcn} should be associative.  It need not be commutative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.sqrt}{\hypertarget{m.sqrt}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.sqrt":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the positive square root of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is from 0 (inclusive) to infinity.  Beyond this domain, the result is {\PFAc NaN}, not an exception (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or {\PFAc NaN} values."\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.rint}{\hypertarget{m.rint}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.rint":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the closest whole number to {\PFAp x}, rounding toward the nearest even number if the fractional part is exactly one-half. \vspace{0.2 cm} \\ }}%
    {m.link.probit}{\hypertarget{m.link.probit}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.probit":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the probit function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $(\mbox{erf}(x_i/\sqrt{2}) + 1)/2$. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {m.link.softplus}{\hypertarget{m.link.softplus}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.softplus":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the softplus function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $\log(1.0 + \exp(x_i))$. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {bytes.decodeUtf8}{\hypertarget{bytes.decodeUtf8}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.decodeUtf8":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Decode a bytes object as a utf-8 string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises an ``invalid bytes'' error if the bytes cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {//}{\hypertarget{//}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"//":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long\} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Divide {\PFAp y} from {\PFAp x}, returning the largest whole number {\PFAc N} for which {\PFAc N} $\leq$ {\PFAp x}/{\PFAp y} (integral floor division). \vspace{0.2 cm} \\ }}%
    {model.naive.bernoulli}{\hypertarget{model.naive.bernoulli}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.naive.bernoulli":$\!$ [datum, classModel]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of string \\  & \PFAc classModel \rm & map of double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Score {\PFAp datum} using a Multinomial Naive Bayes model. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm &  Vector of independent variables with $d$ dimensions.   \\  & \PFAc classModel \rm &  Array or map of $d$ likelihoods of the presence of each independent variable for this class.   \\  & {\it (return value)} \rm & Returns the unscaled log-likelihood of {\PFAp datum} for this class. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\PFAp datum} or {\PFAp classModel} may be expressed as arrays (indexed by integers), or maps (indexed by strings).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``probability in classModel cannot be less than 0 or greater than 1'' error if a value in {\PFAp classModel} is less than zero or greater than one.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {metric.taxicab}{\hypertarget{metric.taxicab}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"metric.taxicab":$\!$ [similarity, x, y]\} \rm or \PFAc \{"metric.taxicab":$\!$ [similarity, x, y, missingWeight]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (double, double) $\to$ double \\  & \PFAc x \rm & array of union of \{null, double\} \\  & \PFAc y \rm & array of union of \{null, double\} \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (double, double) $\to$ double \\  & \PFAc x \rm & array of union of \{null, double\} \\  & \PFAc y \rm & array of union of \{null, double\} \\  & \PFAc missingWeight \rm & array of double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Taxicab metric, also known as the 1-norm, city-block or Manhattan distance (since it is the distance when confined to a rectilinear city grid). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc similarity \rm & Similarity function (1-dimensional metric) that quantifies the distance between components of {\PFAp x} and components of {\PFAp y}.  \\  & \PFAc x \rm & First sample vector, which may have missing values.  \\  & \PFAc y \rm & Second sample vector, which may have missing values.  (Must have the same dimension as {\PFAp x}.)  \\  & \PFAc missingWeight \rm & Optional missing-value weights: a vector with the same dimension as {\PFAp x} and {\PFAp y} that determines the normalized contribution of missing values in the sum.  If not provided, missing-value weights of 1.0 are assumed.  \\  & {\it (return value)} \rm & With $I(x_i,y_i)$ = 0 if component $i$ of {\PFAp x} or {\PFAp y} is missing, 1 otherwise, this function returns $(\sum_i I(x_i,y_i) \mbox{similarity}(x_i,y_i))(\sum_i q_i)/(\sum_i I(x_i,y_i) q_i)$ where $q_i$ are components of the missing-value weights.  Without missing values, it is $\sum_i \mbox{similarity}(x_i,y_i)$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``dimensions of vectors do not match'' if all vectors do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.map}{\hypertarget{a.map}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.map":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ any {\PFAtp B} \\  & {\it (returns)} & array of {\PFAtp B} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and return an array of the results. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {la.sub}{\hypertarget{la.sub}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.sub":$\!$ [x, y]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc y \rm & array of double \\ & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc y \rm & array of array of double \\ & {\it (returns)} & array of array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\  & \PFAc y \rm & map of double \\ & {\it (returns)} & map of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc y \rm & map of map of double \\ & {\it (returns)} & map of map of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Subtract vector or matrix {\PFAp y} from {\PFAp x} (returns $x - y$). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which elements are computed is not specified, and may be in parallel.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}In the array signature, if any element in {\PFAp x} does not have a corresponding element in {\PFAp y} (or vice-versa), this function raises a ``misaligned matrices'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {interp.linear}{\hypertarget{interp.linear}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"interp.linear":$\!$ [x, table]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ double, {\PFApf to:}$\!$ double\} \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ double, {\PFApf to:}$\!$ array of double\} \\ & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Finds the closest {\PFApf x} values in the {\PFAp table} that are below and above the input {\PFAp x} and linearly projects their {\PFApf to} values to the input {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Any ties in distance are resolved in favor of the first instance in the {\PFAp table}. \vspace{0.1 cm} \\ If the {\PFApf to} values are arrays, each component will be interpolated.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``table must have at least two distinct x values'' error if fewer than two of the {\PFAp table} {\PFApf x} entries are unique. \vspace{0.1 cm} \\ Raises an ``inconsistent dimensionality'' error if the {\PFApf to} values of the two closest entries have different numbers of dimensions.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {+}{\hypertarget{+}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"+":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Add {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Float and double overflows do not produce runtime errors but result in positive or negative infinity, which would be carried through any subsequent calculations (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or NaN values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Integer results above or below -2147483648 and 2147483647 (inclusive) produce an ``int overflow'' runtime error. \vspace{0.1 cm} \\ Long-integer results above or below -9223372036854775808 and 9223372036854775807 (inclusive) produce a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.weibullPDF}{\hypertarget{prob.dist.weibullPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.weibullPDF":$\!$ [x, shape, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc shape \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the weibull distribution parameterized by {\PFAp shape} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc shape \rm & Shape parameter (a).  \\  & \PFAc scale \rm & Scale parameter (b).  \\  & {\it (return value)} \rm & With $shape$, $scale$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{a}{b}(\frac{x}{b})^{a - 1}\mathrm{e}^{-(\frac{x}{b})^{a}}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if the $shape \leq 0$ OR if $scale \leq 0$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.sample.fillHistogram}{\hypertarget{stat.sample.fillHistogram}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"stat.sample.fillHistogram":$\!$ [x, w, histogram]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc w \rm & double \\  & \PFAc histogram \rm & any record {\PFAtp A} with \{{\PFApf numbins:}$\!$ int, {\PFApf low:}$\!$ double, {\PFApf high:}$\!$ double, {\PFApf values:}$\!$ array of double\} \\ & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc w \rm & double \\  & \PFAc histogram \rm & any record {\PFAtp A} with \{{\PFApf low:}$\!$ double, {\PFApf binsize:}$\!$ double, {\PFApf values:}$\!$ array of double\} \\ & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc w \rm & double \\  & \PFAc histogram \rm & any record {\PFAtp A} with \{{\PFApf ranges:}$\!$ array of array of double, {\PFApf values:}$\!$ array of double\} \\ & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update a histogram by filling it with one value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample value.  \\  & \PFAc w \rm & Sample weight; set to 1 for no weights.  \\  & \PFAc histogram \rm & The histogram prior to filling.  It must have {\PFApf numbins}, {\PFApf low}, {\PFApf high}, and {\PFApf values} (fixed bins) xor it must have {\PFApf low}, {\PFApf binsize}, and {\PFApf values} (number of equal-sized bins grows), xor it must have {\PFApf ranges} and {\PFApf values} (arbitrary interval bins).  Only one set of required fields is allowed (semantic error otherwise), and the rest of the fields are optional.                                                                                                  \begin{description*}\item[\PFAc numbins:] The fixed number of bins in the histogram. \item[\PFAc low:] The low edge of the histogram range (inclusive). \item[\PFAc high:] The high edge of the histogram range (exclusive). \item[\PFAc binsize:] The size of a bin for a histogram whose number of bins and right edge grows with the data. \item[\PFAc ranges:] Pairs of values describing arbitrary interval bins.  The first number of each pair is the inclusive left edge and the second number is the exclusive right edge. \item[\PFAc values:] Histogram contents, which are updated by this function. \item[\PFAc underflow:] If present, this double-valued field counts {\PFAp x} values that are less than {\PFApf low} or not contained in any {\PFApf ranges}. \item[\PFAc overflow:] If present, this double-valued field counts {\PFAp x} values that are greater than {\PFApf high}. \item[\PFAc nanflow:] If present, this double-valued field counts {\PFAp x} values that are {\PFAc nan}.  {\PFAc nan} values would never enter {\PFApf values}, {\PFApf underflow}, or {\PFApf overflow}. \item[\PFAc :] If present, this double-valued field counts {\PFAp x} values that are infinite.  Infinite values would only enter {\PFApf underflow} or {\PFApf overflow} if {\PFApf infflow} is not present, so that they are not double-counted. \end{description*} \\  & {\it (return value)} \rm & Returns an updated version of {\PFAp histogram}: all fields are unchanged except for {\PFApf values}, {\PFApf underflow}, {\PFApf overflow}, {\PFApf nanflow}, and {\PFApf infflow}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the histogram is growable (described by {\PFApf low} and {\PFApf binsize}) and {\PFAp x} minus {\PFApf low} is greater than or equal to {\PFApf binsize} times the length of {\PFApf values}, the {\PFApf values} will be padded with zeros to reach it. \vspace{0.1 cm} \\ If the histogram is growable (described by {\PFApf low} and {\PFApf binsize}), only finite values can extend the size of the histogram: infinite values are entered into {\PFApf overflow} or {\PFApf infflow}, depending on whether {\PFApf infflow} is present. \vspace{0.1 cm} \\ If the histogram is described by {\PFApf ranges} and an element of {\PFApf ranges} contains two equal values, then {\PFAp x} is considered in the interval if it is exactly equal to the value. \vspace{0.1 cm} \\ If the histogram is described by {\PFApf ranges} and {\PFAp x} falls within multiple, overlapping intervals, then all matching counters are updated (values can be double-counted).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the length of {\PFApf values} is not equal to {\PFApf numbins} or the length of {\PFApf ranges}, then a ``wrong histogram size'' error is raised. \vspace{0.1 cm} \\ If {\PFApf low} is greater than or equal to {\PFApf high}, then a ``bad histogram range'' error is raised. \vspace{0.1 cm} \\ If {\PFApf numbins} is less than 1 or {\PFApf binsize} is equal to 0, then a ``bad histogram scale'' error is raised. \vspace{0.1 cm} \\ If {\PFApf ranges} contains an array of doubles with length not equal to 2 or if the first element is greater than the second element, then a ``bad histogram ranges'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.ntile}{\hypertarget{a.ntile}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.ntile":$\!$ [a, p]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc p \rm & double \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the value that is at the ``n-tile'' of {\PFAp a} (like a percentile). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc a \rm & Array of objects to be take the percentile of.  \\  & \PFAc p \rm & A double between 0 and 1.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} has an even number of elements and is a {\PFAc float} or {\PFAc double}, this function will take the average of the two elements closest to the center of the sorted array.  For any other type, it returns the left (first) of the two elements closest to the center of the sorted array.  If {\PFAp p} is exactly one (or greater), the max of the array is returned.  If {\PFAp p} is zero (or less), the min of the array is returned.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {!=}{\hypertarget{!=}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"!=":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is not equal to {\PFAp y}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {stat.sample.updateHoltWinters}{\hypertarget{stat.sample.updateHoltWinters}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.updateHoltWinters":$\!$ [x, alpha, beta, state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc alpha \rm & double \\  & \PFAc beta \rm & double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf level:}$\!$ double, {\PFApf trend:}$\!$ double\} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update the state of a time series analysis with an exponentially weighted linear fit. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample value.  \\  & \PFAc alpha \rm & Weighting factor (usually a constant) between 0 and 1, inclusive, that governs the responsiveness of the {\PFApf level}.  If {\PFAp alpha} is close to 1, recent data are heavily weighted at the expense of old data.  \\  & \PFAc beta \rm & Weighting factor (usually a constant) between 0 and 1, inclusive, that governs the responsiveness of the {\PFApf trend}.  If {\PFAp beta} is close to 1, recent data are heavily weighted at the expense of old data.  \\  & \PFAc state \rm & Record of the previous {\PFApf level} and {\PFApf trend}.                                \begin{description*}\item[\PFAc level:] The constant term in an exponentially weighted linear fit of recent data, weighted by {\PFAp alpha}. \item[\PFAc trend:] The linear term in an exponentially weighted linear fit of recent data, weighted by {\PFAp beta}. \end{description*} \\  & {\it (return value)} \rm & Returns an updated version of the {\PFAp state}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Use {\PFAf \hyperlink{stat.sample.forecast1HoltWinters}{stat.sample.forecast1HoltWinters}} or {\PFAf \hyperlink{stat.sample.forecastHoltWinters}{stat.sample.forecastHoltWinters}} to make predictions from the state record. \vspace{0.1 cm} \\ For $a_t$ = the {\PFApf level} at a time $t$ and $b_t$ = the {\PFApf trend} at a time $t$, $a_t = \alpha x + (1 - \alpha)(a_{t-1} + b_{t-1})$ and $b_t = \beta (a_t - a_{t-1}) + (1 - \beta) b_{t-1}$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp alpha} is less than 0 or greater than 1, an ``alpha out of range'' error is raised. \vspace{0.1 cm} \\ If {\PFAp beta} is less than 0 or greater than 1, an ``beta out of range'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.neighbor.nearestK}{\hypertarget{model.neighbor.nearestK}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.neighbor.nearestK":$\!$ [k, datum, codebook, metric]\} \rm or \PFAc \{"model.neighbor.nearestK":$\!$ [k, datum, codebook]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc k \rm & int \\  & \PFAc datum \rm & any {\PFAtp A} \\  & \PFAc codebook \rm & array of any {\PFAtp B} \\  & \PFAc metric \rm & function ({\PFAtp A}, {\PFAtp B}) $\to$ double \\ & {\it (returns)} & array of {\PFAtp B} \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc k \rm & int \\  & \PFAc datum \rm & array of double \\  & \PFAc codebook \rm & array of array of double \\ & {\it (returns)} & array of array of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Find the {\PFAp k} items in the {\PFAp codebook} that are closest to the {\PFAp datum}, according to the {\PFAp metric}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc k \rm & Number of {\PFAp codebook} points to attempt to return.  \\  & \PFAc datum \rm & Sample datum.  \\  & \PFAc codebook \rm & Set of training data that is compared to the {\PFAp datum}.  \\  & \PFAc metric \rm & Function used to compare each {\PFAp datum} to each element of the {\PFAp codebook}.  (See, for example, {\PFAf \hyperlink{metric.euclidean}{metric.euclidean}}.)  \\  & {\it (return value)} \rm & An array of the closest {\PFAp codebook} elements in any order.  The length of the array is minimum of {\PFAp k} and the length of {\PFAp codebook}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp k} is negative, an ``k must be nonnegative'' error will be raised. \vspace{0.1 cm} \\ If arrays in the {\PFAp codebook} or the {\PFAp codebook} and the {\PFAp datum} have different sizes (without a {\PFAp metric}), an ``inconsistent dimensionality'' error will be raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {\&\&}{\hypertarget{\&\&}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"\&\&":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & boolean \\  & \PFAc y \rm & boolean \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} and {\PFAp y} are both {\PFAc true}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp x} is {\PFAc false}, {\PFAp y} won't be evaluated.  (Only relevant for arguments with side effects.)\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.sample.updateWindow}{\hypertarget{stat.sample.updateWindow}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.updateWindow":$\!$ [x, w, state, windowSize]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc w \rm & double \\  & \PFAc state \rm & array of any record {\PFAtp A} with \{{\PFApf x:}$\!$ double, {\PFApf w:}$\!$ double, {\PFApf count:}$\!$ double\} \\  & \PFAc windowSize \rm & int \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update the state of a counter, a counter and a mean, or a counter, mean, and variance, within a window of {\PFAp windowSize} recent samples. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample value.  \\  & \PFAc w \rm & Sample weight; set to 1 for no weights.  \\  & \PFAc state \rm & Array of previous {\PFApf count}, {\PFApf mean}, and/or {\PFApf variance} and samples in the window.                                                                 \begin{description*}\item[\PFAc count:] The sum of weights {\PFAp w} within the window. \item[\PFAc mean:] The mean of {\PFAp x} within the window, weighted by {\PFAp w}.  This field is optional, but if provided, it must be a {\PFAc double}. \item[\PFAc variance:] The variance of $x - \mbox{mean}$ within the window, weighted by {\PFAp w}.  This field is optional, but if it is provided, it must be a {\PFAc double}, and there must be a {\PFApf mean} as well.  No attempt is made to unbias the estimator, so multiply this by $\mbox{count}/(\mbox{count} - 1)$ to correct for the bias due to centering on the mean. \item[\PFAc x:] Sample value, saved so that it can be removed from the running mean and variance when it goes out of scope. \item[\PFAc w:] Sample weight, saved for the same reason. \end{description*} \\  & \PFAc windowSize \rm & Size of the window.  When the length of {\PFAp state} is less than {\PFAp windowSize}, this function is equivalent to {\PFAf \hyperlink{stat.sample.update}{stat.sample.update}}.  \\  & {\it (return value)} \rm & If the length of {\PFAp state} is zero, this function returns a singleton array with {\PFApf count} = {\PFAp w}, {\PFApf mean} = {\PFAp x}, and/or {\PFApf variance} = 0.  If the length of {\PFAp state} is less than {\PFAp windowSize}, then it returns a copy of {\PFAp state} with the next record added.  Otherwise, it is trunctated to {\PFAp windowSize}, removing the old values from the running count/mean/variance.  In all cases, the {\PFAf \hyperlink{a.last}{a.last}} item is the latest result. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp windowSize} is less than 2, a ``windowSize must be at least 2'' error is raised. \vspace{0.1 cm} \\ If {\PFAp state} is empty and the record type has fields other than {\PFApf count}, {\PFApf mean}, and {\PFApf variance}, then a ``cannot initialize unrecognized fields'' error is raised.  Unrecognized fields are only allowed if an initial record is provided.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.uniformCDF}{\hypertarget{prob.dist.uniformCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.uniformCDF":$\!$ [x, min, max]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc min \rm & double \\  & \PFAc max \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the uniform distribution parameterized by {\PFAp min} and {\PFAp max}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc min \rm & Lower bound.  \\  & \PFAc max \rm & Upper bound.  \\  & {\it (return value)} \rm & With $min$, $max$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $min \geq max$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.special.erf}{\hypertarget{m.special.erf}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.special.erf":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the error function of {\PFAp x}. \vspace{0.2 cm} \\ }}%
    {s.replacelast}{\hypertarget{s.replacelast}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.replacelast":$\!$ [s, original, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc original \rm & string \\  & \PFAc replacement \rm & string \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace the last (rightmost) instance of the substring {\PFAp original} from {\PFAp s} with {\PFAp replacement}. \vspace{0.2 cm} \\ }}%
    {time.dayOfMonth}{\hypertarget{time.dayOfMonth}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.dayOfMonth":$\!$ [ts]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the day of the month that the timestamp falls within.  Timestamp is assumed to be in UTC.  The first day of the month equals 1. \vspace{0.2 cm} \\ }}%
    {bytes.isUtf8}{\hypertarget{bytes.isUtf8}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"bytes.isUtf8":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Returns {\PFAc true} if {\PFAp x} is valid utf-8; {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {model.reg.chi2Prob}{\hypertarget{model.reg.chi2Prob}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.reg.chi2Prob":$\!$ [state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf chi2:}$\!$ double, {\PFApf DOF:}$\!$ int\} \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the chi-square probability, which is the CDF of the chi-square function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc state \rm & Record of the {\PFApf chi2} and {\PFApf DOF}.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if {\PFApf DOF} is less than zero.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.toBase64}{\hypertarget{bytes.toBase64}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.toBase64":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Convert an arbitrary bytes object to a base64-encoded string. \vspace{0.2 cm} \\ }}%
    {a.argmax}{\hypertarget{a.argmax}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argmax":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the index of the maximum value in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the maximum is not unique, this function returns the index of the first maximal value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {metric.tanimoto}{\hypertarget{metric.tanimoto}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"metric.tanimoto":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of boolean \\  & \PFAc y \rm & array of boolean \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Tanimoto similarity of binary vectors. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & First sample vector.  \\  & \PFAc y \rm & Second sample vector.  (Must have the same dimension as {\PFAp x}.)  \\  & {\it (return value)} \rm & Where $a_{11}$ is the number of {\PFAp x}, {\PFAp y} coordinate pairs that are equal to {\PFAc true, true}, $a_{10}$ is the number of {\PFAc true, false}, $a_{01}$ is the number of {\PFAc false, true}, and $a_{00}$ is the number of {\PFAc false, false}, this function returns $(a_{11} + a_{00})/(a_{11} + 2*(a_{10} + a_{01}) + a_{00})$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``dimensions of vectors do not match'' if {\PFAp x} and {\PFAp y} do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.ln1p}{\hypertarget{m.ln1p}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.ln1p":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return $ln(x^2 + 1)$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Avoids round-off or overflow errors in the intermediate steps. \vspace{0.1 cm} \\ The domain of this function is from -1 to infinity (exclusive).  Given -1, the result is negative infinity, and below -1, the result is {\PFAc NaN}, not an exception (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or {\PFAc NaN} values."\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.argmaxN}{\hypertarget{a.argmaxN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argmaxN":$\!$ [a, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & {\it (returns)} & array of int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the indexes of the {\PFAp n} highest values in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their indexes will be returned in ascending order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.isLatin1}{\hypertarget{bytes.isLatin1}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"bytes.isLatin1":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Returns {\PFAc true} if {\PFAp x} is valid latin-1 (ISO-8859-1); {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {prob.dist.geometricQF}{\hypertarget{prob.dist.geometricQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.geometricQF":$\!$ [p, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the geometric distribution parameterized by {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc prob \rm & Probability of success of each trial.  \\  & {\it (return value)} \rm & With $prob$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X \leq x) = p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $\mathrm{prob} \leq 0$ OR if $\mathrm{prob} > 1$. \vspace{0.1 cm} \\ Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.negativeBinomialCDF}{\hypertarget{prob.dist.negativeBinomialCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.negativeBinomialCDF":$\!$ [x, size, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc size \rm & int \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the negative binomial distribution parameterized by {\PFAp size} and {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc size \rm & Size parameter (integer).  Target number of successful trials.  \\  & \PFAc prob \rm & Probability of success in each trial.  \\  & {\it (return value)} \rm & With $size$, $prob$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $\mathrm{prob} < 0$ OR if $\mathrm{prob} > 1$. \vspace{0.1 cm} \\ Raises ``invalid parameterization'' if $size < 0$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.acos}{\hypertarget{m.acos}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.acos":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the arc-cosine (inverse of the cosine function) of {\PFAp x} as an angle in radians between $0$ and $\pi$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is from -1 to 1 (inclusive).  Beyond this domain, the result is {\PFAc NaN}, not an exception (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or {\PFAc NaN} values."\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.chi2QF}{\hypertarget{prob.dist.chi2QF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.chi2QF":$\!$ [p, df]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc df \rm & int \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the Chi-squared distribution parameterized by its degrees of freedom {\PFAp df}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc df \rm & Degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $x1$, $x1$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X \leq x) = p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if {\PFAp df} < 0. \vspace{0.1 cm} \\ Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.endswith}{\hypertarget{s.endswith}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.endswith":$\!$ [haystack, needle]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc needle \rm & string \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if the last (rightmost) subseqence of {\PFAp haystack} is equal to {\PFAp needle}, false otherwise. \vspace{0.2 cm} \\ }}%
    {m.link.softmax}{\hypertarget{m.link.softmax}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.softmax":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the softmax function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $\exp(x_i)/\sum_j \exp(x_j)$. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {prob.dist.lognormalQF}{\hypertarget{prob.dist.lognormalQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.lognormalQF":$\!$ [p, meanlog, sdlog]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc meanlog \rm & double \\  & \PFAc sdlog \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the lognormal distribution parameterized by {\PFAp meanlog} and {\PFAp sdlog}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc meanlog \rm & Mean of the distribution on the log scale.  \\  & \PFAc sdlog \rm & Standard deviation of the distribution on the log scale.  \\  & {\it (return value)} \rm & With $meanlog$, $sdlog$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X \leq x) = p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $sdlog \leq 0$. \vspace{0.1 cm} \\ Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.floor}{\hypertarget{m.floor}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.floor":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the largest (closest to positive infinity) whole number that is less than or equal to the input. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.correspondsWithIndex}{\hypertarget{a.correspondsWithIndex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.correspondsWithIndex":$\!$ [a, b, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of any {\PFAtp B} \\  & \PFAc fcn \rm & function (int, {\PFAtp A}, {\PFAtp B}) $\to$ boolean \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp fcn} is {\PFAc true} when applied to all triples of index, element from {\PFAp a}, element from {\PFAp b} (logical relation). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The number of {\PFAp fcn} calls is not guaranteed. \vspace{0.1 cm} \\ If the lengths of {\PFAp a} and {\PFAp b} are not equal, this function returns {\PFAc false}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.startswith}{\hypertarget{a.startswith}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.startswith":$\!$ [haystack, needle]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & array of {\PFAtp A} \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & {\PFAtp A} \\ & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if the first (leftmost) subseqence of {\PFAp haystack} is equal to {\PFAp needle}, false otherwise. \vspace{0.2 cm} \\ }}%
    {map.len}{\hypertarget{map.len}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.len":$\!$ [m]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the length of a map. \vspace{0.2 cm} \\ }}%
    {map.keys}{\hypertarget{map.keys}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.keys":$\!$ [m]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & {\it (returns)} & array of string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the keys of a map (in no particular order). \vspace{0.2 cm} \\ }}%
    {model.tree.missingWalk}{\hypertarget{model.tree.missingWalk}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.tree.missingWalk":$\!$ [datum, treeNode, test]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & any record {\PFAtp D} \\  & \PFAc treeNode \rm & any record {\PFAtp T} with \{{\PFApf pass:}$\!$ union of \{{\PFAtp T}, any {\PFAtp S}\}, {\PFApf fail:}$\!$ union of \{{\PFAtp T}, {\PFAtp S}\}, {\PFApf missing:}$\!$ union of \{{\PFAtp T}, {\PFAtp S}\}\} \\  & \PFAc test \rm & function ({\PFAtp D}, {\PFAtp T}) $\to$ union of \{null, boolean\} \\  & {\it (returns)} & {\PFAtp S} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Descend through a tree, testing the fields of {\PFAp datum} with the {\PFAp test} function using {\PFAp treeNode} to define the comparison, continuing to {\PFApf pass}, {\PFApf fail}, or {\PFApf missing} until reaching a leaf node of type {\PFAtp S} (score). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Sample value to test.  \\  & \PFAc treeNode \rm & Node of the tree, which contains a predicate to be interpreted by {\PFAp test}.                                           \begin{description*}\item[\PFAc pass:] Branch to follow if {\PFAp test} returns {\PFAc true}. \item[\PFAc fail:] Branch to follow if {\PFAp test} returns {\PFAc false}. \item[\PFAc missing:] Branch to follow if {\PFAp test} returns {\PFAc null}. \end{description*} \\  & \PFAc test \rm & Test function that converts {\PFAp datum} and {\PFAp treeNode} into {\PFAc true}, {\PFAc false}, or {\PFAc null}.  \\  & {\it (return value)} \rm & Leaf node of type {\PFAtp S}, which must be different from the tree nodes.  For a classification tree, {\PFAtp S} could be a string or an enumeration set.  For a regression tree, {\PFAtp S} would be a numerical type.  For a multivariate regression tree, {\PFAtp S} would be an array of numbers, etc. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {m.link.relu}{\hypertarget{m.link.relu}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.relu":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the rectified linear unit (ReLu) function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $\log(1.0 + \exp(x_i))$. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {rand.uuid}{\hypertarget{rand.uuid}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"rand.uuid":$\!$ []\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random (type 4) UUID with IETF variant (8). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & The return value is a string with the form {\PFAc xxxxxxxx-xxxx-4xxx-8xxx-xxxxxxxxxxxx} where {\PFAc x} are random, lowercase hexidecimal digits (0-9a-f), 4 is the version, and 8 is the IETF variant. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {la.scale}{\hypertarget{la.scale}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.scale":$\!$ [x, alpha]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc alpha \rm & double \\ & {\it (returns)} & array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc alpha \rm & double \\ & {\it (returns)} & array of array of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\  & \PFAc alpha \rm & double \\ & {\it (returns)} & map of double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc alpha \rm & double \\ & {\it (returns)} & map of map of double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Scale vector or matrix {\PFAp x} by factor {\PFAp alpha}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which elements are computed is not specified, and may be in parallel.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.argmaxLT}{\hypertarget{a.argmaxLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argmaxLT":$\!$ [a, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the index of the maximum value in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the maximum is not unique, this function returns the index of the first maximal value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.exponentialQF}{\hypertarget{prob.dist.exponentialQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.exponentialQF":$\!$ [p, lambda]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc lambda \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the exponential distribution parameterized by {\PFAp lambda}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc lambda \rm & Rate parameter.  \\  & {\it (return value)} \rm & With $lambda$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X~\leq~x)~=~p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $lambda < 0$. \vspace{0.1 cm} \\ Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.rstrip}{\hypertarget{s.rstrip}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.rstrip":$\!$ [s, chars]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc chars \rm & string \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Remove any characters found in {\PFAp chars} from the end (right) of {\PFAp s}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order of characters in {\PFAp chars} is irrelevant.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.sample.topN}{\hypertarget{stat.sample.topN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.topN":$\!$ [x, top, n, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc top \rm & array of {\PFAtp A} \\  & \PFAc n \rm & int \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update an array of the top {\PFAp n} sorted items by potentially adding {\PFAp x} to that array, using {\PFAp lessThan} as a comparison function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample value.  \\  & \PFAc top \rm & Array of items to which {\PFAp x} might be added.  This array is assumed to be sorted according to {\PFAp lessThan}.  \\  & \PFAc n \rm & Maximum number of items to keep.  \\  & \PFAc lessThan \rm & Comparison function; should return {\PFAc true} if its first argument is less than its second argument, {\PFAc false} otherwise.  \\  & {\it (return value)} \rm & Returns an updated version of {\PFAp top}.  If {\PFAp x} is among the top {\PFAp n} values seen, then it is included in the output.  Otherwise, the output is {\PFAp top}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The {\PFAp x} value is inserted after the first element of {\PFAp top} that it is greater than or equal to ({\PFAp lessThan} applied to that array element and {\PFAp x} returns {\PFAc true}) and the result is truncated to size {\PFAp n}.  Thus, the result only represents a top-n list if {\PFAp top} is already sorted and equal elements already in the array get precedence. \vspace{0.1 cm} \\ The {\PFAp top} array is unchanged by this function because all values in PFA are immutable.  The updated array is the return value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.exponentialCDF}{\hypertarget{prob.dist.exponentialCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.exponentialCDF":$\!$ [x, lambda]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc lambda \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the exponential distribution parameterized by {\PFAp lambda}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc lambda \rm & Rate parameter.  \\  & {\it (return value)} \rm & With $lambda$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if $lambda < 0$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {rand.histogram}{\hypertarget{rand.histogram}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"rand.histogram":$\!$ [distribution]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc distribution \rm & array of double \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc distribution \rm & array of any record {\PFAtp A} with \{{\PFApf prob:}$\!$ double\} \\ & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random index of {\PFAp distribution} with probability proportional to the value of that index or a random item from {\PFAp distribution} with probability proportional to the {\PFApf prob} field. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the probabilities do not sum to 1.0, they will be normalized first.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``distribution must be non-empty'' error if no items of {\PFAp distribution} are non-zero. \vspace{0.1 cm} \\ Raises a ``distribution must be finite'' error if any items of {\PFAp distribution} are infinite or {\PFAc NaN}. \vspace{0.1 cm} \\ Raises a ``distribution must be non-negative'' error if any items of {\PFAp distribution} are negative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.sinh}{\hypertarget{m.sinh}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.sinh":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the hyperbolic sine of {\PFAp x}, which is equal to $\frac{e^x - e^{-x}}{2}$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {TILDE}{\hypertarget{TILDE}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"\textasciitilde{}":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\ & {\it (returns)} & long \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Calculate the bitwise-not of {\PFAp x}. \vspace{0.2 cm} \\ }}%
    {a.disjoint}{\hypertarget{a.disjoint}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.disjoint":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp a} and {\PFAp b} are disjoint, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {metric.euclidean}{\hypertarget{metric.euclidean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"metric.euclidean":$\!$ [similarity, x, y]\} \rm or \PFAc \{"metric.euclidean":$\!$ [similarity, x, y, missingWeight]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (any {\PFAtp A}, any {\PFAtp B}) $\to$ double \\  & \PFAc x \rm & array of union of \{null, {\PFAtp A}\} \\  & \PFAc y \rm & array of union of \{null, {\PFAtp B}\} \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (any {\PFAtp A}, any {\PFAtp B}) $\to$ double \\  & \PFAc x \rm & array of union of \{null, {\PFAtp A}\} \\  & \PFAc y \rm & array of union of \{null, {\PFAtp B}\} \\  & \PFAc missingWeight \rm & array of double \\ & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Euclidean metric, which is the distance function for ordinary space, given by the Pythagorean formula (also known as the 2-norm). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc similarity \rm & Similarity function (1-dimensional metric) that quantifies the distance between components of {\PFAp x} and components of {\PFAp y}.  \\  & \PFAc x \rm & First sample vector, which may have missing values.  \\  & \PFAc y \rm & Second sample vector, which may have missing values.  (Must have the same dimension as {\PFAp x}.)  \\  & \PFAc missingWeight \rm & Optional missing-value weights: a vector with the same dimension as {\PFAp x} and {\PFAp y} that determines the normalized contribution of missing values in the sum.  If not provided, missing-value weights of 1.0 are assumed.  \\  & {\it (return value)} \rm & With $I(x_i,y_i)$ = 0 if component $i$ of {\PFAp x} or {\PFAp y} is missing, 1 otherwise, this function returns $\sqrt{(\sum_i I(x_i,y_i) \mbox{similarity}(x_i,y_i)^2)(\sum_i q_i)/(\sum_i I(x_i,y_i) q_i)}$ where $q_i$ are components of the missing-value weights.  Without missing values, it is $\sqrt{\sum_i \mbox{similarity}(x_i,y_i)^2}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``dimensions of vectors do not match'' if all vectors do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.decodeAscii}{\hypertarget{bytes.decodeAscii}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.decodeAscii":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Decode a bytes object as an ASCII string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises an ``invalid bytes'' error if the bytes cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.product}{\hypertarget{a.product}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.product":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} of \{int, long, float, double\} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the product of numbers in {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Returns one if the array is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.chi2CDF}{\hypertarget{prob.dist.chi2CDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.chi2CDF":$\!$ [x, df]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc df \rm & int \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the Chi-squared distribution parameterized by its degrees of freedom {\PFAp df}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc df \rm & Degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $x1$, $x1$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if {\PFAp df} < 0.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.minN}{\hypertarget{a.minN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.minN":$\!$ [a, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the {\PFAp n} lowest values in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.hypergeometricQF}{\hypertarget{prob.dist.hypergeometricQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.hypergeometricQF":$\!$ [p, m, n, k]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc m \rm & int \\  & \PFAc n \rm & int \\  & \PFAc k \rm & int \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the hypergeometric distribution parameterized by {\PFAp m}, {\PFAp n} and {\PFAp k}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc m \rm & The number of white balls in the urn.  \\  & \PFAc n \rm & The number of black balls in the urn.  \\  & \PFAc k \rm & The number of balls drawn from the urn.  \\  & {\it (return value)} \rm & With $m$, $n$ and $k$ at $p$, this function returns the value $x$ such that $F_{X}(x)~:= P(X~\leq~x)~=~p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``invalid parameterization'' if the $\mathrm{m} + \mathrm{n} > \mathrm{k}$. \vspace{0.1 cm} \\ Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.strip}{\hypertarget{s.strip}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.strip":$\!$ [s, chars]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc chars \rm & string \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Remove any characters found in {\PFAp chars} from the beginning or end of {\PFAp s}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order of characters in {\PFAp chars} is irrelevant.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.findfirst}{\hypertarget{re.findfirst}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.findfirst":$\!$ [pattern, haystack]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pattern \rm & string \\  & \PFAc haystack \rm & string \\ & {\it (returns)} & union of \{string, null\} \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pattern \rm & bytes \\  & \PFAc haystack \rm & bytes \\ & {\it (returns)} & union of \{bytes, null\} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the first occurance of what {\PFAp pattern} matched in {\PFAp haystack}. \vspace{0.2 cm} \\ }}%
    {model.cluster.kmeansIteration}{\hypertarget{model.cluster.kmeansIteration}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.cluster.kmeansIteration":$\!$ [data, clusters, metric, update]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc data \rm & array of array of any {\PFAtp A} \\  & \PFAc clusters \rm & array of any record {\PFAtp C} with \{{\PFApf center:}$\!$ array of any {\PFAtp B}\} \\  & \PFAc metric \rm & function (array of {\PFAtp A}, array of {\PFAtp B}) $\to$ double \\  & \PFAc update \rm & function (array of array of {\PFAtp A}, {\PFAtp C}) $\to$ {\PFAtp C} \\  & {\it (returns)} & array of {\PFAtp C} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update a cluster set by applying one iteration of k-means (Lloyd's algorithm). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc data \rm & Sample data.  \\  & \PFAc clusters \rm & Set of clusters; the record type {\PFAtp C} may contain additional identifying information for post-processing.  \\  & \PFAc metric \rm & Function used to compare each {\PFAp datum} with the {\PFApf center} of the {\PFAp clusters}.  (See, for example, {\PFAf \hyperlink{metric.euclidean}{metric.euclidean}}.)  \\  & \PFAc update \rm & Function of matched data and old cluster records that yields new cluster records.  (See, for example, {\PFAf \hyperlink{model.cluster.updateMean}{model.cluster.updateMean}} with {\PFAp weight} = 0.)  \\  & {\it (return value)} \rm & Returns a new cluster set with each of the {\PFAtp centers} located at the average of all points that match the corresponding cluster in the old cluster set. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The {\PFAp update} function is only called if the number of matched data points is greater than zero.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``no data'' error if {\PFAp data} is empty. \vspace{0.1 cm} \\ Raises a ``no clusters'' error if {\PFAp clusters} is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.decodeUtf16be}{\hypertarget{bytes.decodeUtf16be}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.decodeUtf16be":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Decode a bytes object as a big endian utf-16 string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises an ``invalid bytes'' error if the bytes cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {\^{}}{\hypertarget{\^{}}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"\^{}":$\!$ [x, y]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc y \rm & int \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc y \rm & long \\ & {\it (returns)} & long \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Calculate the bitwise-exclusive-or of {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ }}%
    {stat.change.updateTrigger}{\hypertarget{stat.change.updateTrigger}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.change.updateTrigger":$\!$ [predicate, history]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc predicate \rm & boolean \\  & \PFAc history \rm & any record {\PFAtp A} with \{{\PFApf numEvents:}$\!$ int, {\PFApf numRuns:}$\!$ int, {\PFApf currentRun:}$\!$ int, {\PFApf longestRun:}$\!$ int\} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update the state of a trigger that counts the number of times {\PFAp predicate} is satisfied ({\PFAc true}), as well as the number and lengths of runs of {\PFAc true}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc predicate \rm & Expression that evaluates to {\PFAc true} or {\PFAc false}.  \\  & \PFAc history \rm & Summary of previous results of the {\PFAp predicate}.                                                      \begin{description*}\item[\PFAc numEvents:] The number of times {\PFAp predicate} evaluated to {\PFAc true}. \item[\PFAc numRuns:] The number of contiguous intervals in which {\PFAp predicate} was {\PFAc true}, including the current one. \item[\PFAc currentRun:] If {\PFAp predicate} is {\PFAc false}, {\PFApf currentRun} is 0.  Otherwise, {\PFApf currentRun} is incremented (greater than or equal to 1 if {\PFAp predicate} evaluated to {\PFAc true}). \item[\PFAc longestRun:] The longest run observed so far; may be equal to {\PFApf currentRun}. \end{description*} \\  & {\it (return value)} \rm & Returns a new record with updated fields: {\PFApf numEvents} is always incremented; {\PFApf numRuns} is incremented if {\PFAp predicate} is {\PFAc true} and {\PFApf currentRun} is zero; {\PFApf currentRun} is incremented if {\PFAp predicate} is {\PFAc true} and set to zero if {\PFAp predicate} is {\PFAc false}; {\PFApf longestRun} is set to {\PFApf currentRun} if {\PFAp predicate} is {\PFAc true} and {\PFApf currentRun} is longer than {\PFApf longestRun}.  If the input {\PFAp history} has fields other than {\PFApf numEvents}, {\PFApf numRuns}, {\PFApf currentRun}, or {\PFApf longestRun}, they are copied unaltered to the output. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any of {\PFApf numEvents}, {\PFApf numRuns}, {\PFApf currentRun}, and {\PFApf longestRun} are less than 0, a ``counter out of range'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.subseqto}{\hypertarget{a.subseqto}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.subseqto":$\!$ [a, start, end, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\  & \PFAc replacement \rm & array of {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new array by replacing {\PFAp a} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive) with {\PFAp replacement}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior. \vspace{0.1 cm} \\ Note: {\PFAp a} is not changed in-place; this is a side-effect-free function.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.flatten}{\hypertarget{a.flatten}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.flatten":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Concatenate the arrays in {\PFAp a}. \vspace{0.2 cm} \\ }}%
    {m.special.lnGamma}{\hypertarget{m.special.lnGamma}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.special.lnGamma":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the natural log of the gamma function of {\PFAp x}. \vspace{0.2 cm} \\ }}%
    {map.filterMapWithKey}{\hypertarget{map.filterMapWithKey}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.filterMapWithKey":$\!$ [m, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function (string, {\PFAtp A}) $\to$ union of \{any {\PFAtp B}, null\} \\  & {\it (returns)} & map of {\PFAtp B} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each key-value pair of {\PFAp m} and return a map of the results that are not {\PFAc null}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on items in {\PFAp m} is not guaranteed, though it will be called exactly once for each value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {/}{\hypertarget{/}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"/":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc y \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Divide {\PFAp y} from {\PFAp x}, returning a floating-point number (even if {\PFAp x} and {\PFAp y} are integers). \vspace{0.2 cm} \\ }}%
    {time.fromLocalToUTC}{\hypertarget{time.fromLocalToUTC}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.fromLocalToUTC":$\!$ [ts, offset]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc offset \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Converts a timestamp specified in UTC via an offset in the local time to the local time. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Timestamp in the local time.  \\  & \PFAc offset \rm & The offset from UTC in the local time.  \\  & {\it (return value)} \rm & A timestamp in UTC. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {metric.absDiff}{\hypertarget{metric.absDiff}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"metric.absDiff":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc y \rm & double \\  & {\it (returns)} & double \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Similarity function (1-dimensional metric) that returns the absolute Euclidean distance between {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ }}%
    {>}{\hypertarget{>}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{">":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is greater than {\PFAp y}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {a.head}{\hypertarget{a.head}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.head":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the first item of the array. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {rand.string}{\hypertarget{rand.string}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"rand.string":$\!$ [size]\} \rm or \PFAc \{"rand.string":$\!$ [size, population]\} \rm or \PFAc \{"rand.string":$\!$ [size, low, high]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc size \rm & int \\ & {\it (returns)} & string \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc size \rm & int \\  & \PFAc population \rm & string \\ & {\it (returns)} & string \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc size \rm & int \\  & \PFAc low \rm & int \\  & \PFAc high \rm & int \\ & {\it (returns)} & string \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random string with {\PFAp size} characters from a range, if provided. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc size \rm & Number of characters in the resulting string.  \\  & \PFAc population \rm & Bag of characters to choose from.  Characters repeated $N$ times in the {\PFAp population} have probability $N$/{\PFAp size}, but order is irrelevant.  \\  & \PFAc low \rm & Minimum code-point to sample (inclusive).  \\  & \PFAc high \rm & Maximum code-point to sample (exclusive).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Without a range, this function samples the entire Unicode table up to and including {\PFAc 0xD800}; ASCII characters are rare. \vspace{0.1 cm} \\ The ASCII printable range is {\PFAp low} = 33, {\PFAp high} = 127.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``size must be positive'' error if {\PFAp size} is less than or equal to zero. \vspace{0.1 cm} \\ Raises a ``high must be greater than low'' error if {\PFAp high} is less than or equal to {\PFAp low}. \vspace{0.1 cm} \\ Raises an ``invalid char'' error if {\PFAp low} is less than 1 or greater than {\PFAc 0xD800} or if {\PFAp high} is less than 1 or greater than {\PFAc 0xD800}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.maxNLT}{\hypertarget{a.maxNLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.maxNLT":$\!$ [a, n, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the {\PFAp n} highest values in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.rotate}{\hypertarget{a.rotate}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.rotate":$\!$ [a, steps]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc steps \rm & int \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array formed by rotating {\PFAp a} left {\PFAp steps} spaces. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp steps} is less than zero, a ``steps out of range'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.cluster.updateMean}{\hypertarget{model.cluster.updateMean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.cluster.updateMean":$\!$ [data, cluster, weight]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc data \rm & array of array of double \\  & \PFAc cluster \rm & any record {\PFAtp C} with \{{\PFApf center:}$\!$ array of double\} \\  & \PFAc weight \rm & double \\  & {\it (returns)} & {\PFAtp C} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update a cluster record by computing the mean of the {\PFAp data} vectors and {\PFAp weight} times the old {\PFAp cluster} center. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp weight} is zero, the new center is equal to the mean of {\PFAp data}, ignoring the old {\PFAp center}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``no data'' error if {\PFAp data} is empty. \vspace{0.1 cm} \\ Raises a ``dimensions of vectors do not match'' error if all elements of {\PFAp data} and the {\PFAp cluster} center do not match.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.intersection}{\hypertarget{map.intersection}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.intersection":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of {\PFAtp A} \\  & {\it (returns)} & map of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the intersection of sets {\PFAp a} and {\PFAp b}, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro. \vspace{0.1 cm} \\ This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.corresponds}{\hypertarget{map.corresponds}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.corresponds":$\!$ [a, b, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of any {\PFAtp B} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp B}) $\to$ boolean \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp fcn} is {\PFAc true} when applied to all pairs of values, one from {\PFAp a} and the other from {\PFAp b} (logical relation). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The number of {\PFAp fcn} calls is not guaranteed. \vspace{0.1 cm} \\ If the key sets of {\PFAp a} and {\PFAp b} are not equal, this function returns {\PFAc false}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {\%\%}{\hypertarget{\%\%}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"\%\%":$\!$ [k, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc k \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc n \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the remainder of {\PFAp k} divided by {\PFAp n}; the result has the same sign as the dividend {\PFAp k}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This is the behavior of the {\PFAc \%} operator in Fortran, C/C++, and Java, {\PFAc rem}/{\PFAc remainder} in Ada, Haskell, and Scheme.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.symdiff}{\hypertarget{a.symdiff}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.symdiff":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array that represents the symmetric difference of {\PFAp a} and {\PFAp b}, treated as sets (ignoring order and duplicates). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The symmetric difference is ({\PFAp a} diff {\PFAp b}) union ({\PFAp b} diff {\PFAp a}).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.secondOfMinute}{\hypertarget{time.secondOfMinute}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.secondOfMinute":$\!$ [ts]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the second of the minute that the timestamp falls within.  Timestamp is assumed to be in UTC. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Timestamp.  \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {re.count}{\hypertarget{re.count}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.count":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Count the number of times {\PFAp pattern} matches in {\PFAp haystack}. \vspace{0.2 cm} \\ }}%
    {bytes.encodeAscii}{\hypertarget{bytes.encodeAscii}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.encodeAscii":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & bytes \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Encode a string as ASCII bytes. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises an ``invalid string'' error if the string cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.count}{\hypertarget{s.count}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.count":$\!$ [haystack, needle]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc needle \rm & string \\  & {\it (returns)} & int \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Count the number of times {\PFAp needle} appears in {\PFAp haystack}. \vspace{0.2 cm} \\ }}%
    {time.isWeekend}{\hypertarget{time.isWeekend}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isWeekend":$\!$ [ts]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Returns True if the timestamp falls on a Saturday or Sunday, False otherwise.  Timestamp is assumed to be in UTC. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Timestamp.  \\  & \PFAc low \rm & Lower boundary of the range.  \\  & \PFAc high \rm & Upper boundary of the range.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``bad time range'' if low $\mathrm{low} \geq \mathrm{high}$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {rand.long}{\hypertarget{rand.long}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"rand.long":$\!$ []\} \rm or \PFAc \{"rand.long":$\!$ [low, high]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & {\it (returns)} & long \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc low \rm & long \\  & \PFAc high \rm & long \\ & {\it (returns)} & long \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random long integer, either on the entire 64-bit range or between {\PFAp low} (inclusive) and {\PFAp high} (exclusive). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises a ``high must be greater than low'' error if {\PFAp high} is less than or equal to {\PFAp low}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.isMinuteOfHour}{\hypertarget{time.isMinuteOfHour}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isMinuteOfHour":$\!$ [ts, low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc low \rm & double \\  & \PFAc high \rm & double \\  & {\it (returns)} & boolean \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Checks if a timestamp falls within a time range, specified in terms of minutes of the hour.  Timestamp is assumed to be in UTC. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Timestamp.  \\  & \PFAc low \rm & Lower boundary of the range.  \\  & \PFAc high \rm & Upper boundary of the range.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Raises ``bad time range'' if low $\mathrm{low} \geq \mathrm{high}$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.sortLT}{\hypertarget{a.sortLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.sortLT":$\!$ [a, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array with the same elements as {\PFAp a} but in ascending order as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp a} is not changed in-place; this is a side-effect-free function.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.filterWithKey}{\hypertarget{map.filterWithKey}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.filterWithKey":$\!$ [m, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function (string, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & map of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each value of {\PFAp m} and return a map of the values for which {\PFAp fcn} returns {\PFAc true} (keys are unchanged). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on items in {\PFAp m} is not guaranteed, though it will be called exactly once for each value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.dropWhile}{\hypertarget{a.dropWhile}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.dropWhile":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to elements of {\PFAp a} and create an array of all elements after the longest prefix that returns {\PFAc true}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Beyond the prefix, the number of {\PFAp fcn} calls is not guaranteed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    }[{\bf FIXME: LaTeX error: wrong libfcn name!}]%
}%
