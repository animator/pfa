\documentclass{article}
\usepackage{fullpage}
\usepackage[]{hyperref}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{xcolor}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}

\newcommand{\PFAc}{\ttfamily\bfseries}
\newcommand{\PFAp}{\ttfamily\bfseries}
\newcommand{\PFAt}{\ttfamily\bfseries}
\newcommand{\PFAtp}{\ttfamily\bfseries}
\newcommand{\PFApf}{\ttfamily\bfseries}
\newcommand{\PFAf}{\ttfamily\bfseries}

\newenvironment{description*}%
  {\vspace{-0.15 cm}\begin{description}%
    \setlength{\itemsep}{3pt}%
    \setlength{\parskip}{0pt}}%
  {\vspace{-0.25 cm}\end{description}}

\newenvironment{allowedfields}%
  {\begin{center} \begin{minipage}{0.9\linewidth} \begin{description}}%
  {\end{description} \end{minipage} \end{center}}

\hypersetup{colorlinks=true, allcolors=blue}

\theoremstyle{definition}
\newtheorem{example}{Example}[section]

\newenvironment{json}{
  \VerbatimEnvironment
  \begin{Verbatim}[xleftmargin=0.5cm,formatcom=\ttfamily\bfseries]}{\end{Verbatim}}

\renewcommand{\arraystretch}{1.4}

\title{PFA: Portable Format for Analytics (version 0.8.1)}
\author{Data Mining Group --- PFA Working Group}
\date{\today}

\input{libfcns}

\setlength{\parskip}{0.15 cm}
\begin{document}
\maketitle

{\large \bf Abstract}
\vspace{0.25 cm}

This specification defines the syntax and semantics of the Portable Format for Analytics (PFA).

PFA is a mini-language for mathematical calculations that is usually generated programmatically, rather than by hand.  A PFA document is a string of JSON-formatted text that describes an executable called a scoring engine.  Each engine has a well-defined input, a well-defined output, and functions for combining inputs to construct the output in an expression-centric syntax tree.  In addition, it has centralized facilities for maintaining state, with well-defined semantics for sharing state among scoring engines in a thread-safe way.  The specification defines a suite of mathematical and statistical functions for transforming data, but it does not define any means of communication with an operating system, file system, or network.  A PFA engine must be embedded in a larger system that has these capabilities, and thus an analytic workflow is decoupled into a part that manages data pipelines (such as Hadoop, Storm, or Akka), and a part that describes the algorithm to be performed on data (PFA).

PFA is similar to the Predictive Model Markup Language (PMML), an XML-based specification for statistical models, but whereas PMML's focus is on statistical models in the abstract, PFA's focus is on the scoring procedure itself.  The same input given to two PFA-enabled systems must yield the same output, regardless of platform (e.g.\ a JVM in Hadoop, a client's web browser, a GPU kernel function, or even an IP core directly embedded in an integrated circuit).  Unlike PMML, the PFA specification defines the exact bit-for-bit behavior of any well-formed document, the semantics of data types and data structures, including behavior in concurrent systems, and all cases in which an exception should be raised.  Like PMML, PFA is a specification, not an implementation, it defines a suite of statistical algorithms for analyzing data, and it is usually generated programmatically, as the output of a machine learning algorithm, for instance.

\vspace{0.5 cm}
{\large \bf Status of this document}
\vspace{0.25 cm}

{\it This section describes the status of this document at the time of the current draft.  Other documents may supersede this document.}

This document is an early draft that has not been endorsed for recommendation by any organization.  It describes a proposed specification that could, in the future, become a standard.

\pagebreak

\tableofcontents

\pagebreak

\section{Introduction}

\subsection{Motivation for PFA}

The Portable Format for Analytics (PFA) is a mini-language for mathematical calculations.  It differs from most programming languages in that it is optimized for automatic code generation, rather than writing programs by hand.  The primary use-case is to represent the output of machine learning algorithms, such that they can be freely moved between systems.  Traditionally, this field has been dominated by special-purpose file formats, each representing only one type of statistical model.  The Predictive Model Markup Language (PMML) provides a means of unifying the most common model types into one file format.  However, PMML can only express a fixed set of pre-defined model types; new model types must be agreed upon by the Data Mining Group (DMG) and integrated into a new version of PMML, then that new version must be adopted by the community before it is widely usable.

PFA represents models and analytic procedures more generally by providing generic programming constructs, such as conditionals, loops, persistent state, and callback functions, in addition to a basic suite of statistical tools.  Conventional models like regression, decision trees, and clustering are expressed by referencing the appropriate library function, just as in PMML, but new models can be expressed by composing library functions or passing user-defined callbacks.  Most new statistical techniques are variants of old techniques, so a small number of functions with the appropriate hooks for inserting user code can represent a wide variety of methods, many of which have not been discovered yet.

Given that flexibility is important, one might consider using a general purpose programming language, such as C, Java, Python, or especially R, which is specifically designed for statistics.  While this is often the easiest method for small problems that are explored, formulated, and solved on an analyst's computer, it is difficult to scale up to network-sized solutions or to deploy on production systems that need to be more carefully controlled than a personal laptop.  The special-purpose code may depend on libraries that cannot be deployed, or may even be hard to identify exhaustively.  In some cases, the custom code might be regarded as a stability or security threat that must be thoroughly reviewed before deployment.  If the analytic algorithm needs to be deployed multiple times before it is satisfactory and each deployment is reviewed for reasons unrelated to its analytic content, development would be delayed unnecessarily.  This problem is solved by decoupling the analytic workflow into a part that deals exclusively with mathematics (the PFA scoring engine) and the rest of the infrastructure (the PFA host).  A mathematical algorithm implemented in PFA can be updated frequently with minimal review, since PFA is incapable of raising most stability or security issues, due to its limited access.

PFA is restricted to the following operations: mathematical functions on numbers, strings, raw bytes, homogeneous lists, homogeneous maps (also known as hash-tables, associative arrays, or dictionaries), heterogeneous records, and unions of the above, where mathematical functions include basic operations, special functions, data structure manipulations, missing data handling, descriptive statistics, and common model types such as regression, decision trees, and clustering, parameterized for flexibility.  PFA does not include any means of accessing the operating system, the file system, or the network, so a rouge PFA engine cannot expose or manipulate data other than that which is intentionally funneled into it by the host system.  The full PFA specification allows recursion and unterminated loops, but execution time is limited by a timeout.  PFA documents may need to be reviewed for mathematical correctness, but they do not need to be reviewed for safety.

Another reason to use PFA as an intermediate model representation is for simplicity of code generation.  A machine learning algorithm generates an executable procedure, usually a simple, parameterized decider algorithm that categorizes or makes predictions based on new data.  Although the parameters might be encoded in a static file, some component must be executable.  A PFA document bundles the executable with its parameters, simplifying version control.

The syntax of PFA is better suited to automatic code generation than most programming languages.  Many languages have complex syntax to accommodate the way people think while programming, including infix operators, a distinction between statements and expressions, and in some cases even meaningful whitespace.  Though useful when writing programs by hand, these features only complicate automatic code generation.  A PFA document is an expression tree rendered in JSON, and trees are easy to programmatically compose into larger trees without introducing syntax errors in the generated code.  This is well-known in the Lisp community, since the ease of writing code-modifying macros in Lisp is often credited to its exclusive use of expression trees, rendered as parenthesized lists (known as S-expressions).  PFA uses JSON, rather than S-expressions, because libraries for manipulating JSON objects are more widely available and JSON provides a convenient syntax for maps, but the transliteration between JSON and S-expressions is straight-forward.

Another benefit of PFA's simplicity relative to general programming languages is that it is more amenable to static analysis.  A PFA host can more thoroughly examine an incoming PFA document for undesirable features.  Although PFA makes use of callback functions to provide generic algorithms, functions are not first-class objects in the language, meaning that they cannot be dynamically assigned to variables.  The identity of every function call can be determined without running the engine, which makes it possible to statically generate a graph of function calls and identify recursive loops.  In very limited runtime environments, such as some GPUs, the compiler implicitly inlines all function calls, so recursion is not possible.  In cases like these, static analysis of the PFA document is a necessary step in generating the executable.

A PFA document can also be statically type-checked.  This allows for faster execution times, since types do not need to be checked at runtime, but it also provides additional safety to the PFA host.

PFA uses Apache Avro schemae for type annotations.  Avro is an open-source serialization protocol, widely used in Hadoop and related projects, whose type schemae are expressed as JSON objects and whose data structures can be expressed as JSON objects.  Therefore, all parts of the PFA engine, including control structures, type annotations, and embedded data are all expressed in one seamless JSON object.  Avro additionally has well-defined rules to resolve different but possibly compatible schemae, which PFA reinterprets as type promotion (allowing integers to be passed to a function that expects floating-point numbers, for instance).  When interpreted this way, Avro also has a type-safe null, which PFA uses to ensure that missing data are always explicitly handled.  Finally, the input and output of every PFA engine can always be readily (de)serialized into Avro's binary format or JSON representation, since Avro libraries are available on a wide variety of platforms.

\subsection{Terminology used in this specification}

Within this specification, the key words ``MUST'', ``MUST NOT'', ``REQUIRED'', ``SHALL'', ``SHALL NOT'', ``SHOULD'', ``SHOULD NOT'', ``RECOMMENDED'', ``MAY'', and ``OPTIONAL'' are to be interpreted as described in RFC 2119 (see \href{http://www.ietf.org/rfc/rfc2119.txt}{RFC2119}).  However, for readability, these words do not appear in all uppercase letters in this specification.

At times, this specification provides hints and suggestions for implementation.  These suggestions are not normative and conformance with this specification does not depend on their realization.  These hints contain the expression ``We suggest\ldots'', ``Specific implementations may\ldots'', or similar wording.

This specification uses the terms ``JSON object'', ``JSON object member name'', ``JSON object member value'', ``JSON array'', ``JSON array value'', ``number'', ``integer'', ``string'', ``boolean'', and ``null'' as defined in the JSON specification (\href{http://tools.ietf.org/html/rfc4627}{RFC-4627}), sections 2.2 through 2.5.  It also references and quotes sections of the Avro 1.7.6 specification (\url{http://avro.apache.org/docs/1.7.6/spec.html}).

\subsection{PFA MIME type and file name extension}

The recommended MIME type for PFA is ``application/pfa+json'', though this is not yet in the process of standardization.

It is recommended that PFA files have the extension ``.pfa'' (all lowercase) on all platforms.  It is recommended that gzip-compressed PFA files have the extension ``.pfaz'' (all lowercase) on all platforms.

\hypertarget{hsec:conformance}{}
\subsection{Levels of PFA conformance and PFA subsets}
\label{sec:conformance}

PFA is a large specification with many modules, so some projects or vendors may wish to implement some but not all of the specification.  However, interoperability is the reason PFA exists; if an implementation does not adhere to the standard, it has limited value.  It is therefore useful to explicitly define what it means for a system to partially implement the standard.

JSON subtrees of a PFA document are interpreted in the following six contexts.
\begin{itemize}
\item Top-level fields are JSON object member name, value pairs in the outermost JSON object of the PFA document.  They have unique member names and describe global aspects of the scoring engine.
\item Special forms are JSON objects that specify executable expressions and function definitions.  Each is associated with a unique name.
\item Library functions are strings that specify routines not defined in the PFA document itself.  Each is associated with a unique name that does not conflict with any of the special forms' names.
\item Avro type schemae are JSON objects and strings that describe data types.  The syntax and meaning of Avro types are specified in \href{http://avro.apache.org/docs/1.7.6/spec.html}{the Avro 1.7.6 specification}.
\item Embedded data are JSON objects, JSON arrays, numbers, integers, strings, booleans, and nulls that describe data structures.  The syntax and meaning of these objects are also defined by Avro, as the format used by the {\PFAc JSONEncoder} and {\PFAc JSONDecoder}.
\item Options are JSON object member values of the {\PFAc options} top-level field and may be overridden by the PFA system.  They all have well-defined defaults and unique, hierarchical names.
\end{itemize}

A system may be partially PFA compliant if it implements some but not all top-level fields, some but not all special forms, or some but not all library functions.  Its coverage may be specified by listing the object member names of the top-level fields that it does implement, the names of the special forms that it does implement, and the names of the library functions that it does implement.  Those top-level fields, special forms, and library functions that it does implement must be completely and correctly implemented.  The coverage is therefore atomic and one can immediately determine if a particular system can execute a particular PFA document by checking the set of names used by the document against the set of names implemented by the system.

Some special forms and library functions make use of some top-level fields.  For example, library functions that generate random numbers use the {\PFAc randseed} field for configuration.  These special forms and library functions cannot be considered implemented unless the corresponding top-level fields are also implemented.  The dependencies are explicitly defined in this specification.

Avro type schemae and JSON-encoded data should be completely implemented, to the extent defined by the Avro specification.  We suggest that implementations use language-specific Avro libraries as much as possible, rather than implementing Avro-related features in a PFA system.

Options may also be implemented atomically by name.  If a named option is not implemented, the system should behave as though that option had its default value, regardless of whether the option is explicitly set in the PFA document.  Options can in general be overridden by a host system, so if a host system doesn't implement an option, it is as though the system enforces the default.

The PFA standard is defined so that a PFA-compliant system can verify that the JSON types of a PFA document are correctly composed (syntax check), verify that the PFA invariants are maintained and Avro data types are correctly composed (semantic check), and impose additional constraints on the set of top-level fields, special forms, and library functions used (optional checks).  A PFA-compliant system should perform the syntax and semantic checks, including all type inference and type checking, though it is not strictly required.  A PFA document that does not satisfy these invariants and type constraints is not valid and its behavior is not defined by this specification.  The third set of checks, however, is completely optional and different systems may apply different constraints on the kinds of scoring engines they are willing to execute.  For instance, an implementation targeting a limited environment in which recursion is not possible may analyze the document and reject it if any recursive loops are found.

This specification does not define any standardized subsets of PFA.  As stated above, partial conformance is defined by ad hoc subsets of atomic units.  However, as experience develops, the community may define industry-standard subsets of PFA for specific purposes or special environments.  Conforming to a standardized subset would provide better interoperability than defining ad hoc subsets, and we would recommend such a standard when it exists.  At present, we can only recommend a carefully chosen ad hoc subset or complete conformance.

\subsection{Updates to the specification}

Updates to the PFA specification are labeled with version numbers. The version numbers have the strict form {\PFAc [1-9][0-9]*\textbackslash.[1-9][0-9]*\textbackslash.[1-9][0-9]*} where the first number is the major release number (major changes to the specification, such as new special forms, behavior, or top-level fields), the second is the minor release number (new features, such as new functions or function signatures), and the third is the bug-fix release number (rectifying errors in intention). Version numbers have a strict lexicographic order. {\bf FIXME: Should the first and second numbers be year and month of release, respectively? In that case, the major revision number would not necessarily imply major changes.}

Any changes in which previously valid PFA becomes invalid must go through a deprecation phase for several versions. When a PFA model uses a deprecated special form, function signature, or top-level field, the PFA implementation should issue a warning but accept the model until the cut-off version.

Changes in which previously invalid PFA becomes valid can become effective immediately.

Other backward-incompatible changes, such as valid PFA changing its behavior, are not allowed. New behaviors must introduce new function names, function signatures, special form structures, or top-level field names and deprecate the old ones.

\subsection{Open-source implementations}

The following open-source implementations can help clarify this specification.
\begin{description}
\item[Hadrian:] A PFA system written in Scala for the Java Virtual Machine (JVM).  It performs all necessary checks and dynamically compiles PFA documents into JVM bytecode for fast execution. Available from \url{https://github.com/opendatagroup/hadrian}.
\item[Titus:] A PFA system written in Python.  It performs all necessary checks, interprets PFA documents for testing, and transforms Python-based machine learning outputs into PFA. Available from \url{https://github.com/opendatagroup/hadrian}.
\end{description}

Although these implementations can help clarify the intent of the specification for future implementations, they are not normative definitions of the standard.  Only this document (and those that may supersede it) are normative.  All versions of this document, including the latest version, can be found on the websites listed above.

If you have a PFA implementation that you would like to see listed here, send an e-mail to \url{info@dmg.org}.

\pagebreak

\section{PFA document structure}

\subsection{Top-level fields}

A PFA document is a serialized JSON object representing an executable scoring engine.  Only the following JSON object member names may appear at this JSON nesting level.  These are the top-level fields referred to in the \hyperlink{hsec:conformance}{conformance section} of this specification.  Three fields, {\PFAc action}, {\PFAc input}, and {\PFAc output}, are required for every PFA document and are therefore required for every PFA implementation.  The rest are optional for PFA documents and not strictly required for PFA implementations.  As explained in the conformance section, not implementing some top-level fields can make some special forms and functions unimplementable.

\begin{allowedfields}
\item[\PFAc name:] A string used to identify the scoring engine.
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc method:] A string that may be ``map'', ``emit'', or ``fold'' (\hyperlink{hsec:method}{see Sec.~\ref{sec:method}}).  If absent, the default value is ``map''.
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc input:] An Avro schema representing the data type of data provided to the scoring engine (\hyperlink{hsec:input-output}{see Sec.~\ref{sec:input-output}}).
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc output:] An Avro schema representing the data type of data produced by the scoring engine (\hyperlink{hsec:input-output}{see Sec.~\ref{sec:input-output}}).  The way that output is returned to the host system depends on the {\PFAc method}.
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc begin:] An \hyperlink{hsec:expressions}{expression} or JSON array of \hyperlink{hsec:expressions}{expressions} that are executed in the begin phase of the scoring engine's run (\hyperlink{hsec:phases}{see Sec.~\ref{sec:phases}}).
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc action:] An \hyperlink{hsec:expressions}{expression} or JSON array of \hyperlink{hsec:expressions}{expressions} that are executed for each input datum in the active phase of the scoring engine's run (\hyperlink{hsec:phases}{see Sec.~\ref{sec:phases}}).
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc end:] An \hyperlink{hsec:expressions}{expression} or JSON array of \hyperlink{hsec:expressions}{expressions} that are executed in the end phase of the scoring engine's run (\hyperlink{hsec:phases}{see Sec.~\ref{sec:phases}}).
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc fcns:] A JSON object whose member values are \hyperlink{hsec:fcndef}{function definitions}, defining routines that may be called by expressions in {\PFAc begin}, {\PFAc action}, {\PFAc end}, or by expressions in other functions.
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc zero:] Embedded JSON data whose type must match the {\PFAc output} type of the engine.  This must be present in the ``fold'' {\PFAc method} initialize the fold aggregation, and it must not be present in the ``map'' or ``emit'' {\PFAc method}.
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc merge:] An \hyperlink{hsec:expressions}{expression} or JSON array of \hyperlink{hsec:expressions}{expressions} that may be executed if the scoring engine container needs to combine partial results from independent ``fold'' engines.  It must be present with the ``fold'' {\PFAc method} and it must not be present with the ``map'' or ``emit'' {\PFAc method}.
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc cells:] A JSON object whose member values specify statically allocated, named, typed units of persistent state or embedded data (\hyperlink{hsec:state}{see Sec.~\ref{sec:state}}).  The format of this JSON object is restricted: \hyperlink{hsec:cells-pools}{see Sec.~\ref{sec:cells-pools}}.
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc pools:] A JSON object whose member values specify dynamically allocated namespaces of typed persistent state (\hyperlink{hsec:state}{see Sec.~\ref{sec:state}}).  The format of this JSON object is restricted: \hyperlink{hsec:cells-pools}{see Sec.~\ref{sec:cells-pools}}.
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc randseed:] An integer which, if present, sets the seed for pseudorandom number generation (\hyperlink{hsec:method}{see Sec.~\ref{sec:random}}).
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc doc:] A string used to describe the scoring engine or its provenance (has no effect on calculations).
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc version:] An optional integer to use in model-version bookkeeping.
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc metadata:] A JSON object mapping strings to strings; used to describe the scoring engine or its provenance.
\end{allowedfields}
\begin{allowedfields}
\item[\PFAc options:] A JSON object of JSON objects, arrays, strings, numbers, booleans, or nulls used to control execution.
\end{allowedfields}

\noindent \begin{minipage}{\linewidth}
\begin{example}
This is the simplest possible PFA document.  It only reads {\PFAc null} values, returns {\PFAc null} values, and performs no calculations.
\begin{json}
{"input": "null", "output": "null", "action": null}
\end{json}
\end{example}
\end{minipage}

\begin{example}
This is a simple yet non-degenerate PFA document.  It increments numerical input by 1.
\begin{json}
{"input": "double", "output": "double", "action": {"+": ["input", 1]}}
\end{json}
\end{example}

\begin{example}
This example implements a small decision tree.  Input data are records with three fields: ``one'' (integer), ``two'' (double), and ``three'' (string).  The decision tree is stored in a cell named ``tree'' with type ``TreeNode''.  The tree has three binary splits (four leaves).  The scoring engine walks from the root to a leaf for each input datum, choosing a path based on values found in the record's fields, and returns the string it finds at the tree's leaf.  (See the definitions of the \hyperlink{model.tree.simpleWalk}{model.tree.simpleWalk} and \hyperlink{model.tree.simpleTest}{model.tree.simpleTest} functions.)
\begin{json}
{"input": {"type": "record", "name": "Datum", "fields":
   [{"name": "one", "type": "int"},
    {"name": "two", "type": "double"},
    {"name": "three", "type": "string"}]},
 "output": "string",
 "cells": {"tree":
             {"type":
               {"type": "record",
                "name": "TreeNode",
                "fields": [
                  {"name": "field", "type":
                    {"type": "enum", "name": "TreeFields", "symbols":
                      ["one", "two", "three"]}}
                  {"name": "operator", "type": "string"},
                  {"name": "value", "type": ["double", "string"]},
                  {"name": "pass", "type": ["string", "TreeNode"]},
                  {"name": "fail", "type": ["string", "TreeNode"]}]},
              "init":
                {"field": "one",
                 "operator": "<",
                 "value": {"double": 12},
                 "pass":
                   {"TreeNode":
                     {"field": "two",
                      "operator": ">",
                      "value": {"double": 3.5},
                      "pass": {"string": "yes-yes"},
                      "fail": {"string": "yes-no"}}},
                 "fail":
                   {"TreeNode":
                     {"field": "three",
                      "operator": "==",
                      "value": {"string": "TEST"},
                      "pass": {"string": "no-yes"},
                      "fail": {"string": "no-no"}}}}}},
\end{json}
\begin{json}
 "action":
   {"model.tree.simpleWalk": [
     "input",
     {"cell": "tree"},
     {"params": [{"d": "Datum"}, {"t": "TreeNode"}],
      "ret": "boolean",
      "do": {"model.tree.simpleTest": ["d", "t"]}}
   ]}}
\end{json}
\end{example}

\hypertarget{hsec:cells-pools}{}
\subsection{Cells and Pools}
\label{sec:cells-pools}

The {\PFAc cells} and {\PFAc pools} top-level fields, if present, are JSON objects whose member values are cell-specifications or pool-specifications, respectively.  A cell is a mutable, global data store that holds a single value with a specific type, and a pool is a mutable map from dynamically allocated names to values of a specific type (\hyperlink{hsec:state}{see Sec.~\ref{sec:state}}).

A cell-specification is a JSON object with the following fields.
\begin{allowedfields}
\item[\PFAc type:] {\it (required)} An Avro schema representing the data type of this cell.
\item[\PFAc init:] {\it (required)} If {\PFAc source} (below) is ``embedded'' or not provided, then this is the initial value of the cell as embedded JSON, matching {\PFAc type}. If {\PFAc source} is ``json'' or ``avro'', this is a file name or URL pointing to the initial value of the cell. The file name may be relative or absolute and is formatted for the target operating system (e.g. UNIX-formatted with forward slashes or Windows-formatted with backslashes). It is interpreted as a URL if the whole string matches the following pattern: {\PFAc [a-zA-Z][a-zA-Z0-9\textbackslash+\textbackslash-\textbackslash.]*://.*} (the first character is a letter, followed by letters or plus, hyphen, or dot, followed by colon-slash-slash and arbitrary text until the end of the string).
\item[\PFAc shared:] An optional boolean specifying whether this cell is thread-local to one scoring engine or shared among a battery of similar engines (\hyperlink{hsec:concurrent}{see Sec.~\ref{sec:concurrent}}).  The default is {\PFAc false}.
\item[\PFAc rollback:] An optional boolean specifying whether this cell should be rolled back to the state it had at the beginning of an {\PFAc action} if an \hyperlink{hsec:exceptions}{exception} occurs during the {\PFAc action}.  The default is {\PFAc false}, and {\PFAc shared} and {\PFAc rollback} are mutually incompatible: they cannot both be {\PFAc true}.
\item[\PFAc source:] An optional string specifying whether the {\PFAc init} data is ``embedded'' (the default), ``json'' (formatted exactly like ``embedded'', but in an external file or resource), or ``avro'' (Avro formatted in an external file or resource). The data, once retrieved, must have a type that matches {\PFAc type}.
\end{allowedfields}

A pool-specification is a JSON object with the following fields.
\begin{allowedfields}
\item[\PFAc type:] {\it (required)} An Avro schema representing the data type of an item within this pool. The whole pool is effectively a map of this type.
\item[\PFAc init:] Same as {\PFAc init} for cells, but it is not required for pools. If omitted, a value of \PFAc{\{\}} is assumed.
\item[\PFAc shared:] Same as {\PFAc shared} for cells.
\item[\PFAc rollback:] Same as {\PFAc rollback} for cells.
\item[\PFAc source:] Same as {\PFAc source} for cells.
\end{allowedfields}

Cell and pool names must match the following pattern: {\PFAc [A-Za-z\_][A-Za-z0-9\_]*} (the first character must be a letter or underscore; subsequent characters, if they exist, may also be numbers).  Cells and pools do not share a namespace with each other or with symbols or functions.

A complete explanation of cells and pools is given in \hyperlink{hsec:state}{Sec.~\ref{sec:state}}.

\subsection{Locator marks}

PFA documents are usually generated by an automated process, such as by encoding a machine learning decider into a scoring engine or by transforming user functions from an easily readable language into the terse PFA representation.  In the latter case, there can be a cognitive disconnect between the language in which the user writes code, for instance a regression fit function written in Python, and the auto-generated PFA.  In particular, if there is an error in the generated PFA due to an error in the original source code, reporting the error at the line and column number of the generated PFA would not be useful for the Python programmer.  It would be much better if a PFA system could report such an error at the location of the offending line in the original source code.

To allow individual PFA systems to do this, the PFA specification allows for ``@'' as a JSON member name in any JSON object in the PFA document.  The associated member value must be a string, and would ordinarily be a description of the line number of the original source that generated that JSON object in the PFA document.  These ``@'' key-value pairs can appear in any object at any level, including Avro type schemae and embedded JSON data.  If the library that interprets Avro type schemae and embedded JSON data does not ignore object members named ``@'', then the PFA system must strip these objects before passing the JSON objects for interpretation.

The generation of and meaning of these locator marks are beyond the scope of the PFA specification--- different PFA systems can generate and interpret them differently, or not at all.  However, to ensure that the locator marks made by one system do not cause unnecessary errors in another system, the locator marks must abide by the following rules.
\begin{itemize}
\item JSON object members named ``@'' must not cause errors in any PFA system, even if they appear in Avro type schemae or embedded JSON objects.
\item The value associated with this key must be a string.
\item The system that generates these marks should place them at the beginning of each JSON object--- that is, in the serialized form of the JSON data, the ``@'' member name should appear immediately after the ``\{`` character that starts the JSON object (apart from any whitespace).  This is because some PFA readers may interpret the JSON data as it streams into a buffer, and they may encounter an error before reaching the last JSON object member.  If the locator mark is not first, PFA systems cannot be expected to use it.
\end{itemize}

\pagebreak

\section{Scoring engine execution model}

A PFA document (string of JSON-formatted text) describes a PFA scoring engine (executable routine) or a battery of initially identical engines.  An engine behaves as a single-threaded executable with global state (cells and pools) and local variables.  A battery of scoring engines may run in parallel and only share data if some cells or pools are explicitly marked as {\PFAc shared}.  Although a battery of scoring engines generated by a single PFA document start in exactly the same state, they may evolve into different states if they have any unshared cells or pools.

PFA engines are units of work that may fit into a pipeline system like Hadoop, Storm, or Akka.  In a map-reduce framework such as Hadoop, for instance, one PFA document could describe the calculation performed by all of the mappers and another could describe the calculation performed by all of the reducers.  The mappers are a battery of independent PFA engines, as are the reducers.  In pure map-reduce, the mappers would not communicate with each other and the reducers would not communicate with each other, so none of the cells or pools should be marked as {\PFAc shared}.  With this separation of concerns, issues of transferring data, interpreting input file types, and formatting output should be handled by the pipeline system (Hadoop in this case) while the mathematical procedure is handled by PFA.  Changing file formats would require an update to the pipeline code (and possibly a code review), but changing details of the analytic would only require a new PFA document (a JSON configuration file).

\hypertarget{hsec:phases}{}
\subsection{Execution phases of a PFA scoring engine}
\label{sec:phases}

A PFA engine has a 7 phase lifecycle.  These phases are the following, executed in this order:

\begin{enumerate}
\item reading the PFA document and performing a syntax check;
\item verifying PFA invariants and checking type consistency;
\item additional checks, constraints required by a particular PFA system;
\item initialization of the engine;
\item execution of the {\PFAc begin} routine;
\item execution of the {\PFAc action} routine for each input datum;
\item execution of the {\PFAc end} routine.
\end{enumerate}

In phase 1, JSON is decoded and may be used to build an abstract syntax tree of the whole document.  At this stage, JSON types must be correctly matched (e.g.\ if a number is expected, a string cannot be provided instead) to build the syntax tree.  Incorrectly formatted JSON should also be rejected, though we recommend that a dedicated JSON decoder is used for this task.  Avro schemae should also be interpreted in this phase (see \hyperlink{hsec:avro-types}{Sec.~\ref{sec:avro-types}}).

In phase 2, the loaded PFA document is interpreted as an executable.  If the specific PFA implementation builds code with macros, compiles bytecode, or synthesizes a circuit for execution, that work should happen in this phase.  Data types should be inferred and checked (see \hyperlink{hsec:type-inference}{Sec.~\ref{sec:type-inference}}), especially if the executable is compiled.

Phase 3 is provided for optional checks.  Due to limitations of a particular environment, some PFA systems may need to be more restrictive than the general specification and reject what would otherwise be a valid PFA document.  Reasons include unimplemented function calls, inability to implement recursion, or data structures that are too large.  The phase 3 checks may need to be performed concurrently with the phase 2 checks to build the executable.

Phase 4, initialization, is when data structures such as cells and pools are allocated and filled, network connections are established (if relevant for a particular PFA implementation), pseudorandom number generators are seeded, etc.  These are actions that the engine must perform to work properly but are not a part of the {\PFAc begin}, {\PFAc action}, or {\PFAc end} routines.

The actions performed in the last three phases, {\PFAc begin}, {\PFAc action}, and {\PFAc end}, are explicitly defined in the PFA document.  A PFA system must implement the {\PFAc action} phase, since every PFA document must define an {\PFAc action}.  The {\PFAc action} accepts input and returns output, though the way it does so depends on the {\PFAc method} (\hyperlink{hsec:method}{Sec.~\ref{sec:method}}).

The {\PFAc begin} and {\PFAc end} phases do not accept input and do not return output: they can only modify cells and pools, emit log messages, or raise exceptions.  A PFA system is not required to implement {\PFAc begin} and {\PFAc end}.  If a system that does not implement {\PFAc begin} encounters a document that has a {\PFAc begin} routine, it must fail with an error.  If a system that does not implement {\PFAc end} encounters a document that has an {\PFAc end} routine, it need not fail with an error, though it may.  This is because some PFA documents may use {\PFAc begin} to initialize essential data structures and the {\PFAc action} would only function properly if {\PFAc begin} has been executed, but the {\PFAc end} routine can only affect the state of a completed scoring engine whose interpretation is implementation-specific.  Moreover, some data pipelines do not even have a concept of completion, such as Storm.

After all input data have been passed to the scoring engine and the last {\PFAc action} or {\PFAc end} routine has finished, the scoring engine is said to be completed.  This may be considered an eighth phase of the engine, though its behavior at this point is not defined by this specification.  A particular PFA system may extract aggregated results from a completed engine's state and it may even call functions defined in the document's {\PFAc fcn} field, but this is beyond the scope of the standard PFA lifecycle.  (Note: if the primary purpose of a scoring engine is to aggregate data, consider using the ``fold'' {\PFAc method} instead of extracting from the engine's internal state.)

A completed scoring engine may be used to create a new PFA document, in which the final state of the cells and pools are used to define the {\PFAc cell} {\PFAc init} or {\PFAc pool} {\PFAc init} of the new document, such that a new scoring engine would start where the old one left off.  A PFA system may even re-use an old scoring engine as a new scoring engine (repeating phase 4 onward), but a re-used engine must behave exactly like a new engine with copied state, such that the re-use is an implementation detail and does not affect behavior.

A PFA system may call functions defined in the document's {\PFAc fcn} field at any time after phase 4 is complete.  A PFA system must not execute {\PFAc begin}, {\PFAc action}, or {\PFAc end} outside of its lifecycle.

\hypertarget{hsec:method}{}
\subsection{Scoring method: map, emit, and fold}
\label{sec:method}

PFA defines the following three methods for calling the {\PFAc action} routine of a scoring engine.
\begin{allowedfields}
\item[``map'':] The {\PFAc action} routine is given an {\PFAc input} value, which it uses to construct and return an output.  Barring \hyperlink{hsec:exceptions}{exceptions}, the output dataset would have exactly as many values as the input dataset.
\end{allowedfields}
\begin{allowedfields}
\item[``emit'':] The {\PFAc action} routine is given an {\PFAc input} value and an {\PFAc emit} callback function, and the functional return value is ignored.  The scoring engine returns results to the host system by calling {\PFAc emit}.  It can call {\PFAc emit} any number of times, and thus the output dataset may be smaller or larger than the input dataset.  For example, a filter would call {\PFAc emit} zero or one times for each input.
\end{allowedfields}
\begin{allowedfields}
\item[``fold'':] The {\PFAc action} routine is given an {\PFAc input} value and a {\PFAc tally} value, which it uses to construct and return an output.  The first time {\PFAc action} is invoked, {\PFAc tally} is equal to {\PFAc zero} (the top-level field).  On the $N^{\mbox{\scriptsize th}}$ time {\PFAc action} is invoked, {\PFAc tally} is equal to the $(N - 1)^{\mbox{\scriptsize th}}$ return value.  Thus, a ``fold'' scoring engine is an aggregator: transformed inputs may be counted, summed, maximized, or otherwise accumulated in the {\PFAc tally}.  The aggregate of the entire dataset seen by one scoring engine instance is the last return value of {\PFAc action}.  The host system may then combine partial results from these instances using the {\PFAc merge} method.  The {\PFAc merge} method must be present for ``fold'' scoring engines, though it might not be used.
\end{allowedfields}

For all three methods, the {\PFAc input} is available to expressions as a read-only symbol that can be accessed in an expression as the JSON string {\PFAc "input"} (see \hyperlink{hsec:symbol-ref}{Sec.~\ref{sec:symbol-ref}}).  The {\PFAc input} symbol's scope is limited to the {\PFAc action} routine: it is not accessible in user-defined functions unless explicitly passed.  The {\PFAc input} symbol's data type is specified by the top-level field named {\PFAc input}.

For the ``map'' and ``fold'' methods, the data type of the last expression in the {\PFAc action} routine must be the type specified by the top-level field named {\PFAc output}.  For the ``emit'' method, there is no constraint on the type of the last expression in {\PFAc action}, but the argument passed to the {\PFAc emit} function must have {\PFAc output} type.

For the ``emit'' method, the {\PFAc emit} function is a globally accessible function.  It may be \hyperlink{hsec:function-call}{called} or \hyperlink{hsec:fcnref}{referenced} without qualification by any user-defined function or even in the {\PFAc begin} and {\PFAc end} routines.

For the ``fold'' method, the {\PFAc tally} is available to expressions as a read-only symbol that can be accessed in an expression as the JSON string {\PFAc "tally"} (see \hyperlink{hsec:symbol-ref}{Sec.~\ref{sec:symbol-ref}}).  The {\PFAc tally} symbol's scope is limited to the {\PFAc action} routine: it is not accessible in user-defined functions unless explicitly passed.  The {\PFAc tally} symbol's data type is specified by the {\PFAc output} top-level field.  The top-level field named {\PFAc zero} must also have {\PFAc output} type.

In the {\PFAc merge} method, available only to ``fold'' engines, the symbols {\PFAc tallyOne} and {\PFAc tallyTwo} are read-only symbols that can be accessed in the expression.  They have {\PFAc output} type, and usually come from independent runs of the scoring engine on subsamples.  Just as calling a scoring engine's {\PFAc action} method replaces its {\PFAc tally} with the {\PFAc action} output, calling a scoring engine's {\PFAc merge} method replaces its {\PFAc tally} with the {\PFAc merge} result.

The means by which input values are provided to the scoring engine, output values are retrieved, and the {\PFAc emit} function is set or changed are all unspecified.  A PFA system may change the {\PFAc emit} function at any time, even while an {\PFAc action} is being processed (though we do not recommend this).  However, the {\PFAc emit} function must be defined and callable at all times during the {\PFAc begin}, {\PFAc action}, and {\PFAc end} phases of the scoring engine's lifecycle.

\hypertarget{hsec:predefs}{}
\subsection{Predefined symbols}
\label{sec:predefs}

A small set of symbols are already defined when a {\PFAc begin}, {\PFAc action}, or {\PFAc end} method starts.  These symbols cannot be changed by the method; it is as though the method is executed in a sealed scope within the scope in which the predefined symbols are defined (\hyperlink{hsec:symbol-scope}{see Sec.~\ref{sec:symbol-scope}}).

\noindent The predefined symbols in the {\PFAc begin} method are the following.
\begin{itemize}
\item {\PFAc name} (string): If the {\PFAc name} top-level field is present, this is that string; otherwise, it is the name that the host system has assigned.
\item {\PFAc instance} (int): The 0-based instance number of the scoring engine.  For example, if $N$ engines are generated from a PFA document, they will be numbered from $0$ to $N-1$, inclusive.
\item {\PFAc version} (int): If the {\PFAc version} top-level field is present, this symbol is defined and is equal to the top-level field; otherwise, it is not defined.
\item {\PFAc metadata} (map of string): If the {\PFAc metadata} top-level field is present, this symbol is that string-to-string map; otherwise, it is an empty string-to-string map.
\end{itemize}

\noindent The predefined symbols in the {\PFAc action} method are the following.
\begin{itemize}
\item {\PFAc input} (type defined by top-level field {\PFAc input}): The input datum on which the {\PFAc action} method acts.
\item {\PFAc tally} (type defined by top-level field {\PFAc output}): If the {\PFAc method} is ``fold'', this is the result of applying all actions to date for this scoring engine instance; otherwise, it is not defined.
\item {\PFAc name}, {\PFAc instance}, {\PFAc version}, {\PFAc metadata}: As above.
\item {\PFAc actionsStarted} (long): The number of times this scoring engine instance has {\it started} to process an input record.  It is always greater than or equal to 1 and it includes action attempts that have failed due to exceptions.
\item {\PFAc actionsFinished} (long): The number of times this scoring engine instance has {\it successfully finished} processing an input record.  It is always greater than or equal to 0 and it does not include action attempts that have failed due to exceptions.
\end{itemize}

\noindent The predefined symbols in the {\PFAc end} method are the following.
\begin{itemize}
\item {\PFAc tally}, {\PFAc name}, {\PFAc instance}, {\PFAc version}, {\PFAc metadata}, {\PFAc actionsStarted}, {\PFAc actionsFinished}: As above.
\end{itemize}

\hypertarget{hsec:input-output}{}
\subsection{Input and output type specification}
\label{sec:input-output}

The member values of the top-level fields {\PFAc input} and {\PFAc output} are Avro schemae (see \hyperlink{hsec:avro-types}{Sec.~\ref{sec:avro-types}}).  The way that these types constrain the input and output of scoring engines depends on the {\PFAc method} and is described in \hyperlink{hsec:method}{Sec.~\ref{sec:method}}.

The input data provided to the scoring engine must conform to the {\PFAc input} type in the sense that there must be an unambiguous way to generate it from Avro-encoded data, though this conversion need not actually take place.  For example, if the {\PFAc input} is {\PFAc \{"type":$\!$ "array", "items":$\!$ "int"\}}, then the values passed to the scoring engine must be ordered lists of integers, though they may be implemented as arrays, linked lists, immutable vectors, or any other functionally equivalent data structure that the PFA implementation is capable of using in calculations.  The data source need not be Avro-encoded; the Avro schema is only used to specify the type, not to perform conversions.  Similarly, the output data must conform to the {\PFAc output} type in the sense that there must be an unambiguous way to convert it to Avro-encoded data, though this conversion need not actually take place.

Given that the input and output types are described by Avro schemae, the Avro binary and JSON data formats would be particularly convenient ways to read and write data.  However, there is no requirement that a PFA system should have this capability.  Data conversion and internal data format are both outside the scope of the PFA specification.

\hypertarget{hsec:state}{}
\subsection{Persistent state: cells and pools}
\label{sec:state}

PFA defines two mechanisms to maintain state: cells and pools.  Cells are global variables with a fixed name and type that must be initialized before the scoring engine's run begins.  A cell's value can change to a new value of the same type, but the cell cannot be deleted and new cells cannot be created during the scoring engine's run.  Pools are global namespaces with a fixed type.  New named values can be created within a pool at runtime, as long as they have the correct type, and old values can be deleted at runtime.

A pool of type ``{\PFAtp X}'' would be equivalent to a cell whose type is ``map of {\PFAtp X}'' except for performance and concurrency issues.  All special forms and library functions in the PFA specification treat data structures as immutable objects (\hyperlink{hsec:immutable}{see Sec.~\ref{sec:immutable}}), but scoring engines often need to maintain very large key-value tables.  If pools were not available, a PFA implementation would either incur a performance penalty if it maintained a large map in a cell as an immutable object or if it maintained all temporary variables as mutable objects.  With both cells and pools, a PFA implementation may maintain all values as immutable objects, including cells, and maintain pools as mutable maps of immutable objects.  \hyperlink{hsec:concurrent}{See Sec.~\ref{sec:concurrent}} for a discussion of concurrency issues in cells and pools.

Cells can only be accessed through the ``cell'' special form and can only be modified through the ``cell-to'' special form.  Pools can only be accessed through the ``pool'' special form and modified through the ``pool-to'' and ``pool-del'' special forms (\hyperlink{hsec:cell-pool-forms}{see Sec.~\ref{sec:cell-pool-forms}}).

One common use of persistent state is to represent a complex statistical model, such as a large decision tree.  In most cases, such a model is constant during the scoring engine's run, and this constraint may be enforced through static analysis if the model is stored in a cell.  Another common use is to represent recent or accumulated data in a table, indexed by key.  In most cases, this table is updated frequently and new table entries may be added at any time.  Furthermore, it is often useful to distribute the table-fill operation among a battery of concurrent scoring engines, with different engines modifying different keys at the same time.  These cases are more easily implemented as pools or shared pools.

\hypertarget{hsec:concurrent}{}
\subsection{Concurrent access to shared state}
\label{sec:concurrent}

If the {\PFAc shared} member of a cell or pool's specification is {\PFAc true}, the cell or pool is not assumed to be thread-local (\hyperlink{hsec:cells-pools}{see Sec.~\ref{sec:cells-pools}}).  It may be shared among a battery of identical scoring engines in a multi-threaded process, shared among identical scoring engines distributed across a network, shared in a database among different types of processes, or shared among components of an integrated circuit, etc.  In any case, some rules must be followed to avoid simultaneous attempts to modify the data, and these rules must be standardized to ensure that the same scoring engine has the same behavior on different systems.

Shared cells and pools in PFA follow a read-copy-update rule for concurrent access: attempts to read the shared resource (through the ``cell'' or ``pool'' special forms) always succeed without blocking and attempts to write (through the ``cell-to'', ``pool-to'', and ``pool-del'' special forms) lock the resource or wait until another writer's lock is released.  The writers must operate on a copy of the cell or pool's data (or on immutable data) so that readers can access the old version during the update process.  The new value must be updated atomically at the end of the update process.

Although an update operation may only modify a part of the cell's structure (one value in an array, for instance), the granularity of the writers' lock is the entire cell: two writers must not be able to modify different parts of the same cell at the same time.  The granularity of the writers' lock on pools is limited to a single named entity within the pool: two writers must be able to modify different entities in the pool at the same time, but not different parts of the same named entity.

The ``cell-to'' and ``pool-to'' special forms accept user-defined update functions (\hyperlink{hsec:cell-pool-forms}{see Sec.~\ref{sec:cell-pool-forms}}) but these functions must not directly or indirectly call ``cell-to'', ``pool-to'', or ``pool-del'' because such a situation could lead to deadlock.  This rule can be enforced by examining the call graph.

\hypertarget{hsec:exceptions}{}
\subsection{Exceptions}
\label{sec:exceptions}

As much as is reasonably possible, PFA documents can be statically analyzed to avoid errors at runtime.  However, some error states cannot be predicted without runtime information.  These error states, their exact messages, and numerical codes are explicitly defined for each susceptible special form and library function.  If the specified error conditions are met in the {\PFAc begin} routine of a scoring engine, processing stops and should not continue to the {\PFAc action} routine.  If error conditions occur when the {\PFAc action} routine is processing an input datum, processing of that datum stops and may either continue to the next datum or stop the scoring engine entirely.  The PFA host may choose to stop or continue on the basis of the error message or code.  If error conditions occur in the {\PFAc end} routine, processing stops.

This abrupt end of processing may occur deep in an \hyperlink{hsec:expressions}{expression} or array of \hyperlink{hsec:expressions}{expressions} and behaves like an exception: control flow exits the routine immediately upon encountering the error condition and is either caught by the host system or it halts the process.  In environments where this is difficult to implement, control flow may continue to the end of the routine, but side-effects such as modifications to persistent state and \hyperlink{hsec:logs}{log messages} must be avoided.

If the host system catches an exception in {\PFAc action} and continues to the next datum, and if a cell or pool's {\PFAc rollback} member is {\PFAc true}, then that cell or pool should be reverted to the value that it had at the beginning of the {\PFAc action} (\hyperlink{hsec:cells-pools}{see Sec.~\ref{sec:cells-pools}}).  If the {\PFAc rollback} member is absent or {\PFAc false}, then the cell or pool's value at the start of the next {\PFAc action} should be the value it had at the time of the exception.

In addition to exceptions raised by special forms and library functions, a PFA document can raise custom exceptions with the ``error'' special form (\hyperlink{hsec:exception-form}{see Sec.~\ref{sec:exception-form}}).  The rules described above apply equally to custom exceptions, though we recommend that PFA systems differentiate between built-in exceptions (whose error messages are explicitly defined by this specification) and custom exceptions (whose error messages are free-form).  Code numbers for user-defined errors must be negative.

If a {\PFAc timeout} is defined in the PFA document's {\PFAc options} or is imposed by the PFA system, a {\PFAc begin}, {\PFAc action}, or {\PFAc end} routine that exceeds this timeout raises an exception with the message ``exceeded timeout of $N$ milliseconds'' where $N$ is the relevant timeout.  Timeout exceptions follow the same rules as built-in and custom exceptions.

If possible in a given system, no exceptions other than PFA exceptions should ever be raised while executing a {\PFAc begin}, {\PFAc action}, or {\PFAc end} routine.

\hypertarget{hsec:options}{}
\subsection{Execution options}
\label{sec:options}

The {\PFAc options} top-level field allows PFA documents to request that they are executed in a particular way.  However, the PFA system may override any of these options with its own values, or with the defaults.  When overriding an option, the PFA system should somehow indicate that this is the case, possibly through a log message.

Example options, their JSON types, and their default values are given below.  If a PFA document attempts to set an option with the wrong type, it is a semantic error (phase 2 in \hyperlink{hsec:phases}{see Sec.~\ref{sec:phases}}) and the scoring engine should not be started. Unrecognized options are ignored.

\noindent\begin{longtable}{p{0.23\linewidth} p{0.12\linewidth} p{0.14\linewidth} p{0.4\linewidth}}
{\bf Option name} & {\bf JSON type} & {\bf Default value} & {\bf Description} \\\hline\endhead
{\PFAc timeout} & integer & $-1$ & Number of milliseconds to let the {\PFAc begin}, {\PFAc action}, or {\PFAc end} routine run; at or after this time, the PFA system may stop the routine with an exception (\hyperlink{hsec:exceptions}{see Sec.~\ref{sec:exceptions}}).  If negative, the execution has no timeout. \\
{\PFAc timeout.begin} & integer & {\PFAc timeout} & A specific timeout for the {\PFAc begin} routine that overrides the general {\PFAc timeout}. \\
{\PFAc timeout.action} & integer & {\PFAc timeout} & A specific timeout for the {\PFAc action} routine that overrides the general {\PFAc timeout}. \\
{\PFAc timeout.end} & integer & {\PFAc timeout} & A specific timeout for the {\PFAc end} routine that overrides the general {\PFAc timeout}. \\
\end{longtable}

\hypertarget{hsec:random}{}
\subsection{Pseudorandom number management}
\label{sec:random}

The {\PFAc randseed} top-level field specifies a seed for library functions that generate pseudorandom numbers.  If the {\PFAc randseed} is absent, the random number generator should be unpredictable: multiple runs of the same PFA document would yield different results if the output depends on pseudorandom numbers.  If a {\PFAc randseed} is provided, the random number generator should be predictable: multiple runs of the same PFA document would yield the same results on the same system.  Explicitly setting a {\PFAc randseed} is useful for tests.

The pseudorandom number generator maintains state between {\PFAc begin}, {\PFAc action}, and {\PFAc end} invocations: the generator is not reseeded with each call.  If a PFA document is used to create a battery of identical scoring engines, the {\PFAc randseed} is used to generate different seeds for all of the scoring engines: they are not guaranteed to produce identical results.

The algorithm for generating pseudorandom numbers is not specified, so different PFA implementations may use different algorithms.  Therefore, a PFA document with an explicit {\PFAc randseed} is only guaranteed to yield identical results when rerun on the same system.  On different systems, it may yield different results.

Every library function that depends on pseudorandom numbers should be seeded by the {\PFAc randseed}.  Pseudorandom functions are explicitly denoted by this specification.

\pagebreak

\section{Type system}

Rather than invent a new type system, PFA uses Avro type schemae to describe its data types.  Avro is a serialization format, but it also describes the types (sets of possible values) that are to be serialized or unserialized with JSON-based schemae.  Feeding Avro-formatted data into and out of a PFA scoring engine is particularly easy, since the sets of possible values that can be Avro-serialized perfectly align with the sets of possible values that PFA can use in its calculations.

However, Avro serialization is by no means necessary to use with PFA: data that can be described by Avro types can be serialized many different ways.  In fact, the Avro project provides two: a binary format and a JSON format.  With the appropriate translations, CSV can be converted to and from a subset of Avro types, XML can be fully and reversibly transformed, as can many popular data formats.  The transformation of data formats and the internal representation of data in a PFA implementation are beyond the scope of this specification and should be handled in any way that the designer of a PFA system sees fit.

\hypertarget{hsec:avro-types}{}
\subsection{Avro types}
\label{sec:avro-types}

The normative definition of Avro 1.7.6 types and type schemae is \href{http://avro.apache.org/docs/1.7.6/spec.html}{provided online}.  However, the basics are duplicated here for convenience.  This section is non-normative.

The set of all expressible types is the closure under the following primitives and parameterized types.
\begin{allowedfields}
\item[null:] A type with only one value, {\PFAc null}.  This is a unit type, and is usually only useful when combined with other types in a union (see below) or as a return type for functions that do not have a meaningful value to return.
\item[boolean:] A type with only two values, {\PFAc true} and {\PFAc false}.
\item[int:] Signed whole numbers with a 32-bit range: from $-2147483648$ to $2147483647$ inclusive.
\item[long:] Signed whole numbers with a 64-bit range: from $-9223372036854775808$ to $9223372036854775807$ inclusive.
\item[float:] Signed fractional numbers with 32-bit binary precision as defined by \href{http://dx.doi.org/10.1109%2FIEEESTD.2008.4610935}{IEEE 754}.
\item[double:] Signed fractional numbers with 64-bit binary precision according to the same standard.
\item[string:] Strings of text characters that can be encoded in \href{http://www.unicode.org/standard/standard.html}{Unicode}.
\item[bytes:] Arrays of uninterpreted bytes with any length.
\item[fixed({\PFAtp L}, {\PFAtp N}, {\PFAtp NS}):] Named arrays of uninterpreted bytes with length {\PFAtp L} (integer), name {\PFAtp N} (string), and optional namespace {\PFAtp NS} (string).
\item[enum({\PFAtp S}, {\PFAtp N}, {\PFAtp NS}):] Named enumeration of a finite set of symbols {\PFAtp S} (ordered list of strings), name {\PFAtp N} (string), and optional namespace {\PFAtp NS} (string).
\item[array({\PFAtp X}):] Homogeneous array of type {\PFAtp X} (Avro type) with any length.
\item[map({\PFAtp X}):] Homogeneous map from strings to type {\PFAtp X} (Avro type).  The keys of all maps must be strings (just like JSON).
\item[record({\PFAtp F}, {\PFAtp N}, {\PFAtp NS}):] Heterogeneous record of fields {\PFAtp F} (named slots with Avro types) with name {\PFAtp N} (string) and optional namespace {\PFAtp NS} (string).  This is a product type; the possible values that it can have is the Cartesian product of the possible values that each field can have.
\end{allowedfields}
\begin{allowedfields}
\item[union({\PFAtp T}):] Union of types {\PFAtp T} (array of Avro types).  This is a sum type; the possible values that it can have is union of the values of each type in {\PFAtp T}.
\end{allowedfields}

\noindent\begin{minipage}{\linewidth}
\indent This type system has the following limitations and remediations.
\begin{itemize}
\item Arrays and maps must be homogeneous (all elements have the same, specified type).  This is sufficient for most mathematical applications and the restriction helps to eliminate common mistakes.  Also, it makes some significant optimizations possible that are difficult or impossible in dynamic languages.
\end{itemize}
\end{minipage}

\vspace{-0.15 cm}
\begin{itemize}
\item Map keys must be strings.  If an application must represent a map whose keys are not strings, one can define a unique string representation for each key and look up items by first transforming to the string representation.

\item There is no set or multiset type.  This can be emulated with arrays and PFA's \hyperlink{hsec:set-like}{set-like functions} or a map from string-valued keys to {\PFAc null}.

\item Circular references are not possible, as there are no pointers or references.  However, data structures with conceptual loops can be emulated through weak references in a map.  For example, an arbitrary directed graph can be described as a map of arrays of strings: each key is a node and each element of an array is a link to another node.  These references are weak because there is no guarantee that a key exists for every array element.

The lack of circular references is, in some ways, an advantage.  Non-circular data can be more easily serialized without the possibility of infinite loops.  Immutable data can take advantage of more structural sharing since data structures are purely tree-like.

Note that recursively defined types {\it are} possible.  A record {\PFAtp X} could have one or more fields that are unions of {\PFAtp X} and {\PFAtp Y}, or it could have a field that is an array or map of {\PFAtp X}.  The first case would describe a tree of nodes {\PFAtp X} with a fixed number of named branches, terminating in leaves of type {\PFAtp Y}.  (This is how decision trees are described in PFA; the scores have type {\PFAtp Y}.)  The second case would describe a tree of nodes {\PFAtp X} with arbitrarily many branches at each node, terminating in empty arrays or maps.

\item To make a type such as {\bf string} nullable, one must construct a union of {\bf string} and {\bf null}.  This union type cannot be passed into functions that expect a {\bf string}.

Again, this restriction can be an advantage.  It is often known as a type-safe null: in the example above, string functions can still be used, but only after explicitly handling the {\bf null} case.  In PFA, one would use a \hyperlink{hsec:casting}{cast-cases} special form to split the program flow into a branch that handles the {\bf string} case and a branch that handles the {\bf null} case, usually by specifying a rule that replaces {\PFAc null} with a string.  This restriction eliminates the possibility of null pointer exceptions at runtime.

Most library functions in PFA interpret {\PFAc null} as a missing value.  Missing value handling is an important consideration in many statistical analyses, so PFA has a \hyperlink{hsec:impute}{suite of functions} for addressing this case.
\end{itemize}

The advantages of this type system are that (1) it aligns well with types already used by major data pipeline tools (binary Avro and, with some transformation, Thrift and Protocol Buffers), (2) it is easy to represent as JSON or XML (the lack of circular references is particularly helpful), (3) any type is nullable, including primitives, (4) Avro's rules for schema resolution can be reinterpreted as type promotion for type inference (\hyperlink{hsec:type-inference}{see Sec.~\ref{sec:type-inference}}), (5) all types have a strict ordering (see \href{http://avro.apache.org/docs/1.7.6/spec.html#order}{Avro sort order specification}), and (6) the type schemae are JSON objects and strings, which fit seamlessly into a PFA document.

\subsection{Type schemae in the PFA document}

An Avro type schema can be a JSON object or a string.  JSON objects construct parameterized types, while strings specify type primitives or reference previously defined types.  Some PFA top-level fields and member values of special forms must be Avro schemae: these schema are simply included inline with the JSON representing the rest of the PFA document.

Below is a summary of the schema syntax that is relevant for PFA.  All \hyperlink{http://avro.apache.org/docs/1.7.6/spec.html}{Avro schema elements} must be accepted by a PFA reader, but these are the only ones that influence PFA.

The following strings are type primitives: ``null'', ``boolean'', ``int'', ``long'', ``float'', ``double'', ``string'', ``bytes''.  Other strings are either previously defined named types or they are invalid.  The form {\PFAc \{"type":$\!$ "X"\}} for string {\PFAtp X} is equivalent to the string on its own.

A byte array with name {\PFAtp N} and fixed length {\PFAtp L} is specified by the form {\PFAc \{"type":$\!$ "fixed", "name":$\!$ "N", "namespace":$\!$ "NS", "size":$\!$ L\}}.  The namespace is optional, but the name is not.  The length {\PFAtp L} must be a JSON integer.  Avro fixed types have additional object members, but they are not relevant for PFA.

An enumeration with name {\PFAtp N} and symbols {\PFAtp S} is specified by the form {\PFAc \{"type":$\!$ "enum", "name":$\!$ "N", "namespace":$\!$ "NS", "symbols":$\!$ S\}}.  The namespace is optional, but the name is not.  The symbols {\PFAtp S} must be a JSON array of strings.  Avro enumeration types have additional object members, but they are not relevant for PFA.

An array with elements of type {\PFAtp X} is specified by the form {\PFAc \{"type":$\!$ "array", "items":$\!$ X\}}.  An array does not accept a name or any other member values.

An map with values of type {\PFAtp X} is specified by the form {\PFAc \{"type":$\!$ "map", "values":$\!$ X\}}.  A map does not accept a name or any other member values.

A record with name {\PFAtp N} and fields {\PFAtp F} is specified by the form {\PFAc \{"type":$\!$ "record", "name":$\!$ "N", "namespace":$\!$ "NS", "fields":$\!$ F\}}.  The namespace is optional, but the name is not.  The fields {\PFAtp F} must be JSON objects with the following form: {\PFAc \{"name":$\!$ "FN", "type":$\!$ "FT", "default":$\!$ D, "order":$\!$ O\}} where {\PFAc name} and {\PFAc type} are required and {\PFAc default} and {\PFAc order} are not.  The default {\PFAtp D} is encoded in the Avro-JSON format and provides a default value if the input data stream is missing one.  The order {\PFAc O} is one of these strings: ``ascending'', ``descending'', and ``ignore'', and it defines the sort order for the record.  Avro record types and field types have additional object members, but they are not relevant for PFA.

A union of types {\PFAtp T1} \ldots {\PFAtp TN} is specified by a JSON array form {\PFAc [T \ldots\ TN]}.

If the Avro implementation used by a PFA system supports \href{http://avro.apache.org/docs/1.7.6/spec.html#Aliases}{aliases} for schema resolution, the aliases should be used for type inference (\hyperlink{hsec:type-inference}{see Sec.~\ref{sec:type-inference}}).  Aliases only apply to named types and record fields.

Avro schema parsing is usually implemented as a stateful process, in which the parser remembers previously named types and recognizes its namespace-qualified name in a JSON string as representing the type.  This is especially important for recursively defined types.  A PFA document may have many type schemae embedded within it, often as member values of JSON objects.  Systems that load JSON objects into hash-tables cannot guarantee that the order of JSON object members is preserved, which could cause schemae to be read in any order.

Therefore, PFA implementations must pass Avro schemae to be parsed in an order that resolves dependencies or PFA implementations must parse the schemae themselves in an order that resolves dependencies.  PFA documents must define named types (as a JSON object) exactly once and reference them (as a string) elsewhere.

\hypertarget{hsec:type-inference}{}
\subsection{Type inference}
\label{sec:type-inference}

PFA uses a near-minimum of type annotations for static type analysis.  Only the inputs to every calculation, which are function parameters, literal constants, inline arrays/maps/records, the symbols {\PFAc input} and {\PFAc tally}, and cell/pool definitions, and the outputs of every calculation, which are function return values and the scoring engine {\PFAc output}, need to be specified.  Unlike traditional languages (e.g.\ C or Java), the types of new variables are not specified: they are inferred through their initialization expressions (and would have been redundant if supplied).

With these annotations, the type check algorithm is simple.  Every expression is a tree of subexpressions, whose leaves are either references to previously defined symbols, function parameters, cells, or pools (with known type) or constants (with specified type).  Every function and special form has a type signature that may accept its arguments, in which case type-checking continues toward the root of the tree, or reject its arguments, in which case the PFA document fails with a semantic error.  Every function and special form has a return type, which may depend on the types of its arguments (but not the values of its arguments, which are only known at runtime).  Arguments and return types should be recursively checked until the root of the tree (the type of the expression as a whole) is reached.  This derived type is checked against the declared function return type or {\PFAc output}.  If the declared type does not accept the derived type, the PFA document is rejected with a semantic error.

Some special forms take a JSON array of expressions and either apply no return type constraint or only constrain the last expression, which is used as a return value.  Each case is explicitly specified in \hyperlink{hsec:expressions}{Sec.~\ref{sec:expressions}}.

In passing, we note that the type annotations could have been more minimal if return types were not required, and some input types could, in principle, be inferred from their position in a function argument list.  However, an explicit {\PFAc output} allows a PFA system or casual observer to quickly determine if a scoring engine will fit into a given workflow, in which the input types and output types are constrained by data pipelines.  Moreover, function return types cannot always be omitted, even in theory: recursive functions cannot determine their return type from parameters only, for instance.  Also, inferring input types from parents or siblings in the expression tree unnecessarily complicates the type-check algorithm.  The algorithm chosen for PFA is strictly local--- only subexpressions and previously defined symbols are needed to infer an expression type--- and uniform--- the same rules apply regardless of the function's call graph.

\subsection{Type resolution, promotion, and covariance}

At each step in the type inference algorithm, the expected type or type pattern is checked against the actual or derived type.  All types have a non-commutative, binary ``accepts'' relation, for which ``A accepts B'' means that B is an acceptable observed type for expected type A.  For example, ``{\bf double} accepts {\bf int}'' because integers are a subset of double-precision floating point numbers, and any function that needs a {\bf double} must be able to use an {\bf int} instead.

Even though Avro is a serialization protocol, it defines a suite of type promotion rules for the sake of schema resolution.  In Avro, these rules are used to determine if an old version of a schema is compatible with a new version of a schema: for instance, if the old schema defines a variable as an int and the new schema defines it as a double, the old serialized dataset is forward-compatible--- it can be used in an application as though it had the new schema.  PFA uses the same rules to promote data through an expression.

These rules are described in the \href{http://avro.apache.org/docs/1.7.6/spec.html#Schema+Resolution}{Schema Resolution section} of the Avro specification, but they are reviewed here with an emphasis on how the rules are used in PFA type inference.

\noindent\begin{longtable}{p{0.2\linewidth} p{0.75\linewidth}}
{\bf Expected type} & {\bf Accepts} \\\hline\endhead
{\bf null} & Only {\bf null} or a {\bf union} of only {\bf null} (union of exactly one type, which is not a useful union). \\
{\bf boolean} & Only {\bf boolean} or a {\bf union} of only {\bf boolean}. \\
{\bf int} & Only {\bf int} or a {\bf union} of only {\bf int}. \\
{\bf long} & {\bf int} or {\bf long} or a {\bf union} of any subset of \{{\bf int}, {\bf long}\}. \\
{\bf float} & {\bf int}, {\bf long}, or {\bf float} or a {\bf union} of any subset of \{{\bf int}, {\bf long}, {\bf float}\}. \\
{\bf double} & {\bf int}, {\bf long}, {\bf float} or {\bf double} (all numeric types are promoted).  Also accepts a {\bf union} of any subset of \{{\bf int}, {\bf long}, {\bf float}, {\bf double}\}. \\
{\bf string} & Only {\bf string} or a {\bf union} of only {\bf string}. \\
{\bf bytes} & Only {\bf bytes} or a {\bf union} of only {\bf bytes}. \\
{\bf fixed({\PFAtp L}, {\PFAtp N}, {\PFAtp NS})} & Only a {\bf fixed} with the same length {\PFAtp L} and fully-qualified name given by {\PFAtp NS} and {\PFAtp N}.  Also accepts a {\bf union} of only this {\bf fixed} type. \\
{\bf enum({\PFAtp S}, {\PFAtp N}, {\PFAtp NS})} & An {\bf enum} whose symbols {\PFAc S} are a subset of the expected {\bf enum}'s symbols with fully-qualified name given by {\PFAtp NS} and {\PFAtp N}.  For example, if an {\bf enum} with symbols ``one'', ``two'', and ``three'' is expected, it will accept an {\bf enum} of the same name with symbols ``two'' and ``one''.  Also accepts a {\bf union} of only these {\bf enum} types. \\
{\bf array({\PFAtp X})} & An {\bf array} with items {\PFAc Y} for which {\PFAc X} accepts {\PFAc Y} (arrays are covariant).  For example, an {\bf array} of {\bf double} accepts an {\bf array} of {\bf int}, but an an {\bf array} of {\bf int} does not accept an an {\bf array} of {\bf double}.  Also accepts a {\bf union} of only these {\bf array} types. \\
{\bf map({\PFAtp X})} & A {\bf map} with values {\PFAc Y} for which {\PFAc X} accepts {\PFAc Y} (maps are covariant).  Also accepts a {\bf union} of only these {\bf map} types. \\
{\bf record({\PFAtp F}, {\PFAtp N}, {\PFAtp NS})} & A {\bf record} whose fields are a superset of fields {\PFAc F} (in any order) with corresponding field types such that the expected field accepts the observed field (records are covariant).  For example, an expected record with fields \{``one'': {\bf double} and ``two'': {\bf string}\} accepts an observed record with fields \{``one'': {\bf double}, ``two'': {\bf string}, and ``three'': {\bf bytes}\}.  It also accepts an observed record with fields \{``one'': {\bf int} and ``two'': {\bf string}\}.  The observed record must also have the same fully-qualified name given by {\PFAc NS} and {\PFAc N}.  Also accepts a {\bf union} of only these {\bf record} types. \\
{\bf union({\PFAtp T})} & Either a {\bf union({\PFAtp T$'$})} such that for all {\PFAc t$'$} in {\PFAc T$'$}, there exists a {\PFAc t} in {\PFAc T} for which {\PFAc t} accepts {\PFAc t$'$}, or a single type {\PFAc t$''$} such that there exists a {\PFAc t} in {\PFAc T} for which {\PFAc t} accepts {\PFAc t$''$}.  For example, a {\bf union} of \{{\bf string}, {\bf bytes}, and {\bf null}\} accepts a {\bf union} of \{{\bf string} and {\bf bytes}\}, and it also accepts a {\bf string}.  However, the reverse is not true: a narrow type or union cannot accept a wider union.
\end{longtable}

\hypertarget{hsec:narrowest-supertype}{}
\subsection{Narrowest supertype of a collection of types}
\label{sec:narrowest-supertype}

Some circumstances (return type of a special form, solution of a generic type pattern) require a single type that accepts a given set of types.  For example, an ``if'' conditional with both a ``then'' and an ``else'' clause returns a value that might have the type of the ``then'' clause or might have the type of the ``else'' clause.  If both clauses have the same type {\PFAtp X}, then the return type of the ``if'' special form is {\PFAtp X}, but if ``then'' has type {\PFAtp Y} and ``else'' has type {\PFAtp Z}, the type of the ``if'' special form is something that could be (accepts) {\PFAtp Y} or {\PFAtp Z}.  In these situations, the resultant type is the narrowest supertype of the possibilities.

The following rules define the narrowest supertype of a collection of at least one type.  In cases where more than one rule matches, the first matching rule is applied.
\noindent\begin{longtable}{p{0.02\linewidth} p{0.3\linewidth} p{0.6\linewidth}}
\# & {\bf Collection of types} & {\bf Narrowest supertype} \\\hline\endhead
1. & all {\bf null} & {\bf null} \\
2. & all {\bf boolean} & {\bf boolean} \\
3. & all {\bf int} & {\bf int} \\
4. & all {\bf int} or {\bf long} & {\bf long} \\
5. & all {\bf int}, {\bf long}, or {\bf float} & {\bf float} \\
6. & all {\bf int}, {\bf long}, {\bf float}, or {\bf double} & {\bf double} \\
7. & all {\bf string} & {\bf string} \\
8. & all {\bf bytes} & {\bf bytes} \\
9. & all {\bf fixed} with the same length and fully-qualified name & that {\bf fixed} type \\
10. & all {\bf enum} types with the same symbols and fully-qualified name & that {\bf enum} type \\
11. & all {\bf arrays} & an {\bf array} of the narrowest supertype of the items of each {\bf array} \\
12. & all {\bf maps} & a {\bf map} of the narrowest supertype of the values of each {\bf map} \\
13. & all {\bf records} with the same fields and fully-qualified name & that {\bf record} type \\
14. & any other collection of types, excluding those containing {\bf fixed} and {\bf enum} & a union of those types, merging any unions contained in the collection (e.g.\ {\bf union({\PFAtp X}, {\PFAtp Y})} and {\bf union({\PFAtp Y}, {\PFAtp Z})} combine into {\bf union({\PFAtp X}, {\PFAtp Y}, {\PFAtp Z})}) and combining any types that can be combined with the rules above (e.g.\ {\bf int} and {\bf double} become {\bf double}, rather than {\bf union(int, double)}). \\
15. & any other case & is a type error.
\end{longtable}

In summary, any cases that cannot be promoted to the same type are combined into a union except for collections containing {\bf fixed} or {\bf enum}.  These cases, had they been allowed, would introduce the need for PFA implementations to perform runtime type conversions: values of different {\bf fixed} types would need to be converted into raw {\bf bytes} and values of different {\bf enum} types would need to be converted into {\bf string} or an {\bf enum} with a superset of symbols.  These new, anonymous types would have potentially unexpected properties: the broadening of {\bf enums} cannot maintain the order of a collection of symbols, which are used in some statistical applications as a finite ordinal set.  It is better to raise a type error and force the PFA author to explicitly convert these types to {\bf bytes}, {\bf string}, or explicitly define an {\bf enum} with a superset of symbols.

Distinct {\bf records} are combined into a union of those {\bf records}, however (rule 13 falls through to rule 14 when the {\bf records} are not exactly the same).

\hypertarget{hsec:generic-signatures}{}
\subsection{Generic library function signatures}
\label{sec:generic-signatures}

User-defined functions in the {\PFAc fcns} top-level field have parameter lists and return types specified strictly by Avro type schemae (\hyperlink{hsec:user-defined-fcns}{see Sec.~\ref{sec:user-defined-fcns}}).  However, some library functions have more general type signatures so that they can be more broadly applied.

Library functions are never declared in a PFA document, and thus they are not bound to the same restrictions.  It would be possible to define a JSON format for expressing generic function signatures, but that format would not be an Avro schema.  Moreover, PFA documents are not intended for generic programming, but for auto-generated code.  Since every PFA document is a specific solution to a specific problem, it should be written in terms of ungeneric functions.  (The generality can be in the routine that generates the PFA document.)  The PFA library functions, however, are intended for a wide variety of problems, and thus should be generic.

Library function type patterns are a superset of Avro types.  They include the same primitives:
\begin{itemize}
\item null, boolean, int, long, float, double, string, bytes
\end{itemize}
and the same parameterized, product, and sum types, though names are optional:
\begin{itemize}
\item fixed ({\it size:} {\PFAtp L})
\item fixed ({\it size:} {\PFAtp L}, {\it name:} {\PFAtp N})
\item enum ({\it symbols:} {\PFAtp S})
\item enum ({\it symbols:} {\PFAtp S}, {\it name:} {\PFAtp N})
\item array of {\PFAtp X}
\item map of {\PFAtp X}
\item record ({\it fields:} \{{\PFApf name$_1$:} {\it type$_1$,} {\PFApf name$_2$:} {\it type$_2$,} \ldots\ {\PFApf name$_n$:} {\it type$_n$}\})
\item record ({\it fields:} \{{\PFApf name$_1$:} {\it type$_1$,} {\PFApf name$_2$:} {\it type$_2$,} \ldots\ {\PFApf name$_n$:} {\it type$_n$}\}, {\it name:} {\PFAtp N})
\item union of \{{\PFAtp T}\}
\end{itemize}
When present, names are fully-qualified, rather than being split into namespace-name pairs.  A type pattern of fixed, enum, or record without a name matches any fixed, enum, or record with the specified structure (structural typing, rather than nominative).  For instance, a library function could require a record with integer, double, and string fields named ``one'', ``two'', and ``three'' like this:
\begin{center}
\begin{minipage}{0.9\linewidth}
record ({\it fields:} \{{\PFApf one:} int, {\PFApf two:} double, {\PFApf three:} string\})
\end{minipage}
\end{center}
Since this pattern has no {\it name,} it would match any record that has exactly these fields with these types.

Unlike Avro types, the parameters of type patterns can be specified by wildcards.  Wildcards are labeled and may be restricted to a set of Avro types (not patterns):
\begin{itemize}
\item any {\PFAp A}
\item any {\PFAp A} of \{{\it type$_1$, type$_2$, \ldots\ type$_n$}\}
\end{itemize}
Wildcards can appear anywhere that a pattern is expected.  For instance,
\begin{center}
\begin{minipage}{0.9\linewidth}
array of any {\PFAp A}
\end{minipage}
\end{center}
is an array with unspecified item type.

Wildcards with repeated labels constrain two types to be the same type.  For instance,
\begin{center}
\begin{minipage}{0.9\linewidth}
record ({\it fields:} \{{\PFApf one:} any {\PFAp A}, {\PFApf two:} any {\PFAp B}, {\PFApf three:} any {\PFAp B}\})
\end{minipage}
\end{center}
is a record with three fields of unspecified type, though fields ``two'' and ``three'' have the same.  If they are not exactly the same, they are promoted to the \hyperlink{hsec:narrowest-supertype}{narrowest supertype} of the matches.  The following are examples of Avro types that would match this pattern.
\begin{example}
{\PFAc R1} matches because ``two'' and ``three'' are both {\bf string}.
\begin{json}
{"type": "record", "name": "R1", "fields": [
    {"name": "one", "type": "int"},
    {"name": "two", "type": "string"},
    {"name": "three", "type": "string"}]}
\end{json}
\vspace{0.2 cm}
\end{example}

\begin{example}
{\PFAc R2} matches because ``two'' and ``three'' are both {\bf int}.  The type that matches wildcard {\PFAp B} does not need to be different from the type that matches wildcard {\PFAp A} (also ``int'').
\begin{json}
{"type": "record", "name": "R2", "fields": [
    {"name": "one", "type": "int"},
    {"name": "two", "type": "int"},
    {"name": "three", "type": "int"}]}
\end{json}
\vspace{0.2 cm}
\end{example}

\begin{example}
{\PFAc R3} matches because ``two'' and ``three'' can both be promoted to {\bf double}.
\begin{json}
{"type": "record", "name": "R3", "fields": [
    {"name": "one", "type": "string"},
    {"name": "two", "type": "int"},
    {"name": "three", "type": "double"}]}
\end{json}
\end{example}

The scope of wildcard labels is the entire function signature, including all parameters and return type.

\begin{example}
As an example, the signature of ``+'' (the library function that adds two numbers) is
\begin{center}
\begin{minipage}{0.9\linewidth}
\mbox{\PFAc \{"+":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\ \end{tabular}
\end{minipage}
\end{center}
The two parameters, {\PFAp x} and {\PFAp y}, can be any type in the set \{int, long, float, double\} and the return type is the narrowest supertype of {\PFAp x} and {\PFAp y}.  Thus, int $+$ int $\to$ int, int $+$ double $\to$ double, etc.  The restriction on {\PFAtp A} in the pattern for {\PFAp x} applies equally to {\PFAp y} because all constraints must be satisfied for a pattern to match.
\end{example}

\begin{example}
Shared labels are primarily used to carry types from a parameter to the return type.  They allow a function like ``a.subseq'' (extract a subsequence of an array) to be defined once for any type of items.
\begin{center}
\begin{minipage}{0.9\linewidth}
\mbox{\PFAc \{"a.subseq":$\!$ [a, start, end]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular}
\end{minipage}
\end{center}
\end{example}

Record substructure can also be matched with wildcards.  Such a pattern has one of these two forms:
\begin{itemize}
\item any record {\PFAp A}
\item any record {\PFAp A} with \{{\PFApf name$_1$:} {\it type$_1$,} {\PFApf name$_2$:} {\it type$_2$,} \ldots\ {\PFApf name$_n$:} {\it type$_n$}\}
\end{itemize}
The first matches any record, regardless of what fields it contains, and the second matches a record with at least the specified fields.  Wildcards with and without specifying record substructure have labels in the same namespace.

Enumeration lists can also be matched to record fields:
\begin{itemize}
\item enum {\PFAp A} of fields of {\PFAp B}
\end{itemize}
where {\PFAp B} refers to a wildcarded record.  To match this pattern, the enum's symbols must be equal to the record field names--- the same strings in the same order, without any missing or any extra.  Functions with this pattern in their signature (such as ``model.tree.simpleTest'') not only guarantee that values of the enumeration correspond to some record field (unlike arbitrary strings), but at runtime, the record field can be retrieved by index or pointer, rather than by name.

Finally, some library functions can accept functions as arguments, even though functions are not first-class objects in the language.  A function cannot be assigned to a symbol, but it can appear in an argument list.  The following type pattern matches functions:
\begin{itemize}
\item function ({\it type$_1$}, {\it type$_2$}, \ldots\ {\it type$_n$}) $\to$ {\it type}
\end{itemize}
The pattern does not specify the names of parameters, only their number, order, and types (as patterns).  Only non-generic functions can be matched, and since most library functions are generic, the matched function would usually be a user-defined function.  (Notable exceptions are mathematical special functions, probability distributions, and clustering metrics.)

\begin{example}
The parameter and return types of a function pattern can be wildcarded, as in this example of ``a.filter'', which filters an array.
\begin{center}
\begin{minipage}{0.9\linewidth}
\mbox{\PFAc \{"a.filter":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\ \end{tabular}
\end{minipage}
\end{center}
\end{example}

\begin{example}
Library functions with function arguments are primarily used to override the default behavior of a statistical routine through callbacks.  The ``model.tree.simpleWalk'' function illustrates how a decision tree traversal can be given an arbitrary or even user-defined predicate.
\begin{center}
\begin{minipage}{0.9\linewidth}
\mbox{\PFAc \{"model.tree.simpleWalk":$\!$ [datum, treeNode, predicate]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & any record {\PFAtp D} \\  & \PFAc treeNode \rm & any record {\PFAtp T} with \{{\PFApf pass:}$\!$ union of \{{\PFAtp T}, any {\PFAtp S}\}, {\PFApf fail:}$\!$ union of \{{\PFAtp T}, {\PFAtp S}\}\} \\  & \PFAc predicate \rm & function ({\PFAtp D}, {\PFAtp T}) $\to$ boolean \\  & {\it (returns)} & {\PFAtp S} \\ \end{tabular}
\end{minipage}
\end{center}
\end{example}

Function arguments can only be provided using the \hyperlink{hsec:fcndef}{fcndef} or \hyperlink{hsec:fcnref}{fcnref} special forms, which require explicit functions to be known during static analysis.  Therefore, the platform on which PFA is being implemented does not need first class functions or the equivalent (e.g.\ objects with a pre-specified ``apply'' method).  It does not even need functions in the normal sense: if the platform requires all functions to be expanded inline, the PFA system can generate specific code for each case.  That is, the ``a.filter'' and ``model.tree.simpleWalk'' functions can be expanded into special-case bytecode for each call that takes a different function argument, possibly mixing the library function implementation with the user-defined callback.  This would not be possible if function arguments could only be resolved at runtime.

\pagebreak

\hypertarget{hsec:symbol-scope}{}
\section{Symbols, scope, and data structures}
\label{sec:symbol-scope}

Calculations in PFA are performed by nesting function calls in argument lists (purely functional programming) and assigning values to symbols, cells, and pools, possibly overwriting previous values (imperative programming).  Some mathematical algorithms are more easily expressed in a functional style while others are more easily expressed in an imperative style.  Cells and pools (global state) are discussed in \hyperlink{hsec:state}{Sec.~\ref{sec:state}}.  Symbols provide temporary local state.

Much like a cell, a symbol is a named container with fixed type whose value can be replaced: it is a variable.  Unlike a cell, a symbol can only be referenced within a limited scope.  Symbol scopes in PFA are
\begin{itemize}
\item lexical: scopes are defined in terms of character ranges in the text of the PFA document, and
\item block-level: they range from the declaration of the symbol to the end of the containing block, which is either a single expression of a JSON array of expressions.
\end{itemize}

Since blocks are deeply nested in a moderately complex PFA document, symbol scopes may be deeply nested as well.  A symbol must not be shadowed; that is, it must not be declared twice in the same scope or in two scopes such that one is nested within the other.  The same symbol name may be used in non-overlapping scopes.

Symbols are declared with the ``let'' special form and reassigned with the ``set'' special form (\hyperlink{hsec:let-set}{see Sec.~\ref{sec:let-set}}).  This distinction between declaration and reassignment should be enforced, as it allows an observer to determine which symbols are constant and which algorithms are purely functional at a glance.

Although a symbol is readable anywhere below the point at which it is defined, some special forms limit the scopes in which a symbol can be reassigned.  For example, symbols declared outside of an anonymous function cannot be modified by the function, since that would be hard to implement in a system that does not have closures.  Looping special forms for which {\PFAc seq} is {\PFAc false} may be evaluated in any order to allow for systems that might parallelize the loop--- in this case, symbols declared outside the loop cannot be modified in the loop, since that would lead to race conditions.  Special forms that prohibit modification of symbols declared outside the form are said to be ``sealed from above''.

Some forms also do not allow new variable declarations.  One such example is the argument list of a function call, since such a declaration could never be used (each argument of the function call is in a different scope).  These scopes are said to be ``sealed within''.  In a functional programming style, it is sometimes desirable to insert whole algorithms in what would otherwise be a restricted block like a function argument.  To allow for this usage, a ``do'' special form can be placed within such a scope, creating a sub-scope that allows variable declarations and expands a single-expression block into a JSON array of expressions.  The ``do'' form is required to ensure that this usage is intentional.

The sealed-from-above or sealed-within status of scopes within each special form is specified in \hyperlink{hsec:expressions}{Sec.~\ref{sec:expressions}}.

Symbol names must match the following pattern: {\PFAc [A-Za-z\_][A-Za-z0-9\_]*} (the first character must be a letter or underscore; subsequent characters, if they exist, may also be numbers).  Symbol names do not share a namespace with cells, pools, or functions.

\hypertarget{hsec:immutable}{}
\subsection{Immutable data structures}
\label{sec:immutable}

All values in PFA, including complex data structures like arrays, maps, and records, are immutable.  That is, there are no special forms or library functions that can change the structure of a value in-place, so in-place operations cannot be expressed in any routine constructed from those calls.  The PFA specification puts no constraints on how values are implemented, however: they may be immutable in the context of PFA operations and yet mutable in the context of the host system.  We suggest that complex data structures be implemented with structural sharing to optimize speed and memory usage, but this is an implementation detail.

One consequence of all data structures being immutable is that there is no distinction between a value and a reference to a value or between copying and linking.  In languages with mutable values and references, this distinction is important because linking a reference to the same value in multiple places creates an unseen connection between them.  For instance (in Python),
\begin{center}
\begin{minipage}{0.9\linewidth}
\PFAc y.child = x \\
z.child = x \\
... \\
y.child.modify()
\end{minipage}
\end{center}
modifies {\PFAc z.child} as well as {\PFAc y.child}, while
\begin{center}
\begin{minipage}{0.9\linewidth}
\PFAc y.child = deepcopy(x) \\
z.child = deepcopy(x) \\
... \\
y.child.modify()
\end{minipage}
\end{center}
only modifies {\PFAc y.child}.  Since PFA lacks the equivalent of {\PFAc modify()}, the above distinction is irrelevant.

Another consequence is that it is impossible to create a circular reference in PFA.  In Python, one can create a circular reference in a list {\PFAc x} by
\begin{center}
\begin{minipage}{0.9\linewidth}
\PFAc x.append(x)
\end{minipage}
\end{center}
Attempts to depth-first walk through this list of lists would result in an infinite loop, and modifications of {\PFAc x} would silently change this nested element (as above).  In PFA, the equivalent statement
\begin{json}
{"set": {"x": {"a.append": ["x", "x"]}}}
\end{json}
creates a new array that contains all of the old items of {\PFAc x} with the entire old array {\PFAc x} appended.  This new array is assigned to symbol {\PFAc x}.  Since PFA has no mutable structures (and no lazy evaluation), it is impossible to create a circular reference.

\begin{example}
In fact, assignments with the same symbol on the left-hand side as the right-hand side behave like ``{\PFAc x = x + 1}'' in that the right-hand side always deals with the old value of the symbol and the left-hand side may change the meaning of the symbol to a new value.  For instance,
\begin{json}
{"do": [
    {"let": {"x": {
        "type": {"type": "record", "name": "R", "fields": [
            {"name": "child", ["R", "null"]}]},
        "value": {"child": null}}}},
    {"set": {"x": {"attr": "x", "path": ["child"], "to": "x"}}},
    {"set": {"x": {"attr": "x", "path": ["child"], "to": "x"}}},
    {"set": {"x": {"attr": "x", "path": ["child"], "to": "x"}}},
    "x"]}
\end{json}
results in
\begin{json}
{"child": {"child": {"child": {"child": null}}}}
\end{json}
just as
\begin{json}
{"do": [
    {"let": {"x": 0}},
    {"set": {"x": {"+": ["x", 1]}}},
    {"set": {"x": {"+": ["x", 1]}}},
    {"set": {"x": {"+": ["x", 1]}}},
    "x"]}
\end{json}
results in 3.  In languages with mutable data structures, some updates behave like ``{\PFAc x = x + 1}'' while others create circular references.
\end{example}

Similarly, there is no distinction between passing a function argument by reference versus passing it by value.  Such a distinction would be seen when the function modifies the object that it is given, but in PFA, these modifications are not possible.

To get this behavior in a language or context that allows in-place modifications, one must make deep copies of the objects because copies are not linked the way that references are.  However, purely immutable objects can be safely passed without copying and structurally shared when modified.  In the examples above, a PFA implementation may use the same object in memory wherever its value is needed and may always pass a pointer to the object as a function argument.  Since values and references are equivalent, one can choose the computationally least expensive operation.

Our decision to make all data structures immutable was driven by two needs: (1) to make them fully expressible by Avro type schemae, which do not allow for circular references or any non-treelike graph, and (2) to simplify the read-copy-update \hyperlink{hsec:concurrent}{concurrency algorithm}.  If objects were mutable, then an explicit copy would be needed to allow read operations to see the old version of the object while write operations create a new version.  In addition to making implementations more complicated, this would make all write operations more expensive, since they must do a deep copy on every update.  With immutable objects, the copy step is unnecessary.

\subsection{Memory management}

PFA does not define any particular memory management technique.  The language has constructs for creating objects but not for deleting them, so some sort of garbage collector will be needed to release objects that are out of scope.  This implicit garbage collector may be the same as the one used by PFA host's environment (e.g.\ the JVM and Python have built-in garbage collectors) or it may be a library used to collect garbage only in the PFA system (e.g.\ the boehmgc and boost libraries provide garbage collectors for C++).

\pagebreak

\hypertarget{hsec:user-defined-fcns}{}
\section{User-defined functions}
\label{sec:user-defined-fcns}

A PFA document may define new functions that are called as though they were library functions.  There are two differences between these ``user-defined'' functions and the library functions specified by PFA:
\begin{itemize}
\item user-defined functions are prefixed by ``{\PFAc u.}'' when called (in the ``u'' branch of the module tree);
\item their signatures must consist of specific Avro types, since only library functions can have generic signatures (\hyperlink{hsec:generic-signatures}{see Sec.~\ref{sec:generic-signatures}}).
\end{itemize}

The scope of all functions, including user-defined functions, is global.  Functions are also static; they cannot be declared at runtime.  They may be declared in the {\PFAc fcns} top-level field, which makes their global, static nature manifest, or they may be declared inline in the argument list of a special form or library function that accepts a function as an argument.

In the latter case, the user-defined function has no name (an ``anonymous function'') and some features of a lexical closure.  It has access to symbols defined in an enclosing scope (it ``closes over'' those symbols), but this access is limited to reading only.  A PFA system may implement this by internally adding the closed symbols to its parameter list.  In all other aspects, an anonymous function behaves like a globally defined function and may be implemented as one (with an auto-generated name).

Function names must match the following: {\PFAc [A-Za-z\_]([A-Za-z0-9\_]|\textbackslash.[A-Za-z][A-Za-z0-9\_]*)*} (consists of dot-delimited words in which each word starts with a letter or underscore; subsequent characters, if they exist, may also be numbers; there must be at least one word).  Functions do not share a namespace with cells, pools, or symbols.

\subsection{No first-class functions}

Some languages have first-class functions, meaning that functions are ``first-class citizens'' and can be treated like any other data structure.  In PFA, functions are second-class, but not coach.  Similar to first-class functions, they may be passed as arguments to other functions (specific library functions that accept functions as arguments) and they may be defined inline as anonymous functions that close over local variables.  Unlike first-class functions, they cannot be assigned to symbols or be returned from functions, and the closures have read-only access to the variables they close over.

These restrictions make it possible to implement PFA functions in very limited environments and to be able to fully analyze the function call graph without executing the scoring engine (thereby statically detecting recursion, if necessary).  If, instead, a function could be assigned to a symbol, then it could be changed at runtime and not be predicted statically.  If an inline function could reassign symbols in its scope, then it could not be internally implemented as a simple function.

These rules provide enough flexibility to implement callbacks in library functions, but not so much as to make the call graph unpredictable or make the scoring engine impossible to implement in environments that only accept inline-expanded functions.  Pascal and Algol are two historical examples of languages with the same set of rules.

\subsection{Syntax for declaring new functions}

User functions are declared with the ``fcndef'' special form.  If ``fcndef'' appears in an argument list, it defines an anonymous function.  If it appears as a member value for a name-value pair in the {\PFAc fcns} top-level field, it defines a named function.

\subsubsection{Defining function: the ``fcndef'' special form}

\hypertarget{hsec:fcndef}{}
\label{form:fcndef}
\begin{minipage}{\linewidth}
The ``fcndef'' special form has the following syntax.
\begin{center}
\begin{minipage}{0.9\linewidth}
\mbox{\PFAc \{"params":$\!$ [\{par1:$\!$ type1\}, \{par2:$\!$ type2\}, ...], "ret":$\!$ retType, "do":$\!$ expr\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\
\rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}
& \PFAc par1 \rm & string, name of first parameter \\
& \PFAc type1 \rm & Avro schema, type of first parameter \\
& \PFAc par2 \rm & string, name of second parameter \\
& \PFAc type2 \rm & Avro schema, type of second parameter \\
& \ldots & \\
& \PFAc retType \rm & Avro schema, return type \\
& \PFAc expr \rm & expression or JSON array of expressions \\
\end{tabular}
\end{minipage}
\end{center}
\end{minipage}

The {\PFAc params}, {\PFAc ret}, and {\PFAc do} fields must be present, though {\PFAc params} could be an empty JSON array (no parameters).  The individual parameters are always represented by single-member JSON objects: the name is the parameter name (used in the function body), and the value is its type.

The {\PFAc do} field is the function body, and its return value is the last or only expression it contains.  The {\PFAc do} field must contain at least one expression (it must not be an empty JSON array).

If this form appears in the {\PFAc fcns} top-level field, the function name (without its namespace qualifier, ``{\PFAc u.}'') is given by the associated member name.

\begin{example}
For example,
\begin{json}
"fcns": {
    "square": {"params": [{"x": "double"}], "ret": "double", "do": {"**": ["x", 2]}},
    "cube": {"params": [{"x": "double"}], "ret": "double", "do": {"**": ["x", 3]}}
}
\end{json}
defines {\PFAc u.square} (which squares the input value) and {\PFAc u.cube} (which cubes the input value).  The number 5 may now be squared by {\PFAc \{"u.square":$\!$ 5\}} or {\PFAc \{"u.square":$\!$ [5]\}}.
\end{example}

\begin{example}
This Fibonacci number algorithm demonstrates recursion.
\begin{json}
"fcns": {
    "fib": {"params": [{"n": "int"}], "ret": "int", "do":
        {"cond": {"if": {"==": ["n", 0]}, "then": 0},
                 {"if": {"==": ["n", 1]}, "then": 1},
         "else": {"+": [
             {"u.fib": [{"-": ["n", 1]}]},
             {"u.fib": [{"-": ["n", 2]}]}
         ]}}}
}
\end{json}
\end{example}

\begin{example}
This iterative Fibonacci number algorithm illustrates a multi-line {\PFAc do} field.
\begin{json}
"fcns": {
    "fib": {"params": [{"n": "int"}], "ret": "int", "do": [
        {"let": {"now": 0,
                 "next": 1}},
        {"for": {"i": "n"},
         "until": {"<": ["i", 0]},
         "step": {"i": {"-": ["i", 1]}},
         "seq": true,
         "do": [
             {"let": {"tmp": {"+": ["now", "next"]}}},
             {"set": {"now": "next",
                      "next": "tmp"}}
         ]},
         {"if": {"==": ["n", 0]},
          "then": 0,
          "else": "next"}
    ]}
}
\end{json}
\end{example}

\hypertarget{hsec:referencing-functions}{}
\subsection{Syntax for referencing functions}
\label{sec:referencing-functions}

Named functions are referenced with the ``fcnref'' special form, and anonymous functions are both declared and referenced with an inline ``fcndef'' special form (see above).

\hypertarget{hsec:fcnref}{}
\label{form:fcnref}

\subsubsection{Referencing a globally defined function: the ``fcnref'' special form}

\begin{minipage}{\linewidth}
The ``fcnref'' special form has the following syntax.
\begin{center}
\begin{minipage}{0.9\linewidth}
\mbox{\PFAc \{"fcn":$\!$ name\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\
\rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}
& \PFAc name \rm & string, the name of the function \\
\end{tabular}
\end{minipage}
\end{center}
or
\begin{center}
\begin{minipage}{0.9\linewidth}
\mbox{\PFAc \{"fcn":$\!$ name, "fill":$\!$ \{param1:$\!$ value1, param2:$\!$ value2, \ldots\}\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\
\rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}
& \PFAc name \rm & string, the name of the function \\
& \PFAc param\# \rm & string, the name of a parameter of the function \\
& \PFAc value\# \rm & expression, an expression to evaluate and pass to param\# \\
\end{tabular}
\end{minipage}
\end{center}
\end{minipage}

The {\PFAc name} string must be an exact name of the function, not an expression that can be evaluated at runtime.

If the {\PFAc fill} field is used, the form represents a new function with fewer parameters than the referenced function, in which one or more of the referenced function's fields are filled by an expression.  The expression is evaluated every time the new function is called (relevant if it has any side-effects).  Since the new function has fewer parameters than the referenced function, it has a different type than the referenced function.  This form is usually used to supply default arguments to a general function.

Only non-generic functions with a single signature that does not reference other functions can be represented by a ``fcnref'' form.  Generic parameters or function parameters are only allowed if they are filled (hidden) by a {\PFAc fill} field.  Note that return types may not be generic, either.  If you wish to reference a general function, wrap it in an inline ``fcndef'', which is non-generic, single-signature, and hs no explicit function arguments because it is a user function.

\begin{example}
Here is a complete PFA document that increments and returns a counter every time it is pinged (the scoring engine is executed with {\PFAc null} input).
\begin{json}
{"input": "null",
 "output": "int",
 "action": [
     {"cell": "counter", "to": {"fcn": "u.increment"}},
     {"cell": "counter"}],
 "cells":
     {"counter": {"type": "int", "init": 0, "shared": true}},
 "fcns":
     {"increment":
         {"params": [{"x": "int"}],
          "ret": "int",
          "do": {"+": ["x", 1]}}}
}
\end{json}
The increment is defined in a function so that getting the counter value, incrementing it, and putting the new value in the cell are all one atomic action--- other update attempts block until this one is done.  Without ensuring atomicity, the counter could miss an update when a second update attempt reads {\PFAc counter} before the first writes its new value.
\end{example}

\begin{example}
The same operation could be performed with an inline ``fcndef''.  In the example below, the scoring engine adds the input value to {\PFAc counter} every time it is called.  Because of its location, the anonymous function can close over the {\PFAc input} symbol, which exists in the {\PFAc action} block but not in {\PFAc fcns}.
\begin{json}
{"input": "int",
 "output": "int",
 "action": [
     {"cell": "counter", "to": {"params": [{"x": "int"}],
                                "ret": "int",
                                "do": {"+": ["x", "input"]}}},
     {"cell": "counter"}],
 "cells":
     {"counter": {"type": "int", "init": 0, "shared": true}}
}
\end{json}
\end{example}

\pagebreak

\hypertarget{hsec:expressions}{}
\section{Expressions}
\label{sec:expressions}

PFA documents may contain simple programs formed by composing expressions.  There are four types of expressions: symbol references, literal values, function calls, and special forms.

\hypertarget{hsec:symbol-ref}{}
\subsection{Symbol references}
\label{sec:symbol-ref}

A symbol reference yields the current value of a predefined symbol.  For example, the {\PFAc action} routine has a {\PFAc input} symbol pre-defined: wherever this appears, the input value is inserted.  New symbols can be created with ``\hyperlink{hsec:let-set}{let}'' and old symbols can be changed with ``\hyperlink{hsec:let-set}{set}'', if the current context allows it (\hyperlink{hsec:symbol-scope}{see Sec.~\ref{sec:symbol-scope}}).  \hyperlink{hsec:cells-pools}{Cells and pools} are not symbols; they are referenced through \hyperlink{hsec:cell-pool-forms}{a pair of special forms}.

A symbol reference is simply a JSON string.  JSON strings in contexts where an expression is expected are interpreted as symbol references (with one exception); JSON strings in other contexts have other meanings.  The exception is the following: a valid symbol name must not contain dots (``.'') as described at the end of \hyperlink{hsec:symbol-scope}{Sec.~\ref{sec:symbol-scope}}, and if a JSON string where an expression is expected contains dots, it should be interpreted as a shortcut for the ``\hyperlink{hsec:attr-form}{attr}'' special form.

\hypertarget{hsec:literals}{}
\subsection{Literal values}
\label{sec:literals}

Literal values are constants embedded in an expression.  Simple examples are numbers, such as the ``2'' in this expression that squares {\PFAc x}: {\PFAc \{"**":$\!$ ["x", 2]\}}.

Cells without ``cell-to'' can also be used to define constants in a PFA document.  The differences are: (1) a literal appears in the midst of an expression, while cells are in the {\PFAc cells} top-level field, (2) cells are named and can be referenced in many places throughout a PFA document, including functions, but literals are unnamed unless assigned to a symbol of limited scope, (3) constant cells are constructed once, in the \hyperlink{hsec:phases}{initialization phase} of the engine, but literals may or may not be constructed every time the program flow reaches them (this is an implementation detail).  Typically, large data structures like the representation of a statistical model would be stored in a cell, rather than an inline literal.

Literals are represented by the following special forms:
\begin{itemize}
\item {\PFAc \{"int":$\!$ NUMBER\}} where {\PFAc NUMBER} is a JSON integer.  The return type is {\bf int}; a value that is too large to be represented as a 32-bit number is a syntax error.
\item {\PFAc \{"long":$\!$ NUMBER\}} where {\PFAc NUMBER} is a JSON integer.  The return type is {\bf long}; a value that is too large to be represented as a 64-bit number is a syntax error.
\item {\PFAc \{"float":$\!$ NUMBER\}} where {\PFAc NUMBER} is a JSON floating-point number.  The return type is {\bf float}; a value that is too large, too small, or too precise to be represented as a \href{http://dx.doi.org/10.1109%2FIEEESTD.2008.4610935}{IEEE 754} 32-bit floating point number is a syntax error.
\item {\PFAc \{"double":$\!$ NUMBER\}} where {\PFAc NUMBER} is a JSON floating-point number.  The return type is {\bf double}; a value that is too large, too small, or too precise to be represented as a \href{http://dx.doi.org/10.1109%2FIEEESTD.2008.4610935}{IEEE 754} 64-bit floating point number is a syntax error.
\item {\PFAc \{"string":$\!$ STRING\}} where {\PFAc STRING} is a quoted string.  The return type is {\bf string}.
\item {\PFAc \{"base64":$\!$ STRING\}} where {\PFAc STRING} is a \href{http://www.ietf.org/rfc/rfc3548.txt}{base-64 representation} of a binary input.  The return type is {\bf bytes}.
\item {\PFAc \{"type":$\!$ TYPE, "value":$\!$ VALUE\}} where {\PFAc TYPE} is an Avro schema and {\PFAc VALUE} is a JSON literal ({\it not} an expression) whose type matches {\PFAc TYPE}.  This form can be used to construct arrays, maps, records, etc.
\end{itemize}

Additionally, if an integer appears where an expression is expected, that number is an {\bf int} literal if 32-bit, a {\bf long} literal if 64-bit, and a syntax error if larger.  If a floating point number appears where an expression is expected, that number is a {\bf double} literal (not a {\bf float}, even if small enough).  A floating-point number that is too large, too small, or too precise to be a \href{http://dx.doi.org/10.1109%2FIEEESTD.2008.4610935}{IEEE 754} 64-bit floating point number causes a syntax error.

There is also a shortcut for making {\bf string} literals: {\PFAc [STRING]} (single-element JSON array containing a string).  Note that a string, by itself is interpreted as a \hyperlink{sec:symbol-ref}{symbol reference} (because symbol references are more common than string literals).  In some contexts, such as the argument list of a function, an expression or an array of expressions is expected.  If a {\PFAc [STRING]} appears in one of these contexts, it is interpreted as a one-element array containing a symbol reference, not a literal string.

\hypertarget{hsec:function-call}{}
\subsection{Function calls}
\label{sec:function-call}

Most of the functionality of PFA is provided through function calls; data-centric scoring engines, such as statistical models, would often involve only one function call.  Library functions are part of the PFA definition (\hyperlink{hsec:core-library}{see Sec.~\ref{sec:core-library} et seq.}); user functions are defined in a PFA document (\hyperlink{hsec:user-defined-fcns}{see Sec.~\ref{sec:user-defined-fcns}}).

A function call is expressed in JSON as a single-member object, like this
\begin{json}
{"functionName": [argument1, argument2, ... argumentN]}
\end{json}
for a function {\PFAc functionName} of {\PFAc N} (zero or more) arguments or
\begin{json}
{"functionName": argument1}
\end{json}
for a function of exactly one argument.

The arguments of a function call can either be an expression or a \hyperlink{hsec:referencing-functions}{function reference} (assuming that the called function accepts functions as arguments).

Functions have strict requirements on the number of arguments (always fixed; there are no optional arguments or varargs) and their types.  Functions return a value with a specific type, though that type may depend on the argument types (for library functions).

Function call expressions evaluate all of the function's arguments, from left to right, before calling the function, unless documented otherwise.  For instance, the {\PFAc and} function only evaluates its second argument if the first does not evaluate to {\PFAc false} and the {\PFAc or} function only evaluates its second argument if the first does not evaluate to {\PFAc true}.

The expression in each argument of a function call is evaluated in a separate, sealed-from-above and sealed-within scope (\hyperlink{hsec:symbol-scope}{see Sec.~\ref{sec:symbol-scope}}).  Thus, one cannot declare or reassign symbols as one progresses through the argument list.

\hypertarget{hsec:special-forms}{}
\subsection{Special forms}
\label{sec:special-forms}

Special forms are expressions that take arguments, perform an operation, and return a value, much like function calls.  Unlike function calls, however, they may have irregular syntax.  Whereas a function call is always a JSON object with one member name (the function name) and one member value (its arguments, interpreted as expressions), some special forms have multiple JSON object members and some special forms have custom interpretations for their member values.  These object members may appear in any order.  In addition, special forms have custom scoping rules when they do interpret values as expressions.

\hypertarget{hsec:call-args}{}
\subsection{Call a user-defined function that is specified at runtime}
\label{sec:call-args}

PFA excludes first class functions so that the call graph can be analyzed without running the analytic.  Therefore, all \hyperlink{hsec:function-call}{function calls} and \hyperlink{hsec:fcnref}{function references} are static strings in the JSON text.  However, it is sometimes useful to select a function to call at runtime, so the following special form is available to select a function from a small set.
\begin{json}
{"call": expression, "args": [argument1, argument2, ... argumentN]}
\end{json}
The {\PFAc expression} must resolve to an enumeration type, and the values of the enumeration type must be user-defined functions (without the ``{\PFAc u.}'' prefix).

All functions referenced by the enumeration type must accept the argument types defined by {\PFAc args}.  The return type of this special form is the narrowest supertype of the return types of all referenced functions.  Therefore, the types are verified for all possible values of the {\PFAc expression}.

In the call graph, this special form is presented as the union of all members of the enumeration type.  Therefore, if the enumeration type has symbols ``one'', ``two'', and ``three'', then there must be user-defined functions accepting the arguments presented with compatible return types, and the call graph would include ``u.one'', ``u.two'', and ``u.three'', as well as any functions called in the argument list.  Even if function ``u.three'' is never called at runtime, this special form reports it because it {\it might} be called.

\hypertarget{hsec:new-form}{}
\subsection{Creating arrays, maps, and records}
\label{sec:new-form}

\subsubsection{Creating arrays/maps/records from expressions: the ``new'' special form}

Arrays, maps, and records can be created with the {\PFAc \{"type":$\!$ TYPE, "value":$\!$ VALUE\}} literal form \hyperlink{hsec:literals}{described above}, but the {\PFAc VALUE} must be a JSON literal and not an expression.  Thus, the literal form cannot depend on any inputs.  The ``new'' special form exists to create arrays, maps, and records from expressions:
\begin{json}
{"new": ARRAY, "type": ARRAY-TYPE}
{"new": OBJECT, "type": MAP-OR-RECORD-TYPE}
\end{json}
where {\PFAc ARRAY} is a JSON array of expressions whose type is accepted by Avro schema {\PFAc ARRAY-TYPE}, and {\PFAc OBJECT} is a JSON object whose member values are expressions matching Avro schema {\PFAc MAP-OR-RECORD-TYPE}.

\begin{example}
The following returns an array of powers of {\PFAc x}, which has type {\bf double}.
\begin{json}
{"new": [1, "x", {"**": ["x", 2]}], "type": {"type": "array", "items": "double"}}
\end{json}
\end{example}

\begin{example}
The following returns a map from names to powers of {\PFAc x}, which has type {\bf double}.
\begin{json}
{"new": {"p0": 1, "p1": "x", "p2": {"**": ["x", 2]}},
 "type": {"type": "array", "items": "double"}}
\end{json}
\end{example}

\begin{example}
The following initializes a record of type {\PFAc R} with a {\bf string} stored in {\PFAc x} and its length.
\begin{json}
{"new": {"theString": "x", "theLength": {"s.len": "x"}},
 "type": {"type": "record", "name": "R", "fields":
     [{"name": "theString", "type": "string"},
      {"name": "theLength", "type": "int"}]}}
\end{json}
\end{example}

\hypertarget{hsec:let-set}{}
\subsection{Symbol assignment and reassignment}
\label{sec:let-set}

\subsubsection{Creating symbols: the ``let'' special form}

The ``let'' special form creates new symbols and assigns an initial value.  The ``set'' special form changes the value associated with a set of symbols.  There are no type declarations for new symbols because its types are \hyperlink{hsec:type-inference}{inferred} from the initial value.

A ``let'' has the following syntax:
\begin{json}
{"let": {"name1": VALUE1, "name2": VALUE2, ...}}
\end{json}
where {\PFAc VALUE1}, {\PFAc VALUE2}, etc. are expressions.  These expressions must not depend on symbols defined in the same ``let'' form, and they may be evaluated in any order.  (The symbols can be referenced after the end of the ``let'' form and before the end of its containing form.)  The {\PFAc VALUE} expressions are \hyperlink{hsec:symbol-scope}{sealed-within}: they may not declare new symbols unless wrapped in a ``do'' special form, and cannot change externally declared symbols.

A ``let'' that only declares one symbol still requires a nested JSON object.  The ``let'' form has return type {\bf null}.  It must declare at least one symbol.

\subsubsection{Changing symbol bindings: the ``set'' special form}

A ``set'' has the following syntax:
\begin{json}
{"set": {"name1": VALUE1, "name2": VALUE2, ...}}
\end{json}
where {\PFAc VALUE1}, {\PFAc VALUE2}, etc. are expressions.  These expressions may depend on symbols that are rebound in the same ``set'' form, but if so, they are provided with the old values of those symbols, as defined immediately before the ``set'' form.  The assignments within a ``set'' may be evaluated in any order.  The {\PFAc VALUE} expressions are \hyperlink{hsec:symbol-scope}{sealed-within}, just like the ``let'' form.

A ``set'' that only changes one symbol still requires a nested JSON object.  The ``set'' form has return type {\bf null}.  It must reassign at least one symbol.

\begin{example}
If the following appears in a JSON array of expressions, the final values of {\PFAc x} and {\PFAc y} are 2 and 2 (not 2 and 3 or 3 and 2).
\begin{json}
{"let": {"x": 1, "y": 1}},
{"set": {"x": {"+": ["x", "y"]}, "y": {"+": ["x", "y"]}}}
\end{json}
Regardless of whether {\PFAc x} is reassigned first or {\PFAc y} is reassigned first, each sum sees both {\PFAc x} and {\PFAc y} as having a value of 1 at the time of assignment.
\end{example}

\hypertarget{hsec:attr-form}{}
\subsection{Extracting from and updating arrays, maps, and records}
\label{sec:attr-form}

\subsubsection{Retrieving nested values: the ``attr'' special form}

The ``attr'' special form extracts a value from an array, a map, a record, or any combination of these three.  The ``attr-to'' special form returns an object with one element changed (leaving the original untouched).

The form of ``attr'' is
\begin{json}
{"attr": EXPRESSION, "path": INDEXES}
\end{json}
where {\PFAc EXPRESSION} is the array, map, or record to extract from and {\PFAc INDEXES} is a JSON array of expressions with {\bf int} type or {\bf string} type and string literals.  These {\PFAc INDEXES} specify a path through the nested objects.  If nesting is only one level deep, {\PFAc INDEXES} must have exactly one element.  It is a syntax error for {\PFAc INDEXES} to have zero elements.

If the type at a particular nesting level is an {\bf array}, the path index must resolve to an {\bf int}, though it can perform arbitrary calculations to produce the {\bf int}.  If the type at a particular nesting level is a {\bf map}, the path index must resolve to a {\bf string}.  If the type at a particular nesting level is a {\bf record}, the path index must be a literal {\bf string} (not just an expression that resolves to a {\bf string}), and that string must be a field name of the record.  Since it is a literal string, static analysis can verify that the field name exists and a PFA system should raise a type error if no such field exists.  The nesting level is increased for each array element of the path, and the return type of ``attr'' is the type of the deepest object referenced by the path.

If an array index is out of bounds (at any level of dereferencing along the path), an ``array index not found'' (code \#2000) runtime error is raised. If a map key is not found (at any level of dereferencing along the path), a ``map key not found'' (code \#2001) runtime error is raised. If a record field is not valid, it is a semantic error, a scoring engine cannot be built.

As a convenience, ``attr'' forms may also be expressed as a dot-delimited string resembling a symbol reference.  The first substring is taken to be a symbol reference {\PFAc EXPRESSION} and the rest are taken to be elements of the {\PFAc INDEXES} array (literal expressions only).  PFA systems should implement this short-cut.

\begin{example}
The following are equivalent:
\begin{json}
"x.4.key.field"
\end{json}
and
\begin{json}
{"attr": "x", "path": [4, ["key"], ["field"]]}
\end{json}
and
\begin{json}
{"attr": {"attr": {"attr": "x", "path": [4]}, "path": [["key"]]}, "path": [["field"]]}
\end{json}
If the type of {\PFAc x} is
\begin{json}
{"type": "array", "items": {"type": "map", "values": {"type": "record", "name": "R",
     "fields": [{"name": "field", "type": X}]}}}
\end{json}
then the example is valid and the return type is {\PFAtp X}.

(Note: {\PFAc ["key"]} and {\PFAc ["field"]} are short-cuts for {\PFAc \{"string":$\!$ "key"\}} and {\PFAc \{"string":$\!$ "field"\}}, respectively; \hyperlink{hsec:literals}{see Sec.~\ref{sec:literals}}.)
\end{example}

\subsubsection{Copy with different nested values: the ``attr-to'' special form}

The form of ``attr-to'' is:
\begin{json}
{"attr": EXPRESSION, "path": INDEXES, "to": VALUE-OR-FUNCTION}
\end{json}
with the same meaning for {\PFAc EXPRESSION} and {\PFAc INDEXES} as in ``attr''.  If the attribute evaluates to {\PFAtp X} at the end of its path, the {\PFAc VALUE-OR-FUNCTION} argument must either be an expression of type {\PFAtp X} or a function that maps {\PFAtp X} to {\PFAtp X}.  If is an expression, then the form will return a structure like the original, but with the specified subelement changed to the new value.  If {\PFAc VALUE-OR-FUNCTION} is a function, then the function is evaluated, passing in the old value of the subelement and updating the structure with the function's return value.

The {\PFAc INDEXES} must contain at least item.  There is no equivalent of using the dot-delimited string as a short-cut.  The ``attr-to'' form returns a whole new structure with one subelement changed; it has the same type as {\PFAc EXPRESSION}.  It must be emphasized that ``attr-to'' does not change the {\PFAc EXPRESSION} or the object it refers to, nor does it reassign any symbols; it returns a new value.

If an array index is out of bounds (at any level of dereferencing along the path), an ``array index not found'' (code \#2002) runtime error is raised. If a map key is not found (at any level of dereferencing along the path), a ``map key not found'' (code \#2003) runtime error is raised. If a record field is not valid, it is a semantic error, a scoring engine cannot be built.

\begin{example}
If {\PFAc x} is an array, we can effectively change one element of {\PFAc x} to {\PFAc xn} by
\begin{json}
{"set": {"x": {"attr": "x", "path": ["n"], "to": "xn"}}}
\end{json}
\end{example}

\begin{example}
If the {\PFAc "x.4.key.field"} subelement is a {\PFAc int}, following are equivalent:
\begin{json}
{"attr": "x", "path": [4, ["key"], ["field"]], "to": {"+": ["x.4.key.field", 1]}}
\end{json}
and
\begin{json}
{"attr": "x", "path": [4, ["key"], ["field"]], "to":
     {"params": [{"z": "int"}], "ret": "int", "do": {"+": ["z", 1]}}}
\end{json}
The first version represents the same path twice (the second time with dot-notation for brevity), while the second version represents the path once and applies an updator function when it gets to the end of the path.  This updator function could be referenced by name with \hyperlink{hsec:fcnref}{fcnref} for code re-use.
\end{example}

\hypertarget{hsec:cell-pool-forms}{}
\subsection{Extracting from and updating cells and pools}
\label{sec:cell-pool-forms}

Cells and pools (\hyperlink{hsec:cells-pools}{see Sec.~\ref{sec:cells-pools}}) are referenced with ``cell'' and ``pool'' special forms and updated with ``cell-to'', ``pool-to'', and ``pool-del'' special forms.  Subelements in a cell or pool are referenced/updated with a path of the same form as ``\hyperlink{hsec:attr-form}{attr}'', though the ``cell'' and ``cell-to'' forms may be given without any path to specify the cell as a whole.

\subsubsection{Retrieving cell values: the ``cell'' special form}

The ``cell'' special form has the following syntax.
\begin{json}
{"cell": NAME}
\end{json}
or
\begin{json}
{"cell": NAME, "path": INDEXES}
\end{json}
where {\PFAc NAME} is the name of the cell and {\PFAc INDEXES} is a JSON array of {\bf int} and {\bf string} valued expressions (for arrays and maps) and {\bf string} literals (for records).  If a {\PFAc path} is not given, this form returns the value of the specified cell.  If a {\PFAc path} is given, then it walks down the {\PFAc INDEXES} of the {\PFAc path} in the same way as ``attr''.  Unlike ``attr'', {\PFAc INDEXES} may be an empty JSON array, in which case the behavior is the same as if {\PFAc path} had not been specified.

If an array index is out of bounds (at any level of dereferencing along the path), an ``array index not found'' (code \#2004) runtime error is raised. If a map key is not found (at any level of dereferencing along the path), a ``map key not found'' (code \#2005) runtime error is raised. If a record field is not valid, it is a semantic error, a scoring engine cannot be built.

\subsubsection{Changing cell values: the ``cell-to'' special form}

The ``cell-to'' special form has the following syntax.
\begin{json}
{"cell": NAME, "to": VALUE-OR-FUNCTION}
\end{json}
or
\begin{json}
{"cell": NAME, "path": INDEXES, "to": VALUE-OR-FUNCTION}
\end{json}
where {\PFAc VALUE-OR-FUNCTION} is expression of type {\PFAtp X} or a function that maps {\PFAtp X} to {\PFAtp X}, assuming that the cell or subelement has type {\PFAtp X}.  Like ``attr-to'', the {\PFAc to} field replaces the cell or subelement at the end of the path with {\PFAc VALUE-OR-FUNCTION} if it is a value or evaluates {\PFAc VALUE-OR-FUNCTION} on the subelement if it is a function.  Like ``attr-to'', the return value is the new cell value.  Unlike ``attr-to'', the cell is changed in-place: subsequent calls to extract the cell value will get the new value, rather than the old one.  If the old value (or its parts) were previously copied into a local symbol, those copies are unchanged.

If an array index is out of bounds (at any level of dereferencing along the path), an ``array index not found'' (code \#2006) runtime error is raised. If a map key is not found (at any level of dereferencing along the path), a ``map key not found'' (code \#2007) runtime error is raised. If a record field is not valid, it is a semantic error, a scoring engine cannot be built.

\begin{example}
For example, suppose that {\PFAc myCell} is a cell containing an array of {\bf string} and {\PFAc n} is an index within the bounds of the array.
\begin{json}
{"let": {"x": {"cell": "myCell"}, "y": {"cell": "myCell", "path": ["n"]}}},
{"cell": "myCell", "path": ["n"], "to": {"string": "hello"}}
\end{json}
The first line retrieves the value of the cell and a subelement of the cell, putting them in local symbols {\PFAc x} and {\PFAc y}.  The second line changes {\PFAc myCell} in such a way that element {\PFAc n} (only) is now {\PFAc "hello"}.  However, both {\PFAc x} and {\PFAc y} are unchanged--- they continue to reference the old value of {\PFAc myCell} and its components.
\end{example}

For ``attr-to'', the difference between the value form and the function form of {\PFAc VALUE-OR-FUNCTION} is just a matter of style (whether the path is repeated or the function can be re-used).  For shared cells, choosing between the value form and the function form of {\PFAc VALUE-OR-FUNCTION} in ``cell-to'' could make a difference in the behavior of the scoring engine.  If a cell is extracted and replaced in two steps, then it is possible for another scoring engine sharing that value to modify it between the extraction step and the replacement step.  The function form, however, is atomic: all other attempts to modify the value wait until it is done.

\begin{example}
Suppose that {\PFAc myCell} is a shared cell that we want to increment by 1.  If we use
\begin{json}
{"cell": "myCell", "to": {"+": [{"cell": "myCell"}, 1]}}
\end{json}
in multiple scoring engines, then it is possible that their calls to ``cell'' and ``cell-to'' might interleave.  In this sequence of operations:
\begin{enumerate}
\item value of {\PFAc myCell} is 5
\item scoring engine A gets the value of {\PFAc myCell} (5)
\item scoring engine B gets the value of {\PFAc myCell} (5)
\item scoring engine A adds 1 to 5 and sets the value of {\PFAc myCell} to the result (6)
\item scoring engine B adds 1 to 5 and sets the value of {\PFAc myCell} to the result (6)
\end{enumerate}
{\PFAc myCell} is only incremented once, though two scoring engines attempted to increment it.  If steps 3 and 4 were reversed (a race condition), the final result would be 7, rather than 6.

Instead, we should increment a cell with the function form:
\begin{json}
{"cell": "myCell", "to":
     {"params": [{"x": "int"}], "ret": "int", "do": {"+": ["x", 1]}}}
\end{json}
\end{example}

The same applies to subelements of a cell specified by a {\PFAc path}.  If a {\PFAc path} is used, the granularity of the writers lock is at the level of the whole cell: two scoring engines cannot modify different parts of the same cell at the same time.  Calls to ``cell'' (readers) are never blocked: they always see the old version of the cell until the ``cell-to'' function finishes (\hyperlink{hsec:concurrent}{see Sec.~\ref{sec:concurrent}}).

The functions passed to ``cell-to'' are restricted: they should not be allowed to call any ``cell-to'' or ``path-to'' at any level of their call graphs.  (That is, they cannot modify cells or pools and the functions that they call cannot modify cells or pools, including any functions those functions call, etc.)  This constraint should be enforced by a PFA system that supports shared cells, since it excludes the possibility of deadlock.

\subsubsection{Retrieving pool values: the ``pool'' special form}

The ``pool'' special form is similar to ``cell'', except that a {\PFAc path} is always required.
\begin{json}
{"pool": NAME, "path": INDEXES}
\end{json}
The {\PFAc INDEXES} must not be empty, and the first item must be a literal string naming the desired object in the pool's namespace.

If an array index is out of bounds (at any level of dereferencing along the path), an ``array index not found'' (code \#2008) runtime error is raised. If a map key is not found (at any level of dereferencing along the path, including the pool item itself), a ``map key not found'' (code \#2009) runtime error is raised. If a record field is not valid, it is a semantic error, a scoring engine cannot be built.

\subsubsection{Creating or changing pool values: the ``pool-to'' special form}

The ``pool-to'' special form is similar to ``cell-to'', except that the {\PFAc path} is always required and an {\PFAc init} is required to handle the case in which the desired pool element is missing.
\begin{json}
{"pool": NAME, "path": INDEXES, "to": FUNCTION, "init": VALUE}
\end{json}
Unlike a cell, a pool element might not exist at runtime.  If it does not exist, the element is created with initial value {\PFAc VALUE} and then the {\PFAc to} replacement or function is applied.  The {\PFAc VALUE} specified by {\PFAc init} must have the type of a pool element.  The ``pool-to'' form changes the value of the pool element in-place (like ``cell-to'') and returns the new value of the pool element.

The same concurrency issues apply to shared pools as to shared cells.  The check for existence and update or the check for existence, creation, and update are all performed in one atomic operation.  The granularity of the writers lock is on a single pool element, not the whole pool and not a part of the element.

Some PFA systems may implement shared cells and pools with a networked database.  If so, they can take advantage of the {\PFAc path} in the ``cell'' special form or the ``pool'' special form to only transfer the relevant subelement of the cell or pool over the network, rather than sending the whole data structure and extracting the subelement afterward.

If an array index is out of bounds (at any level of dereferencing along the path), an ``array index not found'' (code \#2010) runtime error is raised. If a map key is not found (at any level of dereferencing along the path), a ``map key not found'' (code \#2011) runtime error is raised. If a record field is not valid, it is a semantic error, a scoring engine cannot be built.

\subsubsection{Removing pool values: the ``pool-del'' special form}

The ``pool-del'' special form specifies a pool item for removal.
\begin{json}
{"pool": NAME, "del": EXPRESSION}
\end{json}
The {\PFAc EXPRESSION} must evaluate to a string, naming the pool item, and the special form returns {\PFAc null}.

The same concurrency rules apply to ``pool-del'' as to ``pool-to''.  If scoring engine A begins a ``pool-to'' on an item before scoring engine B begins a ``pool-del'' on the same item, the end result is that the item will be deleted (either by letting the update continue and then deleting the item when done or by intelligently stopping the update). If scoring engine A begins a ``pool-del'' on an item before scoring engine B begins a ``pool-to'' on the same item, the update will proceed as though the item never existed (that is, using the ``pool-to'' {\PFAc init}).

Some PFA systems may implement shared pools with a networked database.  If so, the ``pool-del'' is an atomic transaction that must be queued in the same queue with ``pool-to'' (for the same item). No errors are raised when the pool item is not found.

\subsection{Tree-like structures in the program flow}

\subsubsection{Expanding an expression into a mini-program: the ``do'' special form}

A ``do'' special form allows the PFA document author to insert a series of expressions where one expression is expected.  It has the following syntax.
\begin{json}
{"do": ARRAY-OF-EXPRESSIONS}
\end{json}
where {\PFAc ARRAY-OF-EXPRESSIONS} is a JSON array of expressions and the whole form is one expression.  The return value is the value of the last expression in the JSON array, which must not be empty.

It is also possible for {\PFAc ARRAY-OF-EXPRESSIONS} to be replaced with a single expression, though doing so would defeat the purpose of a ``do'' block.  This option exists for symmetry with other, similar forms.

\begin{example}
A ``do'' form is also useful for declaring symbols in a sealed-within scope (\hyperlink{hsec:symbol-scope}{see Sec.~\ref{sec:symbol-scope}}).  For instance, new symbols usually cannot be declared in a function's argument list, but sometimes it is useful to insert a mini-program as an argument (in a purely functional style).  For instance,
\begin{json}
{"someFunction": [
     "simpleArgument",
     {"do": [
          {"let": {"x": 0}},
          {"while": {"notDone": "x"}, "do": {"set": {"x": {"iterate": "x"}}}}
          "x"
     ]},
     "simpleArgument"]}
\end{json}
The first and third arguments to {\PFAc someFunction} are just references to a symbol named {\PFAc simpleArgument}, but the second argument is a mini-program that calls {\PFAc iterate} on a value until {\PFAc notDone} is {\PFAc false}.
\end{example}

\begin{example}
Although a ``do'' block can loosen a sealed-within scope, it cannot loosen its sealed-from-above attribute.  Symbols declared outside of a sealed-from-above scope cannot be modified in that scope, even within a ``do'' block.  For example, the following is invalid (a semantic error).
\begin{json}
{"let": {"outerSymbol": 0}},
{"someFunction": [
     {"do": [
          {"set": {"outerSymbol": 1}},
          "outerSymbol"
     ]}]}
\end{json}
because the scope of function arguments are sealed-from-above.
\end{example}

\begin{example}
A ``do'' block does not apply any additional constraints on the scope of symbols.  The following attempt to modify an outside symbols is valid.
\begin{json}
{"let": {"outerSymbol": 0}},
{"do": [
     {"set": {"outerSymbol": 1}},
     "outerSymbol"
]}
\end{json}
\end{example}

\subsection{Branching the program flow}

Conditionals cause a branch in the program flow, in which the expressions that are evaluated depend on values at runtime.

\subsubsection{Conditional with one or two cases: the ``if'' special form}

The ``if'' special form has the following syntax:
\begin{json}
{"if": CONDITION, "then": EXPRESSION-OR-EXPRESSIONS}
\end{json}
or
\begin{json}
{"if": CONDITION, "then": EXPRESSION-OR-EXPRESSIONS, "else": EXPRESSION-OR-EXPRESSIONS}
\end{json}
where {\PFAc CONDITION} is a single expression that evaluates to {\bf boolean} and {\PFAc EXPRESSION-OR-EXPRESSIONS} is either a single expression or a JSON array of expressions.  The form without an {\PFAc else} clause returns {\PFAc null}, but the form with an {\PFAc else} clause returns the \hyperlink{hsec:narrowest-supertype}{narrowest supertype} of the {\PFAc then} and {\PFAc else} clauses.

The {\PFAc CONDITION} expression is evaluated in a sealed-from-above, sealed-within scope, but the {\PFAc then} and {\PFAc else} clauses are unsealed (\hyperlink{hsec:symbol-scope}{see Sec.~\ref{sec:symbol-scope}}).  That is, an outside symbol cannot be modified in the {\PFAc CONDITION}, but it can be modified in the {\PFAc then} and {\PFAc else} clauses.  In an imperative programming style, {\PFAc then} and {\PFAc else} are primarily used to assign values to symbols defined outside the ``if''.  In a functional programming style, the return value of the entire ``if'' form would be assigned to a symbol.

\subsubsection{Conditional with many cases: the ``cond'' special form}

The ``cond'' special form allows one to chain a series of conditionals.
\begin{json}
{"cond": [{"if": CONDITION1, "then": EXPRS1}, {"if": CONDITION2, "then": EXPRS2}, ...]}
\end{json}
or
\begin{json}
{"cond": [{"if": CONDITION1, "then": EXPRS1}, {"if": CONDITION2, "then": EXPRS2}, ...],
 "else": EXPRS}
\end{json}
The ``if'' forms within a ``cond'' are like stand-alone ``if'' forms except that they cannot have {\PFAc else} clauses.  The ``cond'' form can have a single {\PFAc else} clause.  Much like an ``if'', the return value of ``cond'' is {\PFAc null} if {\PFAc else} is absent, and it is the narrowest supertype of all {\PFAc then} clauses and the {\PFAc else} clause if the {\PFAc else} is present.  A ``cond'' must have at least one ``if''.  The {\PFAc CONDITION1}, {\PFAc CONDITION2}, \ldots\ are all single expressions that are sealed-from-above and sealed-within, and the {\PFAc EXPRS1}, {\PFAc EXPRS2}, \ldots\ and {\PFAc EXPRS} are either single expressions or JSON arrays of expressions that are unsealed.  The {\PFAc then} clause corresponding to the first (and only the first) successful {\PFAc if} condition is evaluated, or the {\PFAc else} clause is evaluated if no {\PFAc if} conditions are successful.

\subsection{Loops in the program flow}

Loops repeatedly evaluate a set of expressions until some condition is met at runtime.

\subsubsection{Generic pre-test loop: the ``while'' special form}

The pre-test ``while'' special form has the following syntax.
\begin{json}
{"while": CONDITION, "do": EXPRESSION-OR-EXPRESSIONS}
\end{json}
where {\PFAc CONDITION} is a single expression that evaluates to {\bf boolean} and {\PFAc EXPRESSION-OR-EXPRESSIONS} is either a single expression or a JSON array of expressions.  The return value of the ``while'' form is {\PFAc null}: it can only be used to modify state.  The scope of the {\PFAc CONDITION} is sealed-from-above and sealed-within, but the scope of the {\PFAc EXPRESSION-OR-EXPRESSIONS} is unsealed (\hyperlink{hsec:symbol-scope}{see Sec.~\ref{sec:symbol-scope}}).

The {\PFAc CONDITION} is evaluated before the {\PFAc EXPRESSION-OR-EXPRESSIONS} and the two are evaluated in alternation until {\PFAc CONDITION} returns {\PFAc false}.  If {\PFAc CONDITION} returns {\PFAc false} the first time it is called, the {\PFAc EXPRESSION-OR-EXPRESSIONS} would never be evaluated.

\subsubsection{Generic post-test loop: the ``do-until'' special form}

The post-test ``do-until'' special form has the following syntax.
\begin{json}
{"do": EXPRESSION-OR-EXPRESSIONS, "until": CONDITION}
\end{json}
Like ``while'', the {\PFAc CONDITION} is a single expression that evaluates to {\bf boolean} and {\PFAc EXPRESSION-OR-EXPRESSIONS} is either a single expression or a JSON array of expressions.  The return value is {\PFAc null}.  The difference is that the alternation between evaluating {\PFAc EXPRESSION-OR-EXPRESSIONS} and {\PFAc CONDITION} starts with the {\PFAc EXPRESSION-OR-EXPRESSIONS} and continues until {\PFAc CONDITION} is {\PFAc true}.  Thus, the {\PFAc EXPRESSION-OR-EXPRESSIONS} is evaluated at least once, even if {\PFAc CONDITION} is always {\PFAc true}.

\subsubsection{Iteration with dummy variables: the ``for'' special form}

For loops are specialized loops that declare new symbols for use in the loop body.  There are three basic types: ``for'' loops, which are usually used to increment a numerical index, ``foreach'' loops, which iterate over values of an array, and ``forkey-forval'' loops, which iterate over key-value pairs of a map.

The ``for'' special form has the following syntax.
\begin{json}
{"for": NAME-TO-EXPRESSION, "while": CONDITION, "step": NAME-TO-EXPRESSION,
 "do": EXPRESSION-OR-EXPRESSIONS}
\end{json}
The {\PFAc for} clause's {\PFAc NAME-TO-EXPRESSION} is a JSON object whose members are new symbols to declare, the {\PFAc step} clause's {\PFAc NAME-TO-EXPRESSION} is a JSON object whose members are symbols to modify, and {\PFAc while} is a {\bf boolean}-valued single expression that stops the iteration when it becomes {\PFAc false}.  The {\PFAc do} expression or expressions is the body of the loop, and the return value of the ``for'' form is {\PFAc null}.

The {\PFAc for} clause's {\PFAc NAME-TO-EXPRESSION} is similar to a \hyperlink{hsec:let-set}{let expression} in that it declares and initializes new symbols.  The names of the symbols are the member names of the {\PFAc NAME-TO-EXPRESSION} and the initial values are the evaluated results of the member values.  The scope of the initialization expressions are sealed-from-above and sealed-within (\hyperlink{hsec:symbol-scope}{see Sec.~\ref{sec:symbol-scope}}), and they are evaluated before anything else in the ``if'' form but the order of initialization expressions is not guaranteed.  The symbols declared by the {\PFAc for} clause can only be referenced in the {\PFAc while}, {\PFAc step}, and {\PFAc do} clauses.

The {\PFAc step} clause's {\PFAc NAME-TO-EXPRESSION} is similar to a \hyperlink{hsec:let-set}{set expression} in that it changes symbols, usually by incrementing them.  The names of the symbols to modify are the member names of the {\PFAc NAME-TO-EXPRESSION} and their new values are the evaluated results of the member values.  The scope of the updator expressions are sealed-from-above and sealed-within, and if any updator expressions depend on a symbol that is also being updated, they will see the old value of the symbol.  That way, they can be evaluated in any order without conflict, which is important because their order is not guaranteed.

The {\PFAc while} expression is sealed-from-above and sealed-within.  It is evaluated before the loop body ({\PFAc do}), so it is possible for the loop body to never be evaluated.

The {\PFAc do} expression or expressions is evaluated while the {\PFAc CONDITION} is {\PFAc true}.  The symbols declared by the {\PFAc for} clause may be referenced and even modified, though it is good practice to modify these loop variables only in the {\PFAc step} clause.  The body of the loop is unsealed, meaning that it can modify symbols defined outside of its scope.

\begin{example}
This is a basic for loop that indexes the loop iteration with an integer {\PFAc i}.
\begin{json}
{"for": {"i": 0}, "while": {"<": ["i", 10]}, "step": {"i": {"+": ["i", 1]}},
 "do": [
     {"something": i}
     {"somethingElse": i}
 ]}
\end{json}
The {\PFAc something} and {\PFAc somethingElse} functions are called with arguments from 0 (inclusive) until 10 (exclusive).
\end{example}

\subsubsection{Iteration over arrays: the ``foreach'' special form}

The ``foreach'' special form iterates over elements of an array.  It has the following syntax.
\begin{json}
{"foreach": NAME, "in": ARRAY-EXPRESSION, "do": EXPRESSION-OR-EXPRESSIONS}
\end{json}
or
\begin{json}
{"foreach": NAME, "in": ARRAY-EXPRESSION, "do": EXPRESSION-OR-EXPRESSIONS,
 "seq": TRUE-OR-FALSE}
\end{json}
where {\PFAc NAME} is a string naming the new symbol to declare, {\PFAc ARRAY-EXPRESSION} is a single expression whose type is an {\bf array}, the {\PFAc do} expression or expressions is the body of the loop, and the return value of the ``for'' form is {\PFAc null}.  The {\PFAc seq} flag, if absent or set to {\PFAc true}, ensures that the loop order through the array is sequential.  This flag affects the scope of symbols, so that a PFA system has the option to evaluate the loop body in parallel if the {\PFAc seq} flag is present and {\PFAc false}.

The symbol declared by the {\PFAc foreach} clause can be referenced only in the body of the loop.  The {\PFAc ARRAY-EXPRESSION} is sealed-from-above and sealed-within.  If the return type of the {\PFAc ARRAY-EXPRESSION} is an array of {\PFAtp X}, the symbol declared by {\PFAc foreach} has type {\PFAc X}.

The loop body is evaluated once for every element in the array specified by the {\PFAc in} clause.  Since the array might be empty, the loop body might never be evaluated.  If {\PFAc seq} is absent or {\PFAc false}, the order of elements is not guaranteed and the loop scope is sealed-from-above.  Some PFA implementations may take advantage of this fact to parallelize the loop.  (If so, all cells and pools referenced within the loop must be treated as though they are shared.)  If {\PFAc seq} is absent or {\PFAc true}, then the elements of the array are processed in order and the loop scope is not sealed-from-above.

\subsubsection{Iteration over maps: the ``forkey-forval'' special form}

The ``forkey-forval'' special form iterates over key-value pairs of a map.  It has the following syntax.
\begin{json}
{"forkey": NAME1, "forval": NAME2, "in": MAP-EXPRESSION,
 "do": EXPRESSION-OR-EXPRESSIONS}
\end{json}
where {\PFAc NAME1} is a string naming a new symbol that iterates through map keys, {\PFAc NAME2} is a string naming a new symbol that iterates through map values, {\PFAc MAP-EXPRESSION} is a single expression whose type is a {\bf map}, the {\PFAc do} expression or expressions is the body of the loop, and the return value of the ``forkey-forval'' form is {\PFAc null}.

The symbols declared by the {\PFAc forkey} and {\PFAc forval} clauses can be referenced only in the body of the loop.  The {\PFAc MAP-EXPRESSION} is sealed-from-above and sealed-within.  If the return type of the {\PFAc MAP-EXPRESSION} is a map of {\PFAtp X}, the symbol declared by {\PFAc forval} has type {\PFAtp X}.  The symbol declared by {\PFAc forkey} has type {\bf string}.

The loop body is evaluated once for every key-value pair in the map specified by the {\PFAc in} clause.  Since the map might be empty, the loop body might never be evaluated.  The order of elements is not guaranteed, but the loop scope is unsealed.  An order-dependent calculation may yield different results every time it is evaluated, so it is good practice to only perform order-independent operations in a ``forkey-forval'' loop.

\hypertarget{hsec:casting}{}
\subsection{Type-safe casting}
\label{sec:casting}

Unrestricted type-casting would invalidate the guarantees that a static type check provides.  It is allowed in many popular programming languages, and if an incorrect type-cast is encountered at runtime, an exception (Java) or undefined behavior (C++) ensues.

However, it is possible to provide the advantages of type-casting without invalidating the static type check.  Instead of returning the type-cast object as a single expression, we split the program flow into branches, one for each possible down-cast type.  For instance, if a possibly-missing input datum has type {\bf union(null, double)}, we split the program flow into a branch that handles the {\bf null} case and a branch that handles the {\bf double} case.  Thus, the type-cast is a special kind of conditional.

\subsubsection{Narrowing a type: the ``cast-cases'' special form}

Down-casting (making a value's type more specific) is handled by the ``cast-cases'' special form, which has the following syntax.
\begin{json}
{"cast": EXPRESSION, "cases": [
     {"as": TYPE1, "named": NAME1, "do": EXPRESSION-OR-EXPRESSIONS1},
     {"as": TYPE2, "named": NAME2, "do": EXPRESSION-OR-EXPRESSIONS2},
     ...
]}
\end{json}
or
\begin{json}
{"cast": EXPRESSION, "cases": [
     {"as": TYPE1, "named": NAME1, "do": EXPRESSION-OR-EXPRESSIONS1},
     {"as": TYPE2, "named": NAME2, "do": EXPRESSION-OR-EXPRESSIONS2},
     ...],
 "partial": TRUE-OR-FALSE}
\end{json}
The {\PFAc cast} clause evaluates a single {\PFAc EXPRESSION} with some type {\PFAtp X}.  The {\PFAc as} clauses enumerate possible subtypes {\PFAtp Y}$_i$ of {\PFAtp X}.  If {\PFAtp X} does not accept {\PFAtp Y}$_i$, then branch $i$ can never be reached, which should result in a semantic exception.  If {\PFAc partial} is absent or {\PFAc false}, then the Avro type schemae named by {\PFAc as} clauses should be exhaustive, there must be at least two cases, and the ``cast-cases'' form returns the last value of the followed branch.  If {\PFAc partial} is present and {\PFAc true}, then the types named by {\PFAc as} clauses do not need to be exhaustive, there must be at least one case, and the ``cast-cases'' form returns {\PFAc null}.  Only one branch is followed: the one with the first matching type schema.

The {\PFAc named} clause takes a string that declares a new symbol with the given name.  The new symbol can be referenced only within the corresponding {\PFAc do} expression or expressions.  Since the scopes of the {\PFAc do} clauses do not overlap, cases may re-use names without shadowing.

The {\PFAc cast} expression is sealed-from-above and sealed-within, but the {\PFAc do} expressions are unsealed (\hyperlink{hsec:symbol-scope}{see Sec.~\ref{sec:symbol-scope}}).

\begin{example}
This replaces a missing value in the {\PFAc input} symbol by a default value, assuming that the PFA document's input type {\PFAc [null, double]} (union of {\bf null} and {\bf double}).  The ``cast-cases'' form is used as an expression that initializes {\PFAc normalizedInput}.
\begin{json}
{"let": {"normalizedInput":
     {"cast": "input", "cases": [
          {"as": "null", "named": "x", "do": -1000.0},
          {"as": "double", "named": "x", "do": "x"}
     ]}}}
\end{json}
\end{example}

\begin{example}
Alternatively, we could use an imperative programming style and overwrite a default value, like the following.
\begin{json}
{"let": {"normalizedInput": -1000.0}},
{"cast": "input", "cases":
     [{"as: "double", "named": "x", "do": {"set": {"normalizedInput": "x"}}}]
 "partial": true}
\end{json}
\end{example}

\subsubsection{Widening a type: the ``upcast'' special form}

It is sometimes (rarely) useful to up-cast a value, making it less specific.  This is handled by the ``upcast'' expression, which simply returns the casted value.
\begin{json}
{"upcast": EXPRESSION, "as": TYPE}
\end{json}
The Avro type schema specified by {\PFAc as} should accept the return type of {\PFAc EXPRESSION} and raise a semantic error if it does not.

\subsubsection{Checking missing values: the ``ifnotnull'' special form}

A special case that is frequently used in PFA is to cast a union of {\PFAtp X} and {\bf null} to {\PFAtp X}.  Null is used to represent missing values, so this would branch the program flow based on whether the value is missing or not.  Moreover, some datasets have many fields that could be missing and it is useful to isolate the case in which none of them are, in fact, missing.  This could be accomplished with nested ``cast-cases'' forms, but the nesting level would be very deep and unwieldy, even for automated processing.

To simplify the PFA document, the ``ifnotnull'' special form only performs a {\bf null}-removing cast, but it applies to one or more symbols simultaneously.  It has the following syntax.
\begin{json}
{"ifnotnull": {SYM1: EXPR1, ... SYMN: EXPRN}, "then": EXPRESSION-OR-EXPRESSIONS}
\end{json}
or
\begin{json}
{"ifnotnull": {SYM1: EXPR1, ... SYMN: EXPRN}, "then": EXPRESSION-OR-EXPRESSIONS,
 "else": EXPRESSION-OR-EXPRESSIONS}
\end{json}
where {\PFAc SYM1} \ldots\ {\PFAc SYMN} are as-yet undefined symbols, {\PFAc EXPR1} \ldots\ {\PFAc EXPRN} are single expressions, and \\ {\PFAc EXPRESSION-OR-EXPRESSIONS} are expressions or JSON arrays of expressions.

All of the {\PFAc EXPR1} \ldots\ {\PFAc EXPRN} expressions are evaluated, in an unspecified order, with sealed-from-above and sealed-within scope.  Each of these expressions must have a union type that includes {\bf null}, though they may have different types from one another.

If all of the {\PFAc EXPR1} \ldots\ {\PFAc EXPRN} expressions are not null, their values are assigned to new symbols {\PFAc SYM1} \ldots\ {\PFAc SYMN}, respectively.  If the type of some {\PFAc EXPR} is {\bf union(X, null)}, the corresponding {\PFAc SYM} has type {\bf X}.  If the type of some {\PFAc EXPR} is {\bf union(X, Y, \ldots\ null)}, the corresponding {\PFAc SYM} has type {\bf union(X, Y, \ldots)}.  These symbols are only defined in the scope of the {\PFAc then} clause.

If all of the {\PFAc EXPR1} \ldots\ {\PFAc EXPRN} expressions are not null, the {\PFAc then} clause is executed with the new symbols in scope.  If any of the {\PFAc EXPR1} \ldots\ {\PFAc EXPRN} expressions are null and the {\PFAc else} clause exists, the {\PFAc else} clause is executed without any new symbols in scope.  The {\PFAc then} and {\PFAc else} clauses have no scope constraints.

The ``ifnotnull'' form without an {\PFAc else} clause returns {\PFAc null}, but the form with an {\PFAc else} clause returns the \hyperlink{hsec:narrowest-supertype}{narrowest supertype} of the {\PFAc then} and {\PFAc else} clauses.

\subsubsection{Extracting values from binary: the ``unpack'' special form}

Sometimes inputs to a model are not provided as well-structured values but as a block of binary data.  The ``unpack'' special form interprets a {\bf bytes} object as a set of new variables that can be used in a block of expressions.  The syntax is
\begin{json}
{"unpack": BYTES-EXPRESSION, "format": [{SYM1: FORMAT1}, ... {SYMN: FORMATN}],
 "then": EXPRESSION-OR-EXPRESSIONS}
\end{json}
to simply split the flow (returning {\PFAc null}) or
\begin{json}
{"unpack": BYTES-EXPRESSION, "format": [{SYM1: FORMAT1}, ... {SYMN: FORMATN}],
 "then": EXPRESSION-OR-EXPRESSIONS, "else": EXPRESSION-OR-EXPRESSIONS}
\end{json}
to provide for the case in which the {\PFAc FORMAT} does not match the {\PFAc BYTES-EXPRESSION}.  In both cases, \\ {\PFAc BYTES-EXPRESSION} is an expression whose return value is {\bf bytes}, {\PFAc SYM1} \ldots\ {\PFAc SYMN} are as-yet undefined symbols, {\PFAc FORMAT1} \ldots \ {\PFAc FORMATN} are format-specifiers, described below, and {\PFAc EXPRESSION-OR-EXPRESSIONS} are expressions or JSON arrays of expressions.  The latter case returns the result of the {\PFAc then} clause or the {\PFAc else} clause, whose type is the \hyperlink{hsec:narrowest-supertype}{narrowest supertype} of the two.

Format specifiers are JSON strings that satisfy one of the following regular expressions, where {\PFAc \textbackslash E} is {\PFAc (<|>|!|little|big|network)?}, {\PFAc \textbackslash U} is {\PFAc unsigned}, and {\PFAc \textbackslash s} is any whitespace character.  If an endianness is not provided, big-endian is assumed.

\noindent \begin{longtable}{p{0.55\linewidth} p{0.22\linewidth} p{0.15\linewidth}}
{\PFAc FORMAT} & {\bf Result} & {\bf PFA Type} \\\hline
{\PFAc \textbackslash s*pad\textbackslash s*} & skips one byte & {\bf null} \\
{\PFAc \textbackslash s*boolean\textbackslash s*} & interprets one byte as true if nonzero & {\bf boolean} \\
{\PFAc \textbackslash s*(byte|int8)\textbackslash s*} & one byte as signed integer & {\bf int} \\
{\PFAc \textbackslash s*\textbackslash U\textbackslash s*(byte|int8)\textbackslash s*} & one byte as non-negative integer & {\bf int} \\
{\PFAc \textbackslash s*\textbackslash E\textbackslash s*(short|int16)\textbackslash s*} & two bytes as signed integer & {\bf int} \\
{\PFAc \textbackslash s*\textbackslash E\textbackslash s*(\textbackslash U\textbackslash s*short|\textbackslash U\textbackslash s*int16)\textbackslash s*} & two bytes as non-negative integer & {\bf int} \\
{\PFAc \textbackslash s*\textbackslash E\textbackslash s*(int|int32)\textbackslash s*} & four bytes as signed integer & {\bf int} \\
{\PFAc \textbackslash s*\textbackslash E\textbackslash s*(\textbackslash U\textbackslash s*int|\textbackslash U\textbackslash s*int32)\textbackslash s*} & four bytes as non-negative integer & {\bf long} \\
{\PFAc \textbackslash s*\textbackslash E\textbackslash s*(long|long\textbackslash s+long|int64)\textbackslash s*} & eight bytes as signed integer & {\bf long} \\
{\PFAc \textbackslash s*\textbackslash E\textbackslash s*(\textbackslash U\textbackslash s*long|\textbackslash U\textbackslash s*long\textbackslash s+long|\textbackslash U\textbackslash s*int64)\textbackslash s*} & eight bytes as non-negative integer & {\bf double} \\
{\PFAc \textbackslash s*\textbackslash E\textbackslash s*(float|float32)\textbackslash s*} & four bytes as \href{http://dx.doi.org/10.1109%2FIEEESTD.2008.4610935}{IEEE 754} floating point number & {\bf float} \\
{\PFAc \textbackslash s*\textbackslash E\textbackslash s*(double|float64)\textbackslash s*} & eight bytes as \href{http://dx.doi.org/10.1109%2FIEEESTD.2008.4610935}{IEEE 754} floating point number & {\bf double} \\
{\PFAc \textbackslash s*raw\textbackslash s*[0-9}+\textbackslash s*] & extract fixed number of bytes & {\bf bytes} \\
{\PFAc \textbackslash s*null\textbackslash s*?terminated\textbackslash s*} & extract bytes until terminated by zero & {\bf bytes} \\
 & (excluding terminus) &  \\
{\PFAc \textbackslash s*length\textbackslash s*?prefixed\textbackslash s*} & interpret first byte as a size, then extract that many bytes & {\bf bytes} \\
 & (excluding size byte) & \\
\end{longtable}

If the fixed-width format specifiers and variable-width pattern specifiers (null-terminated and length-prefixed) does not use exactly the number of bytes provided in the {\PFAc BYTES-EXPRESSION}, the {\PFAc then} clause will not be evaluated.  If an {\PFAc else} clause is present, this is the clause that would be evaluated in this case.

\subsubsection{Encoding values in binary: the ``pack'' special form}

The ``pack'' special form does the opposite of the ``unpack'' form: it encodes a set of values into a byte array.  It has this syntax:
\begin{json}
{"pack": [{FORMAT1: EXPRESSION1}, ... {FORMATN: EXPRESSIONN}]}
\end{json}
where {\PFAc FORMAT1} \ldots\ {\PFAc FORMATN} are format specifiers and {\PFAc EXPRESSION1} \ldots\ {\PFAc EXPRESSIONN} are expressions whose types must correspond to the format specifiers.

The ``pack'' special form has the same format specifiers as ``unpack'' except for one additional specifier:

\noindent \begin{longtable}{p{0.55\linewidth} p{0.22\linewidth} p{0.15\linewidth}}
{\PFAc FORMAT} & {\bf Result} & {\bf PFA Type} \\\hline
{\PFAc \textbackslash s*raw\textbackslash s*} & any number of bytes & {\bf bytes} \\
\end{longtable}

The return type of the ``pack'' special form is {\bf bytes}.

If the size of a fixed-width bytes format does not match the size of the bytes expression, a ``raw bytes does not have specified size'' (code \#3000) runtime error is raised. If a bytes expression for a length-prefixed format is too large, a ``length prefixed bytes is larger than 255 bytes'' (code \#3001) runtime error is raised.

\subsection{Miscellaneous special forms}

\hypertarget{hsec:inline-doc}{}
\subsubsection{Inline documentation: the ``doc'' special form}
\label{sec:inline-doc}

JSON has no means of including comments.  Auto-generated code usually doesn't need comments, but there may be occasions in which it is useful to embed inactive statements in a PFA document.

The ``doc'' special form has the following syntax.
\begin{json}
{"doc": STRING}
\end{json}
Unlike a comment in a programming language, it occupies a slot in the syntax tree.  If inactive expressions are ever needed (the equivalent of Python's {\PFAc pass} keyword), one could use a ``doc'' with an empty {\PFAc STRING}.  This form returns {\PFAc null}.

\hypertarget{hsec:exception-form}{}
\subsubsection{User-defined exceptions: the ``error'' special form}
\label{sec:exception-form}

PFA provides non-local exits to stop the evaluation of a {\PFAc begin}, {\PFAc action}, or {\PFAc end} routine that behave like exceptions (\hyperlink{hsec:exceptions}{see Sec.~\ref{sec:exceptions}}).  Some library functions raise exceptions, but the PFA author can also raise user-defined exceptions.  The PFA engine is free to halt execution or just skip to the next input datum upon encountering an exception.

The ``error'' special form raises user-defined exceptions.  It has the following syntax.
\begin{json}
{"error": STRING}
\end{json}
or
\begin{json}
{"error": STRING, "code": NEGATIVE-INTEGER}
\end{json}
The {\PFAc STRING} is the error message, and if a {\PFAc code} is provided, it provides a safer way to identify specific errors than a human-readable message. User-defined error codes are negative to distinguish themselves from the library functions.

The ``error'' form has no return type: specifically, its return type is a type that can never be instantiated, called a bottom type.  The \hyperlink{hsec:narrowest-supertype}{narrowest supertype} of the bottom type with {\PFAtp X} is {\PFAtp X}, and thus if an if statement has a ``then'' branch that ends in a value and an ``else'' branch that ends in an error, the type of the if statement is the type of the value.  The same is true of ``cond'' forms, ``cast'' blocks, and anything else that branches the program flow.  If place at a point that does not branch the program flow (e.g.\ at the end of a ``do'' form), then the type is converted into {\bf null}.

\hypertarget{hsec:try-form}{}
\subsubsection{Turning exceptions into missing values: the ``try'' special form}
\label{sec:try-form}

A running scoring engine should only encounter two types of errors: a runtime error in a library call or a user-defined error.  Sometimes, it is better to treat exceptional cases as missing values than non-local exits.  The ``try'' special form evaluates an expression or array of expressions, catches errors, and either returns the result of the calculation or {\PFAc null} to indicate a missing value.  It has the following syntax.
\begin{json}
{"try": EXPRESSION-OR-EXPRESSIONS}
\end{json}
or
\begin{json}
{"try": EXPRESSION-OR-EXPRESSIONS, "filter": ARRAY-OF-STRINGS-AND-INTEGERS}
\end{json}

The return type of the ``try'' form is a union of ``null'' and the type of the last expression in the block.  Thus, if the {\PFAc EXPRESSION-OR-EXPRESSIONS} calculates a numerical result (e.g.\ ``double''), the try returns a possibly missing numerical result (e.g.\ [``double'', ``null'']).  This missing value may be returned directly or wrapped in an ``ifnotnull'' form to build a traditional try-catch block: the ``ifnotnull'' would perform the catch logic.

\begin{example}
Example of a traditional try-catch block.
\begin{json}
{"ifnotnull": {result: {"try": TRY-LOGIC}},
 "then": result,
 "else": CATCH-LOGIC}
\end{json}
\end{example}

If a ``filter'' is provided, only the specified error messages would be caught--- the rest are passed through. The strings need to match the error message text exactly, and the integers match error codes.

\hypertarget{hsec:logs}{}
\subsubsection{Log messages: the ``log'' special form}
\label{sec:logs}

The only three outputs that a PFA scoring engine can emit are (1) normal output, the result of a calculation, (2) an exception, and (3) log messages.  Log messages should not be used for normal output, as they may or may not be handled by the host PFA system.  The PFA system has full discretion to ignore, filter, collate, forward, or merge log messages.

The ``log'' special form emits a log message.  It has the following syntax.
\begin{json}
{"log": EXPRESSION-OR-EXPRESSIONS}
\end{json}
or
\begin{json}
{"log": EXPRESSION-OR-EXPRESSIONS, "namespace": NAME}
\end{json}
The {\PFAc EXPRESSION-OR-EXPRESSIONS} are the expressions to dump to the log (remember to wrap plain strings in {\PFAc \{"string":$\!$ "} \ldots {\PFAc "\}} or {\PFAc ["} \ldots {\PFAc "]}); the optional {\PFAc NAMESPACE} is a token that may be used for filtering or collating.  The ``log'' form returns {\PFAc null}.

\pagebreak

\hypertarget{hsec:core-library}{}
\section{Core library}
\label{sec:core-library}

The core library contains functions that would, in most languages, be infix operators.  Following a LISP style of defining them as functions makes it easier to manipulate the expression tree with an automated algorithm.

\subsection{Basic arithmetic}

\subsubsection{Addition of two values ($+$)}
\hypertarget{+}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"+":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Add {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Float and double overflows do not produce runtime errors but result in positive or negative infinity, which would be carried through any subsequent calculations (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or NaN values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#18000:} Integer results above or below -2147483648 and 2147483647 (inclusive) produce an ``int overflow'' runtime error. \vspace{0.1 cm} \\ {\bf \#18001:} Long-integer results above or below -9223372036854775808 and 9223372036854775807 (inclusive) produce a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Subtraction ($-$)}
\hypertarget{-}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"-":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Subtract {\PFAp y} from {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Float and double overflows do not produce runtime errors but result in positive or negative infinity, which would be carried through any subsequent calculations (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or NaN values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#18010:} Integer results above or below -2147483648 and 2147483647 (inclusive) produce an ``int overflow'' runtime error. \vspace{0.1 cm} \\ {\bf \#18011:} Long-integer results above or below -9223372036854775808 and 9223372036854775807 (inclusive) produce a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Multiplication of two values (*)}
\hypertarget{*}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"*":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Multiply {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Float and double overflows do not produce runtime errors but result in positive or negative infinity, which would be carried through any subsequent calculations (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or NaN values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#18020:} Integer results above or below -2147483648 and 2147483647 (inclusive) produce an ``int overflow'' runtime error. \vspace{0.1 cm} \\ {\bf \#18021:} Long-integer results above or below -9223372036854775808 and 9223372036854775807 (inclusive) produce a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Floating-point division (/)}
\hypertarget{/}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"/":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc y \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Divide {\PFAp y} from {\PFAp x}, returning a floating-point number (even if {\PFAp x} and {\PFAp y} are integers). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This function returns an infinite value if {\PFAp x} is non-zero and {\PFAp y} is zero and NaN if both are zero.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Integer division (//)}
\hypertarget{//}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"//":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long\} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Divide {\PFAp y} from {\PFAp x}, returning the largest whole number {\PFAc N} for which {\PFAc N} $\leq$ {\PFAp x}/{\PFAp y} (integral floor division). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#18040:} If {\PFAp y} is zero, this function raises a ``integer division by zero'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Negation (u$-$)}
\hypertarget{u-}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"u-":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the additive inverse of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#18050:} For exactly one integer value, -2147483648, this function raises an ``int overflow'' runtime error. \vspace{0.1 cm} \\ {\bf \#18051:} For exactly one long value, -9223372036854775808, this function raises a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Modulo (\%)}
\hypertarget{\%}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"\%":$\!$ [k, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc k \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc n \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAp k} modulo {\PFAp n}; the result has the same sign as the modulus {\PFAp n}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This is the behavior of the {\PFAc \%} operator in Python, {\PFAc mod}/{\PFAc modulo} in Ada, Haskell, and Scheme.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#18060:} If {\PFAp n} is zero and {\PFAp k} and {\PFAp n} are int or long, this function raises a ``integer division by zero'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Remainder (\%\%)}
\hypertarget{\%\%}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"\%\%":$\!$ [k, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc k \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc n \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the remainder of {\PFAp k} divided by {\PFAp n}; the result has the same sign as the dividend {\PFAp k}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This is the behavior of the {\PFAc \%} operator in Fortran, C/C++, and Java, {\PFAc rem}/{\PFAc remainder} in Ada, Haskell, and Scheme.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#18070:} If {\PFAp n} is zero and {\PFAp k} and {\PFAp n} are int or long, this function raises a ``integer division by zero'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Raising to a power (**)}
\hypertarget{**}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"**":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Raise {\PFAp x} to the power {\PFAp n}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Float and double overflows do not produce runtime errors but result in positive or negative infinity, which would be carried through any subsequent calculations (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or NaN values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#18080:} Integer results above or below -2147483648 and 2147483647 (inclusive) produce an ``int overflow'' runtime error. \vspace{0.1 cm} \\ {\bf \#18081:} Long-integer results above or below -9223372036854775808 and 9223372036854775807 (inclusive) produce a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Comparison operators}

Avro defines a \href{http://avro.apache.org/docs/1.7.6/spec.html#order}{sort order} for every pair of values with a compatible type, so any two objects of compatible type can be compared in PFA.

\subsubsection{General comparison (cmp)}
\hypertarget{cmp}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"cmp":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc 1} if {\PFAp x} is greater than {\PFAp y}, {\PFAc -1} if {\PFAp x} is less than {\PFAp y}, and {\PFAc 0} if {\PFAp x} and {\PFAp y} are equal. \vspace{0.2 cm} \\ }

\subsubsection{Equality (==)}
\hypertarget{==}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"==":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is equal to {\PFAp y}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }

\subsubsection{Inequality (!=)}
\hypertarget{!=}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"!=":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is not equal to {\PFAp y}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }

\subsubsection{Less than (<)}
\hypertarget{<}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"<":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is less than {\PFAp y}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }

\subsubsection{Less than or equal to (<=)}
\hypertarget{<=}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"<=":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is less than or equal to {\PFAp y}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }

\subsubsection{Greater than (>)}
\hypertarget{>}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{">":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is greater than {\PFAp y}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }

\subsubsection{Greater than or equal to (>=)}
\hypertarget{>=}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{">=":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is greater than or equal to {\PFAp y}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }

\subsubsection{Maximum of two values (max)}
\hypertarget{max}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"max":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAp x} if {\PFAp x} $\geq$ {\PFAp y}, {\PFAp y} otherwise. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}For the maximum of more than two values, see {\PFAf \hyperlink{a.max}{a.max}}\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Minimum of two values (min)}
\hypertarget{min}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"min":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAp x} if {\PFAp x} < {\PFAp y}, {\PFAp y} otherwise. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}For the minimum of more than two values, see {\PFAf \hyperlink{a.min}{a.min}}\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Logical operators}

\subsubsection{Logical and (\&\&)}
\hypertarget{\&\&}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"\&\&":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & boolean \\  & \PFAc y \rm & boolean \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} and {\PFAp y} are both {\PFAc true}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp x} is {\PFAc false}, {\PFAp y} won't be evaluated.  (Only relevant for arguments with side effects.)\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Logical or (||)}
\hypertarget{||}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"||":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & boolean \\  & \PFAc y \rm & boolean \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if either {\PFAp x} or {\PFAp y} (or both) are {\PFAc true}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp x} is {\PFAc true}, {\PFAp y} won't be evaluated.  (Only relevant for arguments with side effects.)\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Logical xor (\^{}\^{})}
\hypertarget{\^{}\^{}}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"\^{}\^{}":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & boolean \\  & \PFAc y \rm & boolean \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is {\PFAc true} and {\PFAp y} is {\PFAc false} or if {\PFAp x} is {\PFAc false} and {\PFAp y} is {\PFAc true}, but return {\PFAc false} for any other case. \vspace{0.2 cm} \\ }

\subsubsection{Logical not (!)}
\hypertarget{!}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"!":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & boolean \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is {\PFAc false} and {\PFAc false} if {\PFAp x} is {\PFAc true}. \vspace{0.2 cm} \\ }

\subsection{Kleene operators (three-way logic)}

\subsubsection{Kleene and (\&\&\&)}
\hypertarget{\&\&\&}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"\&\&\&":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & union of \{boolean, null\} \\  & \PFAc y \rm & union of \{boolean, null\} \\  & {\it (returns)} & union of \{boolean, null\} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc false} if {\PFAp x} or {\PFAp y} is {\PFAc false}, {\PFAc true} if {\PFAp x} and {\PFAp y} are {\PFAc true}, and {\PFAc null} otherwise. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This corresponds to Kleene's three-state logic, in which {\PFAc null} represents a boolean quantity whose value is unknown. \vspace{0.1 cm} \\ If {\PFAp x} is {\PFAc false}, {\PFAp y} won't be evaluated.  (Only relevant for arguments with side effects.)\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Kleene or (|||)}
\hypertarget{|||}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"|||":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & union of \{boolean, null\} \\  & \PFAc y \rm & union of \{boolean, null\} \\  & {\it (returns)} & union of \{boolean, null\} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} or {\PFAp y} is {\PFAc true}, {\PFAc false} if both {\PFAp x} and {\PFAp y} is {\PFAc false}, or {\PFAc null} otherwise. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This corresponds to Kleene's three-state logic, in which {\PFAc null} represents a boolean quantity whose value is unknown. \vspace{0.1 cm} \\ If {\PFAp x} is {\PFAc true}, {\PFAp y} won't be evaluated.  (Only relevant for arguments with side effects.)\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Kleene not (!!!)}
\hypertarget{!!!}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"!!!":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & union of \{boolean, null\} \\  & {\it (returns)} & union of \{boolean, null\} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is {\PFAc false}, {\PFAc false} if {\PFAp x} is {\PFAc true}, or {\PFAc null} if {\PFAp x} is {\PFAc null}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This corresponds to Kleene's three-state logic, in which {\PFAc null} represents a boolean quantity whose value is unknown.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Bitwise arithmetic}

\subsubsection{Bitwise and (\&)}
\hypertarget{\&}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"\&":$\!$ [x, y]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc y \rm & int \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc y \rm & long \\ & {\it (returns)} & long \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Calculate the bitwise-and of {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ }

\subsubsection{Bitwise or (|)}
\hypertarget{|}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"|":$\!$ [x, y]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc y \rm & int \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc y \rm & long \\ & {\it (returns)} & long \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Calculate the bitwise-or of {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ }

\subsubsection{Bitwise xor (\^{})}
\hypertarget{\^{}}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"\^{}":$\!$ [x, y]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc y \rm & int \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc y \rm & long \\ & {\it (returns)} & long \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Calculate the bitwise-exclusive-or of {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ }

\subsubsection{Bitwise not (\textasciitilde{})}
\hypertarget{TILDE}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"\textasciitilde{}":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\ & {\it (returns)} & long \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Calculate the bitwise-not of {\PFAp x}. \vspace{0.2 cm} \\ }

\pagebreak

\section{Math library}

\subsection{Constants}

Constants such as $\pi$ and $e$ are represented as stateless functions with no arguments.  Specific implementations may choose to replace the function call with its inline value.

\subsubsection{Archimedes' constant $\pi$ (m.pi)}
\hypertarget{m.pi}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.pi":$\!$ []\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} The double-precision number that is closer than any other to $\pi$, the ratio of a circumference of a circle to its diameter. \vspace{0.2 cm} \\ }

\subsubsection{Euler's constant $e$ (m.e)}
\hypertarget{m.e}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.e":$\!$ []\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} The double-precision number that is closer than any other to $e$, the base of natural logarithms. \vspace{0.2 cm} \\ }

\subsection{Common functions}

\subsubsection{Square root (m.sqrt)}
\hypertarget{m.sqrt}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.sqrt":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the positive square root of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is from 0 (inclusive) to infinity.  Beyond this domain, the result is {\PFAc NaN}, not an exception (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or {\PFAc NaN} values."\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Hypotenuse (m.hypot)}
\hypertarget{m.hypot}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.hypot":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc y \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return $\sqrt{x^2 + y^2}$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Avoids round-off or overflow errors in the intermediate steps. \vspace{0.1 cm} \\ The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Trigonometric sine (m.sin)}
\hypertarget{m.sin}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.sin":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the trigonometric sine of {\PFAp x}, which is assumed to be in radians. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Trigonometric cosine (m.cos)}
\hypertarget{m.cos}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.cos":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the trigonometric cosine of {\PFAp x}, which is assumed to be in radians. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Trigonometric tangent (m.tan)}
\hypertarget{m.tan}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.tan":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the trigonometric tangent of {\PFAp x}, which is assumed to be in radians. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Inverse trigonometric sine (m.asin)}
\hypertarget{m.asin}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.asin":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the arc-sine (inverse of the sine function) of {\PFAp x} as an angle in radians between $-\pi/2$ and $\pi/2$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is from -1 to 1 (inclusive).  Beyond this domain, the result is {\PFAc NaN}, not an exception (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or {\PFAc NaN} values."\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Inverse trigonometric cosine (m.acos)}
\hypertarget{m.acos}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.acos":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the arc-cosine (inverse of the cosine function) of {\PFAp x} as an angle in radians between $0$ and $\pi$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is from -1 to 1 (inclusive).  Beyond this domain, the result is {\PFAc NaN}, not an exception (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or {\PFAc NaN} values."\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Inverse trigonometric tangent (m.atan)}
\hypertarget{m.atan}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.atan":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the arc-tangent (inverse of the tangent function) of {\PFAp x} as an angle in radians between $-\pi/2$ and $\pi/2$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Robust inverse trigonometric tangent (m.atan2)}
\hypertarget{m.atan2}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.atan2":$\!$ [y, x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc y \rm & double \\  & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the arc-tangent (inverse of the tangent function) of {\PFAp y}/{\PFAp x} without loss of precision for small {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real plane; no pair of inputs is invalid. \vspace{0.1 cm} \\ Note that {\PFAp y} is the first parameter and {\PFAp x} is the second parameter.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Hyperbolic sine (m.sinh)}
\hypertarget{m.sinh}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.sinh":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the hyperbolic sine of {\PFAp x}, which is equal to $\frac{e^x - e^{-x}}{2}$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Hyperbolic cosine (m.cosh)}
\hypertarget{m.cosh}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.cosh":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the hyperbolic cosine of {\PFAp x}, which is equal to $\frac{e^x + e^{-x}}{2}$ \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Hyperbolic tangent (m.tanh)}
\hypertarget{m.tanh}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.tanh":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the hyperbolic tangent of {\PFAp x}, which is equal to $\frac{e^x - e^{-x}}{e^x + e^{-x}}$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Natural exponential (m.exp)}
\hypertarget{m.exp}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.exp":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAf \hyperlink{m.e}{m.e}} raised to the power of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Natural exponential minus one (m.expm1)}
\hypertarget{m.expm1}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.expm1":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return $e^x - 1$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Avoids round-off or overflow errors in the intermediate steps. \vspace{0.1 cm} \\ The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Natural logarithm (m.ln)}
\hypertarget{m.ln}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.ln":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the natural logarithm of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is from 0 to infinity (exclusive).  Given zero, the result is negative infinity, and below zero, the result is {\PFAc NaN}, not an exception (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or {\PFAc NaN} values."\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Logarithm base 10 (m.log10)}
\hypertarget{m.log10}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.log10":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the logarithm base 10 of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is from 0 to infinity (exclusive).  Given zero, the result is negative infinity, and below zero, the result is {\PFAc NaN}, not an exception (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or {\PFAc NaN} values."\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Arbitrary logarithm (m.log)}
\hypertarget{m.log}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.log":$\!$ [x, base]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc base \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the logarithm of {\PFAp x} with a given {\PFAp base}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is from 0 to infinity (exclusive).  Given zero, the result is negative infinity, and below zero, the result is {\PFAc NaN}, not an exception (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or {\PFAc NaN} values."\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#27170:} If {\PFAp base} is less than or equal to zero, this function produces a ``base must be positive'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Natural logarithm of one plus square (m.ln1p)}
\hypertarget{m.ln1p}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.ln1p":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return $ln(x^2 + 1)$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Avoids round-off or overflow errors in the intermediate steps. \vspace{0.1 cm} \\ The domain of this function is from -1 to infinity (exclusive).  Given -1, the result is negative infinity, and below -1, the result is {\PFAc NaN}, not an exception (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or {\PFAc NaN} values."\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Rounding}

\subsubsection{Absolute value (m.abs)}
\hypertarget{m.abs}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.abs":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the absolute value of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#27020:} For exactly one integer value, -2147483648, this function produces an ``int overflow'' runtime error. \vspace{0.1 cm} \\ {\bf \#27021:} For exactly one long value, -9223372036854775808, this function produces a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Floor (m.floor)}
\hypertarget{m.floor}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.floor":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the largest (closest to positive infinity) whole number that is less than or equal to the input. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Ceiling (m.ceil)}
\hypertarget{m.ceil}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.ceil":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the smallest (closest to negative infinity, not closest to zero) whole number that is greater than or equal to the input. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Simple rounding (m.round)}
\hypertarget{m.round}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.round":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & long \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the closest whole number to {\PFAp x}, rounding up if the fractional part is exactly one-half. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Equal to {\PFAf \hyperlink{m.floor}{m.floor}} of ({\PFAp x} + 0.5).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#27190:} Integer results outside of -2147483648 and 2147483647 (inclusive) produce an ``int overflow'' runtime error. \vspace{0.1 cm} \\ {\bf \#27191:} Long-integer results outside of -9223372036854775808 and 9223372036854775807 (inclusive) produce a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Unbiased rounding (m.rint)}
\hypertarget{m.rint}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.rint":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the closest whole number to {\PFAp x}, rounding toward the nearest even number if the fractional part is exactly one-half. \vspace{0.2 cm} \\ }

\subsubsection{Threshold function (m.signum)}
\hypertarget{m.signum}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.signum":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return 0 if {\PFAp x} is zero, 1 if {\PFAp x} is positive, and -1 if {\PFAp x} is negative. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Copy sign (m.copysign)}
\hypertarget{m.copysign}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.copysign":$\!$ [mag, sign]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc mag \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc sign \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a number with the magnitude of {\PFAp mag} and the sign of {\PFAp sign}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real or integer plane; no pair of inputs is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Special functions}

\subsubsection{Error function (m.special.erf)}
\hypertarget{m.special.erf}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.special.erf":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the error function of {\PFAp x}. \vspace{0.2 cm} \\ }

\subsubsection{Complimentary error function (m.special.erfc)}
\hypertarget{m.special.erfc}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.special.erfc":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the complimentary error function of {\PFAp x}. \vspace{0.2 cm} \\ }

\subsubsection{Natural log of the gamma function (m.special.lnGamma)}
\hypertarget{m.special.lnGamma}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.special.lnGamma":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the natural log of the gamma function of {\PFAp x}. \vspace{0.2 cm} \\ }

\subsubsection{Natural log of the beta function (m.special.lnBeta)}
\hypertarget{m.special.lnBeta}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.special.lnBeta":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & double \\  & \PFAc b \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the beta function parameterized by {\PFAp a} and {\PFAp b}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & With $a$ and $b$, this function evaluates natural logarithm of the beta function. The beta function is $\int_{0}^{1} t^{a - 1}(1 - t)^{b - 1} dt $. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#36010:} Raises ``domain error'' if $a \leq 0$ or if $b \leq 0$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Binomial coefficient (m.special.nChooseK)}
\hypertarget{m.special.nChooseK}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.special.nChooseK":$\!$ [n, k]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc n \rm & int \\  & \PFAc k \rm & int \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:}  The number of ways to choose {\PFAp k} elements from a set of {\PFAp n} elements. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc n \rm & Total number of elements.  \\  & \PFAc k \rm & Numer of elements chosen.  \\  & {\it (return value)} \rm & With $n$ and $k$, this function evaluates the binomial coefficient. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#36000:} Raises ``domain error'' if $k \leq 0$ or $k \geq n$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Link or activation functions}

\subsubsection{Logit (m.link.logit)}
\hypertarget{m.link.logit}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.logit":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the logit function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $1 / (1 + \exp(-x_i))$. \\ \end{tabular} \vspace{0.2 cm} \\ }

\subsubsection{Probit (m.link.probit)}
\hypertarget{m.link.probit}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.probit":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the probit function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $(\mbox{erf}(x_i/\sqrt{2}) + 1)/2$. \\ \end{tabular} \vspace{0.2 cm} \\ }

\subsubsection{Log-log (m.link.loglog)}
\hypertarget{m.link.loglog}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.loglog":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the loglog function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $\exp(-\exp(x_i))$. \\ \end{tabular} \vspace{0.2 cm} \\ }

\subsubsection{Complement of log-log (m.link.cloglog)}
\hypertarget{m.link.cloglog}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.cloglog":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the cloglog function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $1 - \exp(-\exp(x_i))$. \\ \end{tabular} \vspace{0.2 cm} \\ }

\subsubsection{Cauchit (m.link.cauchit)}
\hypertarget{m.link.cauchit}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.cauchit":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the cauchit function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $0.5 + (1/\pi) \tan^{-1}(x_i)$. \\ \end{tabular} \vspace{0.2 cm} \\ }

\subsubsection{Hyperbolic tangent (m.link.tanh)}
\hypertarget{m.link.tanh}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.tanh":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the hyperbolic tangent function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $\tanh(x_i)$. \\ \end{tabular} \vspace{0.2 cm} \\ }

\subsubsection{Softmax (m.link.softmax)}
\hypertarget{m.link.softmax}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.softmax":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the softmax function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $\exp(x_i)/\sum_j \exp(x_j)$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#25000:} If {\PFAp x} is an empty array or an empty map, this function raises an ``empty input'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{SoftPlus (m.link.softplus)}
\hypertarget{m.link.softplus}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.softplus":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the softplus function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $\log(1.0 + \exp(x_i))$. \\ \end{tabular} \vspace{0.2 cm} \\ }

\subsubsection{Rectified linear unit (m.link.relu)}
\hypertarget{m.link.relu}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.relu":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the rectified linear unit (ReLu) function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $\log(1.0 + \exp(x_i))$. \\ \end{tabular} \vspace{0.2 cm} \\ }

\subsection{Kernel functions}

\subsubsection{Linear (m.kernel.linear)}
\hypertarget{m.kernel.linear}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.kernel.linear":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc y \rm & array of double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Linear kernel function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Length {\PFAp n} vector.  \\  & \PFAc y \rm & Length {\PFAp n} vector.  \\  & {\it (return value)} \rm & Returns the dot product of {\PFAp x} and {\PFAp y}, $\sum_{i=1}^{n} x_{i} y_{j}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#23000:} Raises a ``arrays must have same length'' error if the lengths of {\PFAp x} and {\PFAp y} are not the same.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Radial basis function (m.kernel.rbf)}
\hypertarget{m.kernel.rbf}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.kernel.rbf":$\!$ [x, y, gamma]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc y \rm & array of double \\  & \PFAc gamma \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Radial Basis Function (RBF) kernel function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Length {\PFAp n} vector.  \\  & \PFAc y \rm & Length {\PFAp n} vector.  \\  & \PFAc gamma \rm & Gamma coefficient.  \\  & {\it (return value)} \rm & Returns the result of $\mathrm{exp}(-\gamma || x - y ||^{2})$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#23010:} Raises a ``arrays must have same length'' error if the lengths of {\PFAp x} and {\PFAp y} are not the same.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Polynomal (m.kernel.poly)}
\hypertarget{m.kernel.poly}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.kernel.poly":$\!$ [x, y, gamma, intercept, degree]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc y \rm & array of double \\  & \PFAc gamma \rm & double \\  & \PFAc intercept \rm & double \\  & \PFAc degree \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Polynomial kernel function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Length {\PFAp n} vector.  \\  & \PFAc y \rm & Length {\PFAp n} vector.  \\  & \PFAc gamma \rm & Gamma coefficient.  \\  & \PFAc intecept \rm & Intercept constant.  \\  & \PFAc degree \rm & Degree of the polynomial kernel.  \\  & {\it (return value)} \rm & Returns the result of $(\gamma \sum_{i=1}^{n} x_{i} y_{j} + \mathrm{intercept})^{\mathrm{degree}}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#23020:} Raises a ``arrays must have same length'' error if the lengths of {\PFAp x} and {\PFAp y} are not the same.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Sigmoidal (m.kernel.linear)}
\hypertarget{m.kernel.sigmoid}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.kernel.sigmoid":$\!$ [x, y, gamma, intercept]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc y \rm & array of double \\  & \PFAc gamma \rm & double \\  & \PFAc intercept \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Sigmoid kernel function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Length {\PFAp n} vector.  \\  & \PFAc y \rm & Length {\PFAp n} vector.  \\  & \PFAc gamma \rm & Gamma coefficient.  \\  & \PFAc intecept \rm & Intercept constant.  \\  & {\it (return value)} \rm & Returns the result of $\mathrm{tanh}( \mathrm{gamma} \sum_{i=1}^{n} x_{i} y_{j} + \mathrm{intercept})$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#23030:} Raises a ``arrays must have same length'' error if the lengths of {\PFAp x} and {\PFAp y} are not the same.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\pagebreak

\section{Linear algebra library}

\subsection{Unary scaling of vectors or matrices (la.scale)}
\hypertarget{la.scale}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.scale":$\!$ [x, alpha]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc alpha \rm & double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc alpha \rm & double \\ & {\it (returns)} & array of array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\  & \PFAc alpha \rm & double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc alpha \rm & double \\ & {\it (returns)} & map of map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Scale vector or matrix {\PFAp x} by factor {\PFAp alpha}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which elements are computed is not specified, and may be in parallel.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Generalized unary operator (la.map)}
\hypertarget{la.map}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.map":$\!$ [x, fcn]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc fcn \rm & function (double) $\to$ double \\ & {\it (returns)} & array of array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc fcn \rm & function (double) $\to$ double \\ & {\it (returns)} & map of map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element from {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This can be used to perform scalar multiplication on a matrix: supply a function that multiplies each element by a constant. \vspace{0.1 cm} \\ The order in which elements are computed is not specified, and may be in parallel.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Addition of vectors or matrices (la.add)}
\hypertarget{la.add}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.add":$\!$ [x, y]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc y \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc y \rm & array of array of double \\ & {\it (returns)} & array of array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\  & \PFAc y \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc y \rm & map of map of double \\ & {\it (returns)} & map of map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Add two vectors or matrices {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which elements are computed is not specified, and may be in parallel. \vspace{0.1 cm} \\ Like most functions that deal with matrices, this function has an array signature and a map signature.  In the array signature, the number of rows and/or columns in {\PFAp x} must be equal to the number of rows and/or columns of {\PFAp y}, respectively (dense matrix).  In the map signature, missing row-column combinations are assumed to be zero (sparse matrix).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#24030:} In the array signature, if any element in {\PFAp x} does not have a corresponding element in {\PFAp y} (or vice-versa), this function raises a ``misaligned matrices'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Subtraction of vectors or matrices (la.sub)}
\hypertarget{la.sub}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.sub":$\!$ [x, y]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc y \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc y \rm & array of array of double \\ & {\it (returns)} & array of array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\  & \PFAc y \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc y \rm & map of map of double \\ & {\it (returns)} & map of map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Subtract vector or matrix {\PFAp y} from {\PFAp x} (returns $x - y$). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which elements are computed is not specified, and may be in parallel. \vspace{0.1 cm} \\ Like most functions that deal with matrices, this function has an array signature and a map signature.  In the array signature, the number of rows and/or columns in {\PFAp x} must be equal to the number of rows and/or columns of {\PFAp y}, respectively (dense matrix).  In the map signature, missing row-column combinations are assumed to be zero (sparse matrix).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#24040:} In the array signature, if any element in {\PFAp x} does not have a corresponding element in {\PFAp y} (or vice-versa), this function raises a ``misaligned matrices'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Generalized binary operator (la.zipmap)}
\hypertarget{la.zipmap}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.zipmap":$\!$ [x, y, fcn]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc y \rm & array of array of double \\  & \PFAc fcn \rm & function (double, double) $\to$ double \\ & {\it (returns)} & array of array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc y \rm & map of map of double \\  & \PFAc fcn \rm & function (double, double) $\to$ double \\ & {\it (returns)} & map of map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each pair of elements from {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This can be used to perform matrix addition: supply a function that adds each pair of elements. \vspace{0.1 cm} \\ Like most functions that deal with matrices, this function has an array signature and a map signature.  In the array signature, the number of rows and columns in {\PFAp x} must be equal to the number of rows and columns of {\PFAp y}, respectively (dense matrix).  In the map signature, missing row-column combinations are assumed to be zero (sparse matrix). \vspace{0.1 cm} \\ The order in which elements are computed is not specified, and may be in parallel.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#24020:} In the array signature, if any element in {\PFAp x} does not have a corresponding element in {\PFAp y} (or vice-versa), this function raises a ``misaligned matrices'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Vector and matrix dot product (la.dot)}
\hypertarget{la.dot}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.dot":$\!$ [x, y]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc y \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc y \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc y \rm & array of array of double \\ & {\it (returns)} & array of array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc y \rm & map of map of double \\ & {\it (returns)} & map of map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Multiply two matrices or a matrix and a vector, which may be represented as dense arrays or potentially sparse maps. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Like most functions that deal with matrices, this function has an array signature and a map signature.  In the array signature, the number of columns of {\PFAp x} must be equal to the number of rows (or the number of elements) of {\PFAp y} (dense matrix).  In the map signature, missing values are assumed to be zero (sparse matrix). \vspace{0.1 cm} \\ Matrices supplied as maps may be computed using sparse methods.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#24050:} In the array signature, if the dimensions of {\PFAp x} do not correspond to the dimension(s) of {\PFAp y}, this function raises a ``misaligned matrices'' error. \vspace{0.1 cm} \\ {\bf \#24051:} If {\PFAp x} or {\PFAp y} has fewer than 1 row or fewer than 1 column, this function raises a ``too few rows/cols'' error. \vspace{0.1 cm} \\ {\bf \#24052:} If {\PFAp x} or {\PFAp y} contains any non-finite values, this function raises a ``contains non-finite value'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Transpose (la.transpose)}
\hypertarget{la.transpose}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.transpose":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\ & {\it (returns)} & array of array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\ & {\it (returns)} & map of map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Transpose a rectangular matrix. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#24060:} If the matrix has fewer than 1 row or fewer than 1 column, this function raises a ``too few rows/cols'' error. \vspace{0.1 cm} \\ {\bf \#24061:} If the columns are ragged (arrays of different lengths or maps with different sets of keys), this function raises a ``ragged columns'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Inverse and pseudo-inverse (la.inverse)}
\hypertarget{la.inverse}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.inverse":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\ & {\it (returns)} & array of array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\ & {\it (returns)} & map of map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the inverse (or Moore-Penrose pseudoinverse, if not square) of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#24070:} If the matrix has fewer than 1 row or fewer than 1 column, this function raises a ``too few rows/cols'' error. \vspace{0.1 cm} \\ {\bf \#24071:} If {\PFAp x} is an array with ragged columns (arrays of different lengths), this function raises a ``ragged columns'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Trace (la.trace)}
\hypertarget{la.trace}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.trace":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the trace of a matrix (sum of diagonal elements). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#24080:} If {\PFAp x} is an array with ragged columns (arrays of different lengths), this function raises a ``ragged columns'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Determinant (la.det)}
\hypertarget{la.det}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.det":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the determinant of a matrix. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#24090:} If the matrix has fewer than 1 row or fewer than 1 column, this function raises a ``too few rows/cols'' error. \vspace{0.1 cm} \\ {\bf \#24091:} If {\PFAp x} is an array with ragged columns (arrays of different lengths), this function raises a ``ragged columns'' error. \vspace{0.1 cm} \\ {\bf \#24092:} In the array signature, if {\PFAp x} is not a square matrix, this function raises a ``non-square matrix'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Check for symmetry (la.symmetric)}
\hypertarget{la.symmetric}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.symmetric":$\!$ [x, tolerance]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc tolerance \rm & double \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc tolerance \rm & double \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Determine if a matrix is symmetric withing tolerance. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Returns {\PFAc true} if the absolute value of element $i$, $j$ minus element $j$, $i$ is less than {\PFAp tolerance}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#24100:} If the matrix has fewer than 1 row or fewer than 1 column, this function raises a ``too few rows/cols'' error. \vspace{0.1 cm} \\ {\bf \#24101:} If {\PFAp x} is an array with ragged columns (arrays of different lengths), this function raises a ``ragged columns'' error. \vspace{0.1 cm} \\ {\bf \#24102:} If {\PFAp x} is not a square matrix, this function raises a ``non-square matrix'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Real eigenbasis of symmetric matrix (la.eigenBasis)}
\hypertarget{la.eigenBasis}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.eigenBasis":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\ & {\it (returns)} & array of array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\ & {\it (returns)} & map of map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the eigenvalues and eigenvectors of a real, symmetric matrix {\PFAp x} (which are all real). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & A matrix in which each row (first level of array or map hierarchy) is a normalized eigenvector of {\PFAp x} divided by the square root of the corresponding eigenvalue (The sign is chosen such that the first component is positive.).  If provided as an array, the rows are in decreasing order of eigenvalue (increasing order of inverse square root eigenvalue).  If provided as a map, the rows are keyed by string representations of integers starting with {\PFAc ``0''}, and increasing row keys are in decreasing order of eigenvalue. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp x} is the covariance matrix of a zero-mean dataset, the matrix that this function returns would transform the dataset to one with unit variances and zero covariances. \vspace{0.1 cm} \\ If {\PFAp x} is not symmetric or not exactly symmetric, it will first be symmetrized ($(x + x^T)/2$).  For example, a matrix represented by only the upper triangle (other elements are zero or missing from the map) becomes a symmetric matrix with the upper triangle unchanged. \vspace{0.1 cm} \\ {\bf Nondeterministic: unstable.} This function gives the same results every time it is executed, but those results may not be exactly the same on all systems.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#24110:} If the matrix has fewer than 1 row or fewer than 1 column, this function raises a ``too few rows/cols'' error. \vspace{0.1 cm} \\ {\bf \#24111:} If {\PFAp x} is an array with ragged columns (arrays of different lengths), this function raises a ``ragged columns'' error. \vspace{0.1 cm} \\ {\bf \#24112:} If {\PFAp x} is not a square matrix, this function raises a ``non-square matrix'' error. \vspace{0.1 cm} \\ {\bf \#24113:} If {\PFAp x} contains non-finite values, this function raises a ``non-finite matrix'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Truncate rows (la.truncate)}
\hypertarget{la.truncate}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.truncate":$\!$ [x, keep]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc keep \rm & int \\ & {\it (returns)} & array of array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc keep \rm & array of string \\ & {\it (returns)} & map of map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Remove rows from a matrix so that it becomes a projection operator. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & The matrix to truncate.  \\  & \PFAc keep \rm & If {\PFAp x} is an array, this is the number of rows to keep, starting with the first row.  If {\PFAp x} is a map, this is the set of keys to keep.  If {\PFAp keep} is larger than the number of rows or is not a subset of the keys, the excess is ignored.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}In Principle Component Analysis (PCA), this would be applied to the eigenbasis transformation ({\PFAf \hyperlink{la.eigenBasis}{la.eigenBasis}}) to keep only a specified number (or set) of transformed components.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#24120:} If the matrix has fewer than 1 row or fewer than 1 column, this function raises a ``too few rows/cols'' error. \vspace{0.1 cm} \\ {\bf \#24121:} If {\PFAp x} is an array with ragged columns (arrays of different lengths), this function raises a ``ragged columns'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\pagebreak

\section{Metric library}

\subsection{Euclidean metric without similarity or missing values (metric.simpleEuclidean)}
\hypertarget{metric.simpleEuclidean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"metric.simpleEuclidean":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc y \rm & array of double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Euclidean metric without a special similarity function and without any handling of missing values. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & First sample vector.  \\  & \PFAc y \rm & Second sample vector.  (Must have the same dimension as {\PFAp x}.)  \\  & {\it (return value)} \rm & Returns $\sqrt{\sum_i (x_i - y_i)^2}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#28000:} Raises ``dimensions of vectors do not match'' if all vectors do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Absolute difference similarity function (metric.absDiff)}
\hypertarget{metric.absDiff}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"metric.absDiff":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc y \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Similarity function (1-dimensional metric) that returns the absolute Euclidean distance between {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ }

\subsection{Gaussian similarity function (metric.gaussianSimilarity)}
\hypertarget{metric.gaussianSimilarity}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"metric.gaussianSimilarity":$\!$ [x, y, sigma]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc y \rm & double \\  & \PFAc sigma \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Similarity function (1-dimensional metric) that returns $\exp(-\ln(2) (x - y)^2 / \mbox{sigma}^2)$. \vspace{0.2 cm} \\ }

\subsection{Euclidean metric (metric.euclidean)}
\hypertarget{metric.euclidean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"metric.euclidean":$\!$ [similarity, x, y]\} \rm or \PFAc \{"metric.euclidean":$\!$ [similarity, x, y, missingWeight]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (any {\PFAtp A}, any {\PFAtp B}) $\to$ double \\  & \PFAc x \rm & array of union of \{null, {\PFAtp A}\} \\  & \PFAc y \rm & array of union of \{null, {\PFAtp B}\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (any {\PFAtp A}, any {\PFAtp B}) $\to$ double \\  & \PFAc x \rm & array of union of \{null, {\PFAtp A}\} \\  & \PFAc y \rm & array of union of \{null, {\PFAtp B}\} \\  & \PFAc missingWeight \rm & array of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Euclidean metric, which is the distance function for ordinary space, given by the Pythagorean formula (also known as the 2-norm). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc similarity \rm & Similarity function (1-dimensional metric) that quantifies the distance between components of {\PFAp x} and components of {\PFAp y}.  \\  & \PFAc x \rm & First sample vector, which may have missing values.  \\  & \PFAc y \rm & Second sample vector, which may have missing values.  (Must have the same dimension as {\PFAp x}.)  \\  & \PFAc missingWeight \rm & Optional missing-value weights: a vector with the same dimension as {\PFAp x} and {\PFAp y} that determines the normalized contribution of missing values in the sum.  If not provided, missing-value weights of 1.0 are assumed.  \\  & {\it (return value)} \rm & With $I(x_i,y_i)$ = 0 if component $i$ of {\PFAp x} or {\PFAp y} is missing, 1 otherwise, this function returns $\sqrt{(\sum_i I(x_i,y_i) \mbox{similarity}(x_i,y_i)^2)(\sum_i q_i)/(\sum_i I(x_i,y_i) q_i)}$ where $q_i$ are components of the missing-value weights.  Without missing values, it is $\sqrt{\sum_i \mbox{similarity}(x_i,y_i)^2}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If all values are missing, the function returns {\PFAc NaN}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#28030:} Raises ``dimensions of vectors do not match'' if all vectors do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Squared euclidean metric (metric.squaredEuclidean)}
\hypertarget{metric.squaredEuclidean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"metric.squaredEuclidean":$\!$ [similarity, x, y]\} \rm or \PFAc \{"metric.squaredEuclidean":$\!$ [similarity, x, y, missingWeight]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (double, double) $\to$ double \\  & \PFAc x \rm & array of union of \{null, double\} \\  & \PFAc y \rm & array of union of \{null, double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (double, double) $\to$ double \\  & \PFAc x \rm & array of union of \{null, double\} \\  & \PFAc y \rm & array of union of \{null, double\} \\  & \PFAc missingWeight \rm & array of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Euclidean metric squared, which has the same ordering as the Euclidean metric, but avoids a square root calculation. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc similarity \rm & Similarity function (1-dimensional metric) that quantifies the distance between components of {\PFAp x} and components of {\PFAp y}.  \\  & \PFAc x \rm & First sample vector, which may have missing values.  \\  & \PFAc y \rm & Second sample vector, which may have missing values.  (Must have the same dimension as {\PFAp x}.)  \\  & \PFAc missingWeight \rm & Optional missing-value weights: a vector with the same dimension as {\PFAp x} and {\PFAp y} that determines the normalized contribution of missing values in the sum.  If not provided, missing-value weights of 1.0 are assumed.  \\  & {\it (return value)} \rm & With $I(x_i,y_i)$ = 0 if component $i$ of {\PFAp x} or {\PFAp y} is missing, 1 otherwise, this function returns $(\sum_i I(x_i,y_i) \mbox{similarity}(x_i,y_i)^2)(\sum_i q_i)/(\sum_i I(x_i,y_i) q_i)$ where $q_i$ are components of the missing-value weights.  Without missing values, it is $\sum_i \mbox{similarity}(x_i,y_i)^2$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If all values are missing, the function returns {\PFAc NaN}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#28040:} Raises ``dimensions of vectors do not match'' if all vectors do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Chebyshev metric (metric.chebyshev)}
\hypertarget{metric.chebyshev}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"metric.chebyshev":$\!$ [similarity, x, y]\} \rm or \PFAc \{"metric.chebyshev":$\!$ [similarity, x, y, missingWeight]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (double, double) $\to$ double \\  & \PFAc x \rm & array of union of \{null, double\} \\  & \PFAc y \rm & array of union of \{null, double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (double, double) $\to$ double \\  & \PFAc x \rm & array of union of \{null, double\} \\  & \PFAc y \rm & array of union of \{null, double\} \\  & \PFAc missingWeight \rm & array of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Chebyshev metric, also known as the infinity norm or chessboard distance (since it is the number of moves required for a chess king to travel between two points). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc similarity \rm & Similarity function (1-dimensional metric) that quantifies the distance between components of {\PFAp x} and components of {\PFAp y}.  \\  & \PFAc x \rm & First sample vector, which may have missing values.  \\  & \PFAc y \rm & Second sample vector, which may have missing values.  (Must have the same dimension as {\PFAp x}.)  \\  & \PFAc missingWeight \rm & Optional missing-value weights: a vector with the same dimension as {\PFAp x} and {\PFAp y} that determines the normalized contribution of missing values in the sum.  If not provided, missing-value weights of 1.0 are assumed.  \\  & {\it (return value)} \rm & With $I(x_i,y_i)$ = 0 if component $i$ of {\PFAp x} or {\PFAp y} is missing, 1 otherwise, this function returns $(\max_i I(x_i,y_i) \mbox{similarity}(x_i,y_i))(\sum_i q_i)/(\sum_i I(x_i,y_i) q_i)$ where $q_i$ are components of the missing-value weights.  Without missing values, it is $\max_i \mbox{similarity}(x_i,y_i)$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If all values are missing, the function returns {\PFAc NaN}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#28050:} Raises ``dimensions of vectors do not match'' if all vectors do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Taxicab metric (metric.taxicab)}
\hypertarget{metric.taxicab}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"metric.taxicab":$\!$ [similarity, x, y]\} \rm or \PFAc \{"metric.taxicab":$\!$ [similarity, x, y, missingWeight]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (double, double) $\to$ double \\  & \PFAc x \rm & array of union of \{null, double\} \\  & \PFAc y \rm & array of union of \{null, double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (double, double) $\to$ double \\  & \PFAc x \rm & array of union of \{null, double\} \\  & \PFAc y \rm & array of union of \{null, double\} \\  & \PFAc missingWeight \rm & array of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Taxicab metric, also known as the 1-norm, city-block or Manhattan distance (since it is the distance when confined to a rectilinear city grid). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc similarity \rm & Similarity function (1-dimensional metric) that quantifies the distance between components of {\PFAp x} and components of {\PFAp y}.  \\  & \PFAc x \rm & First sample vector, which may have missing values.  \\  & \PFAc y \rm & Second sample vector, which may have missing values.  (Must have the same dimension as {\PFAp x}.)  \\  & \PFAc missingWeight \rm & Optional missing-value weights: a vector with the same dimension as {\PFAp x} and {\PFAp y} that determines the normalized contribution of missing values in the sum.  If not provided, missing-value weights of 1.0 are assumed.  \\  & {\it (return value)} \rm & With $I(x_i,y_i)$ = 0 if component $i$ of {\PFAp x} or {\PFAp y} is missing, 1 otherwise, this function returns $(\sum_i I(x_i,y_i) \mbox{similarity}(x_i,y_i))(\sum_i q_i)/(\sum_i I(x_i,y_i) q_i)$ where $q_i$ are components of the missing-value weights.  Without missing values, it is $\sum_i \mbox{similarity}(x_i,y_i)$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If all values are missing, the function returns {\PFAc NaN}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#28060:} Raises ``dimensions of vectors do not match'' if all vectors do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Minkowski metric (metric.minkowski)}
\hypertarget{metric.minkowski}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"metric.minkowski":$\!$ [similarity, x, y, p]\} \rm or \PFAc \{"metric.minkowski":$\!$ [similarity, x, y, p, missingWeight]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (double, double) $\to$ double \\  & \PFAc x \rm & array of union of \{null, double\} \\  & \PFAc y \rm & array of union of \{null, double\} \\  & \PFAc p \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (double, double) $\to$ double \\  & \PFAc x \rm & array of union of \{null, double\} \\  & \PFAc y \rm & array of union of \{null, double\} \\  & \PFAc p \rm & double \\  & \PFAc missingWeight \rm & array of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Minkowski metric, also known as the p-norm, a generalized norm whose limits include Euclidean, Chebyshev, and Taxicab. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc similarity \rm & Similarity function (1-dimensional metric) that quantifies the distance between components of {\PFAp x} and components of {\PFAp y}.  \\  & \PFAc x \rm & First sample vector, which may have missing values.  \\  & \PFAc y \rm & Second sample vector, which may have missing values.  (Must have the same dimension as {\PFAp x}.)  \\  & \PFAc missingWeight \rm & Optional missing-value weights: a vector with the same dimension as {\PFAp x} and {\PFAp y} that determines the normalized contribution of missing values in the sum.  If not provided, missing-value weights of 1.0 are assumed.  \\  & {\it (return value)} \rm & With $I(x_i,y_i)$ = 0 if component $i$ of {\PFAp x} or {\PFAp y} is missing, 1 otherwise, this function returns $((\sum_i I(x_i,y_i) \mbox{similarity}(x_i,y_i)^p)(\sum_i q_i)/(\sum_i I(x_i,y_i) q_i))^{1/p}$ where $q_i$ are components of the missing-value weights.  Without missing values, it is $(\sum_i \mbox{similarity}(x_i,y_i)^p)^{1/p}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If all values are missing, the function returns {\PFAc NaN}. \vspace{0.1 cm} \\ If {\PFAp p} is positive infinity, this function is equivalent to {\PFAf \hyperlink{metric.chebyshev}{metric.chebyshev}}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#28070:} Raises ``dimensions of vectors do not match'' if all vectors do not have the same dimension. \vspace{0.1 cm} \\ {\bf \#28071:} Raises ``Minkowski parameter p must be positive'' if {\PFAp p} is less than or equal to zero.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Simple binary metric (metric.simpleMatching)}
\hypertarget{metric.simpleMatching}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"metric.simpleMatching":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of boolean \\  & \PFAc y \rm & array of boolean \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Simple metric on binary vectors. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & First sample vector.  \\  & \PFAc y \rm & Second sample vector.  (Must have the same dimension as {\PFAp x}.)  \\  & {\it (return value)} \rm & Where $a_{11}$ is the number of {\PFAp x}, {\PFAp y} coordinate pairs that are equal to {\PFAc true, true}, $a_{10}$ is the number of {\PFAc true, false}, $a_{01}$ is the number of {\PFAc false, true}, and $a_{00}$ is the number of {\PFAc false, false}, this function returns $(a_{11} + a_{00})/(a_{11} + a_{10} + a_{01} + a_{00})$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#28080:} Raises ``dimensions of vectors do not match'' if {\PFAp x} and {\PFAp y} do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Jaccard binary similarity (metric.jaccard)}
\hypertarget{metric.jaccard}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"metric.jaccard":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of boolean \\  & \PFAc y \rm & array of boolean \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Jaccard similarity of binary vectors. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & First sample vector.  \\  & \PFAc y \rm & Second sample vector.  (Must have the same dimension as {\PFAp x}.)  \\  & {\it (return value)} \rm & Where $a_{11}$ is the number of {\PFAp x}, {\PFAp y} coordinate pairs that are equal to {\PFAc true, true}, $a_{10}$ is the number of {\PFAc true, false}, $a_{01}$ is the number of {\PFAc false, true}, and $a_{00}$ is the number of {\PFAc false, false}, this function returns $a_{11}/(a_{11} + a_{10} + a_{01})$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#28090:} Raises ``dimensions of vectors do not match'' if {\PFAp x} and {\PFAp y} do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Tanimoto binary similarity (metric.tanimoto)}
\hypertarget{metric.tanimoto}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"metric.tanimoto":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of boolean \\  & \PFAc y \rm & array of boolean \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Tanimoto similarity of binary vectors. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & First sample vector.  \\  & \PFAc y \rm & Second sample vector.  (Must have the same dimension as {\PFAp x}.)  \\  & {\it (return value)} \rm & Where $a_{11}$ is the number of {\PFAp x}, {\PFAp y} coordinate pairs that are equal to {\PFAc true, true}, $a_{10}$ is the number of {\PFAc true, false}, $a_{01}$ is the number of {\PFAc false, true}, and $a_{00}$ is the number of {\PFAc false, false}, this function returns $(a_{11} + a_{00})/(a_{11} + 2*(a_{10} + a_{01}) + a_{00})$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#28100:} Raises ``dimensions of vectors do not match'' if {\PFAp x} and {\PFAp y} do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{General binary metric (metric.binarySimilarity)}
\hypertarget{metric.binarySimilarity}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"metric.binarySimilarity":$\!$ [x, y, c00, c01, c10, c11, d00, d01, d10, d11]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of boolean \\  & \PFAc y \rm & array of boolean \\  & \PFAc c00 \rm & double \\  & \PFAc c01 \rm & double \\  & \PFAc c10 \rm & double \\  & \PFAc c11 \rm & double \\  & \PFAc d00 \rm & double \\  & \PFAc d01 \rm & double \\  & \PFAc d10 \rm & double \\  & \PFAc d11 \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Genaralized similarity of binary vectors, using {\PFAp c00}, {\PFAp c01}, {\PFAp c10}, {\PFAp c11}, {\PFAp d00}, {\PFAp d01}, {\PFAp d10}, and {\PFAp d11} as parameters to reproduce all other binary similarity metrics. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & First sample vector.  \\  & \PFAc y \rm & Second sample vector.  (Must have the same dimension as {\PFAp x}.)  \\  & {\it (return value)} \rm & Where $a_{11}$ is the number of {\PFAp x}, {\PFAp y} coordinate pairs that are equal to {\PFAc true, true}, $a_{10}$ is the number of {\PFAc true, false}, $a_{01}$ is the number of {\PFAc false, true}, and $a_{00}$ is the number of {\PFAc false, false}, this function returns $(c_{11}a_{11} + c_{10}a_{10} + c_{01}a_{01} + c_{00}a_{00})/(d_{11}a_{11} + d_{10}a_{10} + d_{01}a_{01} + d_{00}a_{00})$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#28110:} Raises ``dimensions of vectors do not match'' if {\PFAp x} and {\PFAp y} do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\pagebreak

\section{Random number library}

All pseudorandom functions are seeded by the top-level field {\PFAc randseed}.  If absent, the return values of these functions are unpredictable.  If present, they are reproducible for scoring engines generated from the same PFA file on the same PFA implementation.  Different PFA implementations may use different random number generators, so reproducibility among implementations is not guaranteed.

\subsection{Uniform random deviates of basic types}

\subsubsection{Random integer (rand.int)}
\hypertarget{rand.int}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"rand.int":$\!$ []\} \rm or \PFAc \{"rand.int":$\!$ [low, high]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc low \rm & int \\  & \PFAc high \rm & int \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random integer, either on the entire entire 32-bit range or between {\PFAp low} (inclusive) and {\PFAp high} (exclusive). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#34000:} Raises a ``high must be greater than low'' error if {\PFAp high} is less than or equal to {\PFAp low}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Random integer (rand.long)}
\hypertarget{rand.long}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"rand.long":$\!$ []\} \rm or \PFAc \{"rand.long":$\!$ [low, high]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & {\it (returns)} & long \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc low \rm & long \\  & \PFAc high \rm & long \\ & {\it (returns)} & long \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random long integer, either on the entire 64-bit range or between {\PFAp low} (inclusive) and {\PFAp high} (exclusive). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#34010:} Raises a ``high must be greater than low'' error if {\PFAp high} is less than or equal to {\PFAp low}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Random integer (rand.float)}
\hypertarget{rand.float}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"rand.float":$\!$ [low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc low \rm & float \\  & \PFAc high \rm & float \\  & {\it (returns)} & float \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random float between {\PFAp low} and {\PFAp high}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#34020:} Raises a ``high must be greater than low'' error if {\PFAp high} is less than or equal to {\PFAp low}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Random integer (rand.double)}
\hypertarget{rand.double}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"rand.double":$\!$ [low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc low \rm & double \\  & \PFAc high \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random double between {\PFAp low} and {\PFAp high}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#34030:} Raises a ``high must be greater than low'' error if {\PFAp high} is less than or equal to {\PFAp low}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Random string (rand.string)}
\hypertarget{rand.string}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"rand.string":$\!$ [size]\} \rm or \PFAc \{"rand.string":$\!$ [size, population]\} \rm or \PFAc \{"rand.string":$\!$ [size, low, high]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc size \rm & int \\ & {\it (returns)} & string \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc size \rm & int \\  & \PFAc population \rm & string \\ & {\it (returns)} & string \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc size \rm & int \\  & \PFAc low \rm & int \\  & \PFAc high \rm & int \\ & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random string with {\PFAp size} characters from a range, if provided. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc size \rm & Number of characters in the resulting string.  \\  & \PFAc population \rm & Bag of characters to choose from.  Characters repeated $N$ times in the {\PFAp population} have probability $N$/{\PFAp size}, but order is irrelevant.  \\  & \PFAc low \rm & Minimum code-point to sample (inclusive).  \\  & \PFAc high \rm & Maximum code-point to sample (exclusive).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Without a range, this function samples the entire Unicode table up to and including {\PFAc 0xD800}; ASCII characters are rare. \vspace{0.1 cm} \\ The ASCII printable range is {\PFAp low} = 33, {\PFAp high} = 127. \vspace{0.1 cm} \\ {\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#34080:} Raises a ``size must be positive'' error if {\PFAp size} is less than or equal to zero. \vspace{0.1 cm} \\ {\bf \#34081:} Raises a ``high must be greater than low'' error if {\PFAp high} is less than or equal to {\PFAp low}. \vspace{0.1 cm} \\ {\bf \#34082:} Raises an ``invalid char'' error if {\PFAp low} is less than 1 or greater than {\PFAc 0xD800} or if {\PFAp high} is less than 1 or greater than {\PFAc 0xD800}. \vspace{0.1 cm} \\ {\bf \#34083:} Raises an ``population must be non-empty'' error if {\PFAp population} is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Random bytes (rand.bytes)}
\hypertarget{rand.bytes}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"rand.bytes":$\!$ [size]\} \rm or \PFAc \{"rand.bytes":$\!$ [size, population]\} \rm or \PFAc \{"rand.bytes":$\!$ [size, low, high]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc size \rm & int \\ & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc size \rm & int \\  & \PFAc population \rm & bytes \\ & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc size \rm & int \\  & \PFAc low \rm & int \\  & \PFAc high \rm & int \\ & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAp size} random bytes from a range, if provided. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc size \rm & Number of bytes in the result.  \\  & \PFAc population \rm & Bag of bytes to choose from.  Bytes repeated $N$ times in the {\PFAp population} have probability $N$/{\PFAp size}, but order is irrelevant.  \\  & \PFAc low \rm & Minimum byte value to sample (inclusive).  \\  & \PFAc high \rm & Maximum byte value to sample (exclusive).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#34090:} Raises a ``size must be positive'' error if {\PFAp size} is less than or equal to zero. \vspace{0.1 cm} \\ {\bf \#34091:} Raises a ``high must be greater than low'' error if {\PFAp high} is less than or equal to {\PFAp low}. \vspace{0.1 cm} \\ {\bf \#34092:} Raises an ``invalid byte'' error if {\PFAp low} is less than 0 or greater than 255 or if {\PFAp high} is less than 0 or greater than 256. \vspace{0.1 cm} \\ {\bf \#34093:} Raises an ``population must be non-empty'' error if {\PFAp population} is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Common statistical distributions}

\subsubsection{Gaussian deviates (rand.gaussian)}
\hypertarget{rand.gaussian}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"rand.gaussian":$\!$ [mu, sigma]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc mu \rm & double \\  & \PFAc sigma \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random number from a Gaussian (normal) distribution with mean {\PFAp mu} and standard deviation {\PFAp sigma}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Common utility types}

\subsubsection{Type-4 UUID (rand.uuid4)}
\hypertarget{rand.uuid}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"rand.uuid":$\!$ []\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & {\it (returns)} & string \\ \\ \vspace{-0.8 cm} \fbox{\bf Deprecated; exists until PFA 0.9.0: use rand.uuid4 instead.} \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random (type 4) UUID with IETF variant (8). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & The return value is a string with the form {\PFAc xxxxxxxx-xxxx-4xxx-8xxx-xxxxxxxxxxxx} where {\PFAc x} are random, lowercase hexidecimal digits (0-9a-f), 4 is the version, and 8 is the IETF variant. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\hypertarget{rand.uuid4}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"rand.uuid4":$\!$ []\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random (type 4) UUID with IETF variant (8). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & The return value is a string with the form {\PFAc xxxxxxxx-xxxx-4xxx-8xxx-xxxxxxxxxxxx} where {\PFAc x} are random, lowercase hexidecimal digits (0-9a-f), 4 is the version, and 8 is the IETF variant. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Selecting arbitrary objects from a bag}

\subsubsection{Random object from a bag (rand.choice)}
\hypertarget{rand.choice}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"rand.choice":$\!$ [population]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc population \rm & array of any {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random item from a bag of items. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#34040:} Raises a ``population must not be empty'' error if {\PFAp population} is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Random set of objects with replacement (rand.choices)}
\hypertarget{rand.choices}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"rand.choices":$\!$ [size, population]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc size \rm & int \\  & \PFAc population \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array of random items (with replacement) from a bag of items. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#34050:} Raises a ``population must not be empty'' error if {\PFAp population} is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Random set of objects without replacement (rand.sample)}
\hypertarget{rand.sample}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"rand.sample":$\!$ [size, population]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc size \rm & int \\  & \PFAc population \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array of random items (without replacement) from a bag of items. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#34060:} Raises a ``population must not be empty'' error if {\PFAp population} is empty. \vspace{0.1 cm} \\ {\bf \#34061:} Raises a ``population smaller than requested subsample'' error if the size of {\PFAp population} is less than {\PFAp size}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Random objects with a specified probability distribution (rand.histogram)}
\hypertarget{rand.histogram}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"rand.histogram":$\!$ [distribution]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc distribution \rm & array of double \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc distribution \rm & array of any record {\PFAtp A} with \{{\PFApf prob:}$\!$ double\} \\ & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random index of {\PFAp distribution} with probability proportional to the value of that index or a random item from {\PFAp distribution} with probability proportional to the {\PFApf prob} field. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the probabilities do not sum to 1.0, they will be normalized first. \vspace{0.1 cm} \\ {\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#34070:} Raises a ``distribution must be non-empty'' error if no items of {\PFAp distribution} are non-zero. \vspace{0.1 cm} \\ {\bf \#34071:} Raises a ``distribution must be finite'' error if any items of {\PFAp distribution} are infinite or {\PFAc NaN}. \vspace{0.1 cm} \\ {\bf \#34072:} Raises a ``distribution must be non-negative'' error if any items of {\PFAp distribution} are negative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\pagebreak

\section{String manipulation library}

Strings are immutable, so none of the following functions modifies a string in-place.  Some return a modified version of the original string.

\subsection{Basic access}

\subsubsection{Length (s.len)}
\hypertarget{s.len}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.len":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the length of string {\PFAp s}. \vspace{0.2 cm} \\ }

\subsubsection{Extract substring (s.substr)}
\hypertarget{s.substr}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.substr":$\!$ [s, start, end]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the substring of {\PFAp s} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Modify substring (s.substrto)}
\hypertarget{s.substrto}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.substrto":$\!$ [s, start, end, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\  & \PFAc replacement \rm & string \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace {\PFAp s} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive) with {\PFAp replacement}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Search and replace}

Search and replace functions in the basic string library do not use regular expressions.

\subsubsection{Contains (s.contains)}
\hypertarget{s.contains}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.contains":$\!$ [haystack, needle]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc needle \rm & string \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp haystack} contains {\PFAp needle}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }

\subsubsection{Count instances (s.count)}
\hypertarget{s.count}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.count":$\!$ [haystack, needle]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc needle \rm & string \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Count the number of times {\PFAp needle} appears in {\PFAp haystack}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the {\PFAp needle} is an empty string, the result is zero.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Find first index (s.index)}
\hypertarget{s.index}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.index":$\!$ [haystack, needle]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc needle \rm & string \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the lowest index where {\PFAp haystack} contains {\PFAp needle} or -1 if {\PFAp haystack} does not contain {\PFAp needle}. \vspace{0.2 cm} \\ }

\subsubsection{Find last index (s.rindex)}
\hypertarget{s.rindex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.rindex":$\!$ [haystack, needle]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc needle \rm & string \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the highest index where {\PFAp haystack} contains {\PFAp needle} or -1 if {\PFAp haystack} does not contain {\PFAp needle}. \vspace{0.2 cm} \\ }

\subsubsection{Check start (s.startswith)}
\hypertarget{s.startswith}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.startswith":$\!$ [haystack, needle]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc needle \rm & string \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if the first (leftmost) subseqence of {\PFAp haystack} is equal to {\PFAp needle}, false otherwise. \vspace{0.2 cm} \\ }

\subsubsection{Check end (s.endswith)}
\hypertarget{s.endswith}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.endswith":$\!$ [haystack, needle]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc needle \rm & string \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if the last (rightmost) subseqence of {\PFAp haystack} is equal to {\PFAp needle}, false otherwise. \vspace{0.2 cm} \\ }

\subsection{Conversions to or from other types}

\subsubsection{Join an array of strings (s.join)}
\hypertarget{s.join}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.join":$\!$ [array, sep]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc array \rm & array of string \\  & \PFAc sep \rm & string \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Combine strings from {\PFAp array} into a single string, delimited by {\PFAp sep}. \vspace{0.2 cm} \\ }

\subsubsection{Split into an array of strings (s.split)}
\hypertarget{s.split}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.split":$\!$ [s, sep]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc sep \rm & string \\  & {\it (returns)} & array of string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Divide a string into an array of substrings, splitting at and removing delimiters {\PFAp sep}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp s} does not contain {\PFAp sep}, this function returns an array whose only element is {\PFAp s}.  If {\PFAp sep} appears at the beginning or end of {\PFAp s}, the array begins with or ends with an empty string.  These conventions match Python's behavior.  \vspace{0.1 cm} \\ If {\PFAp sep} is an empty string, this function returns an empty array.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Format an integer as a string (s.int)}
\hypertarget{s.int}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"s.int":$\!$ [x]\} \rm or \PFAc \{"s.int":$\!$ [x, width, zeroPad]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\ & {\it (returns)} & string \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc width \rm & int \\  & \PFAc zeroPad \rm & boolean \\ & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Format an integer as a decimal string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & The integer.  \\  & \PFAc width \rm & Width of the string.  If negative, left-justify.  If omitted, the string will be as wide as it needs to be to provide enough precision.  \\  & \PFAc zeroPad \rm & If true, pad the integer with zeros to fill up to {\PFAp width}.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#39240:} If {\PFAp width} is negative and {\PFAp zeroPad} is {\PFAc true}, a ``negative width cannot be used with zero-padding'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Format a positive integer as hexidecimal (s.hex)}
\hypertarget{s.hex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"s.hex":$\!$ [x]\} \rm or \PFAc \{"s.hex":$\!$ [x, width, zeroPad]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\ & {\it (returns)} & string \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc width \rm & int \\  & \PFAc zeroPad \rm & boolean \\ & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Format an unsigned number as a hexidecimal string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & The number.  \\  & \PFAc width \rm & Width of the string.  If negative, left-justify.  If omitted, the string will be as wide as it needs to be to provide the precision.  \\  & \PFAc zeroPad \rm & If true, pad the integer with zeros to fill up to {\PFAp width}.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the {\PFAp precision} requires more space than {\PFAp width}, the string will be wide enough to accommodate the {\PFAp precision}. \vspace{0.1 cm} \\ Digits ``a'' (decimal 10) through ``f'' (decimal 15) are represented by lowercase letters.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#39110:} If {\PFAp width} is negative and {\PFAp zeroPad} is {\PFAc true}, a ``negative width cannot be used with zero-padding'' error is raised. \vspace{0.1 cm} \\ {\bf \#39111:} If {\PFAp x} is negative, a ``negative number'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Format any number as a string (s.number)}
\hypertarget{s.number}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"s.number":$\!$ [x]\} \rm or \PFAc \{"s.number":$\!$ [x, width, zeroPad]\} \rm or \PFAc \{"s.number":$\!$ [x, width, precision]\} \rm or \PFAc \{"s.number":$\!$ [x, width, precision, minNoExp, maxNoExp]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\ & {\it (returns)} & string \\ \\ \vspace{-0.8 cm} \fbox{\bf Deprecated; exists until PFA 0.9.0: use s.int for integers.} \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc width \rm & int \\  & \PFAc zeroPad \rm & boolean \\ & {\it (returns)} & string \\ \\ \vspace{-0.8 cm} \fbox{\bf Deprecated; exists until PFA 0.9.0: use s.int for integers.} \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc width \rm & union of \{int, null\} \\  & \PFAc precision \rm & union of \{int, null\} \\ & {\it (returns)} & string \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc width \rm & union of \{int, null\} \\  & \PFAc precision \rm & union of \{int, null\} \\  & \PFAc minNoExp \rm & double \\  & \PFAc maxNoExp \rm & double \\ & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Format a number as a decimal string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & The number.  Note that different signatures apply to integers and floating point numbers.  \\  & \PFAc width \rm & Width of the string.  If negative, left-justify.  If omitted, the string will be as wide as it needs to be to provide the precision.  \\  & \PFAc zeroPad \rm & If true, pad the integer with zeros to fill up to {\PFAp width}.  \\  & \PFAc precision \rm & Optional precision with which to represent the number.  If omitted, at most six digits after the decimal point will be shown, unless they are zero.  \\  & \PFAc minNoExp \rm & Minimum absolute value that is not presented in scientific notation; 0.0001 if omitted.  \\  & \PFAc maxNoExp \rm & Maxiumum absolute value that is not presented in scientific notation; 100000 if omitted.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the {\PFAp precision} requires more space than {\PFAp width}, the string will be wide enough to accommodate the {\PFAp precision}. \vspace{0.1 cm} \\ Floating point numbers always have a decimal point with at least one digit after the decimal, even if it is zero. \vspace{0.1 cm} \\ Exponents are represented by a lowercase ``e'' which is always followed by a sign, whether positive or negative, and an exponent of two or more digits (single-digit exponents are zero-padded). \vspace{0.1 cm} \\ The base of a number is preceded by a ``-'' if negative, but not a ``+'' if positive. \vspace{0.1 cm} \\ Special floating point values are represented in the following ways: negative zero as zero (no negative sign), not a number as ``nan'', positive infinity as ``inf'', and negative infinity as ``-inf'' (lowercase).  They follow the same precision and width rules as normal numbers, where applicable. \vspace{0.1 cm} \\ {\bf Nondeterministic: unstable.} This function gives the same results every time it is executed, but those results may not be exactly the same on all systems.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#39120:} If {\PFAp width} is negative and {\PFAp zeroPad} is {\PFAc true}, a ``negative width cannot be used with zero-padding'' error is raised. \vspace{0.1 cm} \\ {\bf \#39121:} If {\PFAp precision} is provided and is less than zero, a ``negative precision'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Conversions to or from other strings}

\subsubsection{Concatenate two strings (s.concat)}
\hypertarget{s.concat}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.concat":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\  & \PFAc y \rm & string \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Append {\PFAp y} to {\PFAp x} to form a single string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}To concatenate an array of strings, use s.join with an empty string as {\PFAp sep}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Repeat pattern (s.repeat)}
\hypertarget{s.repeat}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.repeat":$\!$ [s, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc n \rm & int \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Create a string by concatenating {\PFAp s} with itself {\PFAp n} times. \vspace{0.2 cm} \\ }

\subsubsection{Lowercase (s.lower)}
\hypertarget{s.lower}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.lower":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Convert {\PFAp s} to lower-case. \vspace{0.2 cm} \\ }

\subsubsection{Uppercase (s.upper)}
\hypertarget{s.upper}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.upper":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Convert {\PFAp s} to upper-case. \vspace{0.2 cm} \\ }

\subsubsection{Left-strip (s.lstrip)}
\hypertarget{s.lstrip}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.lstrip":$\!$ [s, chars]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc chars \rm & string \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Remove any characters found in {\PFAp chars} from the beginning (left) of {\PFAp s}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order of characters in {\PFAp chars} is irrelevant.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Right-strip (s.rstrip)}
\hypertarget{s.rstrip}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.rstrip":$\!$ [s, chars]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc chars \rm & string \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Remove any characters found in {\PFAp chars} from the end (right) of {\PFAp s}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order of characters in {\PFAp chars} is irrelevant.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Strip both ends (s.strip)}
\hypertarget{s.strip}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.strip":$\!$ [s, chars]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc chars \rm & string \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Remove any characters found in {\PFAp chars} from the beginning or end of {\PFAp s}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order of characters in {\PFAp chars} is irrelevant.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Replace all matches (s.replaceall)}
\hypertarget{s.replaceall}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.replaceall":$\!$ [s, original, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc original \rm & string \\  & \PFAc replacement \rm & string \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace every instance of the substring {\PFAp original} from {\PFAp s} with {\PFAp replacement}. \vspace{0.2 cm} \\ }

\subsubsection{Replace first match (s.replacefirst)}
\hypertarget{s.replacefirst}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.replacefirst":$\!$ [s, original, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc original \rm & string \\  & \PFAc replacement \rm & string \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace the first (leftmost) instance of the substring {\PFAp original} from {\PFAp s} with {\PFAp replacement}. \vspace{0.2 cm} \\ }

\subsubsection{Replace last match (s.replacelast)}
\hypertarget{s.replacelast}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.replacelast":$\!$ [s, original, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc original \rm & string \\  & \PFAc replacement \rm & string \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace the last (rightmost) instance of the substring {\PFAp original} from {\PFAp s} with {\PFAp replacement}. \vspace{0.2 cm} \\ }

\subsubsection{Translate characters (s.translate)}
\hypertarget{s.translate}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.translate":$\!$ [s, oldchars, newchars]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc oldchars \rm & string \\  & \PFAc newchars \rm & string \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} For each character in {\PFAp s} that is also in {\PFAp oldchars} with some index {\PFAc i}, replace it with the character at index {\PFAc i} in {\PFAp newchars}.  Any character in {\PFAp s} that is not in {\PFAp oldchars} is unchanged.  Any index {\PFAc i} that is greater than the length of {\PFAp newchars} is replaced with nothing. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This is the behavior of the the Posix command {\PFAc tr}, where {\PFAp s} takes the place of standard input and {\PFAp oldchars} and {\PFAp newchars} are the {\PFAc tr} commandline options.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\pagebreak

\section{Regular expressions and text pre-procssing}

The regular expression syntax follows the POSIX extended standard (like {\tt grep -e} in Linux and UNIX).

\subsection{Basic identification of pattern}

\subsubsection{Check for existence of a pattern (re.contains)}
\hypertarget{re.contains}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.contains":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return true if {\PFAp pattern} matches anywhere within {\PFAp haystack}, otherwise return false. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35010:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Count occurrences of a pattern (re.count)}
\hypertarget{re.count}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.count":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Count the number of times {\PFAp pattern} matches in {\PFAp haystack}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35020:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Get matched parterns}

\subsubsection{Find the first instance of a pattern (re.findfirst)}
\hypertarget{re.findfirst}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.findfirst":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & union of \{string, null\} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & union of \{bytes, null\} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the first occurance of what {\PFAp pattern} matched in {\PFAp haystack}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35070:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Find all instances of a pattern (re.findall)}
\hypertarget{re.findall}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.findall":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & array of string \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & array of bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array containing each string that {\PFAp pattern} matched in {\PFAp haystack}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35060:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Get matched groups}

\subsubsection{Get first set of matching groups (re.groups)}
\hypertarget{re.groups}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.groups":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & array of array of int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & array of array of int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the location indices of each {\PFAp pattern} sub-match (group-match) in {\PFAp haystack}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35040:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Get all sets of matching groups (re.groupsall)}
\hypertarget{re.groupsall}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.groupsall":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & array of array of array of int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & array of array of array of int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the location indices of each {\PFAp pattern} sub-match (group-match) for each occurance of {\PFAp pattern} in {\PFAp haystack}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35100:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Get matched parterns and groups}

\subsubsection{Find the first instance of a pattern, with groups (re.findgroupsfirst)}
\hypertarget{re.findgroupsfirst}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.findgroupsfirst":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & array of string \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & array of bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array of strings or bytes for each {\PFAp pattern} sub-match (group-match) at the first occurance of {\PFAp pattern} in {\PFAp haystack}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35080:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Find all instances of a pattern, with groups (re.findgroupsall)}
\hypertarget{re.findgroupsall}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.findgroupsall":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & array of array of string \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & array of array of bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array of strings or bytes for each {\PFAp pattern} sub-match (group-match) at every occurance of {\PFAp pattern} in {\PFAp haystack}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35090:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Get index position of match}

\subsubsection{Find the first index where a pattern appears (re.index)}
\hypertarget{re.index}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.index":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & array of int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & array of int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the indices in {\PFAp haystack} of the begining and end of the first match defined by {\PFAp pattern}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35000:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Find the last index where a pattern appears (re.rindex)}
\hypertarget{re.rindex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.rindex":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & array of int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & array of int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the location indices of the last {\PFAp pattern} match in {\PFAp haystack}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35030:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Find all indexes that match a pattern (re.indexall)}
\hypertarget{re.indexall}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.indexall":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & array of array of int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & array of array of int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the location indices of every {\PFAp pattern} match in {\PFAp haystack}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35050:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Replacement}

\subsubsection{Replace the first instance of a pattern (re.replacefirst)}
\hypertarget{re.replacefirst}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.replacefirst":$\!$ [haystack, pattern, replacement]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\  & \PFAc replacement \rm & string \\ & {\it (returns)} & string \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\  & \PFAc replacement \rm & bytes \\ & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace the first {\PFAp pattern} match in {\PFAp haystack} with {\PFAp replacement}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35110:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Replace the last instance of a pattern (re.replacelast)}
\hypertarget{re.replacelast}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.replacelast":$\!$ [haystack, pattern, replacement]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\  & \PFAc replacement \rm & string \\ & {\it (returns)} & string \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\  & \PFAc replacement \rm & bytes \\ & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace the last {\PFAp pattern} match in {\PFAp haystack} with {\PFAp replacement}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35120:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Replace all instances of a pattern (re.replaceall)}
\hypertarget{re.replaceall}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.replaceall":$\!$ [haystack, pattern, replacement]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\  & \PFAc replacement \rm & string \\ & {\it (returns)} & string \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\  & \PFAc replacement \rm & bytes \\ & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace the all {\PFAp pattern} matches in {\PFAp haystack} with {\PFAp replacement}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35140:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Splitting}

\subsubsection{Split a string by a pattern (re.split)}
\hypertarget{re.split}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.split":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & array of string \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & array of bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Break {\PFAp haystack} into an array of strings or bytes on the separator defined by {\PFAp pattern}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35130:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\pagebreak

\section{Parsing library}

\subsection{Parsing numbers}

\subsubsection{32-bit integers (parse.int)}
\hypertarget{parse.int}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"parse.int":$\!$ [str, base]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc str \rm & string \\  & \PFAc base \rm & int \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Parse {\PFAp str} and return its value as an integer with base {\PFAp base}, if possible. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The string is interpreted as though leading and trailing whitespace were removed and is case-insensitive. \vspace{0.1 cm} \\ Leading or trailing whitespace and any capitalization is allowed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#33000:} Raises ``not an integer'' if the string does not conform to ``{\PFAc [-+]?[0-9a-z]+}'' or the number it evaluates to is too large to represent as a 32-bit integer or uses characters as large as or larger than {\PFAp base} ('0' through '9' encode 0 through 9 and 'a' through 'z' encode 10 through 35). \vspace{0.1 cm} \\ {\bf \#33001:} Raises ``base out of range'' if {\PFAp base} is less than 2 or greater than 36.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{64-bit integers (parse.long)}
\hypertarget{parse.long}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"parse.long":$\!$ [str, base]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc str \rm & string \\  & \PFAc base \rm & int \\  & {\it (returns)} & long \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Parse {\PFAp str} and return its value as a long integer with base {\PFAp base}, if possible. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The string is interpreted as though leading and trailing whitespace were removed and is case-insensitive. \vspace{0.1 cm} \\ Leading or trailing whitespace and any capitalization is allowed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#33010:} Raises ``not a long integer'' if the string does not conform to ``{\PFAc [-+]?[0-9a-z]+}'' or the number it evaluates to is too large to represent as a 64-bit integer or uses characters as large as or larger than {\PFAp base} ('0' through '9' encode 0 through 9 and 'a' through 'z' encode 10 through 35). \vspace{0.1 cm} \\ {\bf \#33011:} Raises ``base out of range'' if {\PFAp base} is less than 2 or greater than 36.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Single-precision floating point (parse.float)}
\hypertarget{parse.float}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"parse.float":$\!$ [str]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc str \rm & string \\  & {\it (returns)} & float \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Parse {\PFAp str} and return its value as a single-precision floating point number. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The string is interpreted as though leading and trailing whitespace were removed and is case-insensitive. \vspace{0.1 cm} \\ If the string is ``nan'', the resulting value is not-a-number and if the string is ``inf'', ``+inf'', or ``-inf'', the resulting value is positive infinity, positive infinity, or negative infinity, respectively (see IEEE 754). \vspace{0.1 cm} \\ If the number's magnitude is too large to be represented as a single-precision float, the resulting value is positive or negative infinity (depending on the sign).  If the numbers magnitude is too small to be represented as a single-precision float, the resulting value is zero. \vspace{0.1 cm} \\ Leading or trailing whitespace and any capitalization is allowed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#33020:} Raises ``not a single-precision float'' if the string does not conform to ``{\PFAc [-+]?(\\.?[0-9]+|[0-9]+\\.[0-9]*)([eE][-+]?[0-9]+)?}'', ``inf'', ``+inf'', ``-inf'', or ``nan''.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Double-precision floating point (parse.double)}
\hypertarget{parse.double}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"parse.double":$\!$ [str]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc str \rm & string \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Parse {\PFAp str} and return its value as a double-precision floating point number. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The string is interpreted as though leading and trailing whitespace were removed and is case-insensitive. \vspace{0.1 cm} \\ If the string is ``nan'', the resulting value is not-a-number and if the string is ``inf'', ``+inf'', or ``-inf'', the resulting value is positive infinity, positive infinity, or negative infinity, respectively (see IEEE 754). \vspace{0.1 cm} \\ If the number's magnitude is too large to be represented as a double-precision float, the resulting value is positive or negative infinity (depending on the sign).  If the numbers magnitude is too small to be represented as a double-precision float, the resulting value is zero. \vspace{0.1 cm} \\ Leading or trailing whitespace and any capitalization is allowed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#33030:} Raises ``not a double-precision float'' if the string does not conform to ``{\PFAc [-+]?(\\.?[0-9]+|[0-9]+\\.[0-9]*)([eE][-+]?[0-9]+)?}'', ``inf'', ``+inf'', ``-inf'', or ``nan''.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\pagebreak

\section{Casting library}

\subsection{Casting numbers as numbers of a different type}

\subsubsection{Signed integers with wrap-around (cast.signed)}
\hypertarget{cast.signed}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"cast.signed":$\!$ [x, bits]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc bits \rm & int \\  & {\it (returns)} & long \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Truncate {\PFAp x} as though its signed long two's complement representation were inserted, bit-for-bit, into a signed two's complement representation that is {\PFAp bits} wide, removing the most significant bits. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The result of this function may be negative, zero, or positive.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#17000:} If {\PFAp bits} is less than 2 or greater than 64, an ``unrepresentable unsigned number'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Unsigned integers with wrap-around (cast.unsigned)}
\hypertarget{cast.unsigned}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"cast.unsigned":$\!$ [x, bits]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc bits \rm & int \\  & {\it (returns)} & long \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Truncate {\PFAp x} as though its signed long two's complement representation were inserted, bit-for-bit, into an unsigned register that is {\PFAp bits} wide, removing the most significant bits. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The result of this function is always nonnegative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#17010:} If {\PFAp bits} is less than 1 or greater than 63, an ``unrepresentable unsigned number'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{32-bit integers (cast.int)}
\hypertarget{cast.int}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.int":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Cast {\PFAp x} to an integer, rounding if necessary. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#17020:} Results outside of -2147483648 and 2147483647 (inclusive) produce an ``int overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{64-bit integers (cast.long)}
\hypertarget{cast.long}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.long":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\ & {\it (returns)} & long \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\ & {\it (returns)} & long \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & long \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & long \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Cast {\PFAp x} to a 64-bit integer, rounding if necessary. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#17030:} Results outside of -9223372036854775808 and 9223372036854775807 (inclusive) produce a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Single-precision floating point (cast.float)}
\hypertarget{cast.float}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.float":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\ & {\it (returns)} & float \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\ & {\it (returns)} & float \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & float \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & float \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Cast {\PFAp x} to a single-precision floating point number, rounding if necessary. \vspace{0.2 cm} \\ }

\subsubsection{Double-precision floating point (cast.double)}
\hypertarget{cast.double}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.double":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Cast {\PFAp x} to a double-precision floating point number. \vspace{0.2 cm} \\ }

\subsection{Fanning out variables to arrays of various types}

\subsubsection{Fan a variable out to an array of booleans (cast.fanoutBoolean)}
\hypertarget{cast.fanoutBoolean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.fanoutBoolean":$\!$ [x]\} \rm or \PFAc \{"cast.fanoutBoolean":$\!$ [x, dictionary, outOfRange]\} \rm or \PFAc \{"cast.fanoutBoolean":$\!$ [x, minimum, maximum, outOfRange]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any enum {\PFAtp A} \\ & {\it (returns)} & array of boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\  & \PFAc dictionary \rm & array of string \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc minimum \rm & int \\  & \PFAc maximum \rm & int \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Fanout {\PFAp x} to an array of booleans, all {\PFAc false} except the matching value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Categorical datum  \\  & \PFAc dictionary \rm & Possible values of {\PFAp x}, which is needed if {\PFAp x} is an arbitrary string.  \\  & \PFAc minimum \rm & Inclusive minimum value of {\PFAp x}.  \\  & \PFAc maximum \rm & Excluded maximum value of {\PFAp x}.  \\  & \PFAc outOfRange \rm & If {\PFAc true}, include an extra item in the output to represent values of {\PFAp x} that are outside of the specified range.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#17060:} If not all values in {\PFAp dictionary} are unique, this function raises a ``non-distinct values in dictionary'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Fan a variable out to an array of ints (cast.fanoutInt)}
\hypertarget{cast.fanoutInt}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.fanoutInt":$\!$ [x]\} \rm or \PFAc \{"cast.fanoutInt":$\!$ [x, dictionary, outOfRange]\} \rm or \PFAc \{"cast.fanoutInt":$\!$ [x, minimum, maximum, outOfRange]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any enum {\PFAtp A} \\ & {\it (returns)} & array of int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\  & \PFAc dictionary \rm & array of string \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc minimum \rm & int \\  & \PFAc maximum \rm & int \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Fanout {\PFAp x} to an array of booleans, all {\PFAc false} except the matching value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Categorical datum  \\  & \PFAc dictionary \rm & Possible values of {\PFAp x}, which is needed if {\PFAp x} is an arbitrary string.  \\  & \PFAc minimum \rm & Inclusive minimum value of {\PFAp x}.  \\  & \PFAc maximum \rm & Excluded maximum value of {\PFAp x}.  \\  & \PFAc outOfRange \rm & If {\PFAc true}, include an extra item in the output to represent values of {\PFAp x} that are outside of the specified range.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#17070:} If not all values in {\PFAp dictionary} are unique, this function raises a ``non-distinct values in dictionary'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Fan a variable out to an array of longs (cast.fanoutLong)}
\hypertarget{cast.fanoutLong}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.fanoutLong":$\!$ [x]\} \rm or \PFAc \{"cast.fanoutLong":$\!$ [x, dictionary, outOfRange]\} \rm or \PFAc \{"cast.fanoutLong":$\!$ [x, minimum, maximum, outOfRange]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any enum {\PFAtp A} \\ & {\it (returns)} & array of long \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\  & \PFAc dictionary \rm & array of string \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of long \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc minimum \rm & int \\  & \PFAc maximum \rm & int \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of long \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Fanout {\PFAp x} to an array of booleans, all {\PFAc false} except the matching value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Categorical datum  \\  & \PFAc dictionary \rm & Possible values of {\PFAp x}, which is needed if {\PFAp x} is an arbitrary string.  \\  & \PFAc minimum \rm & Inclusive minimum value of {\PFAp x}.  \\  & \PFAc maximum \rm & Excluded maximum value of {\PFAp x}.  \\  & \PFAc outOfRange \rm & If {\PFAc true}, include an extra item in the output to represent values of {\PFAp x} that are outside of the specified range.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#17080:} If not all values in {\PFAp dictionary} are unique, this function raises a ``non-distinct values in dictionary'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Fan a variable out to an array of floats (cast.fanoutFloat)}
\hypertarget{cast.fanoutFloat}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.fanoutFloat":$\!$ [x]\} \rm or \PFAc \{"cast.fanoutFloat":$\!$ [x, dictionary, outOfRange]\} \rm or \PFAc \{"cast.fanoutFloat":$\!$ [x, minimum, maximum, outOfRange]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any enum {\PFAtp A} \\ & {\it (returns)} & array of float \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\  & \PFAc dictionary \rm & array of string \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of float \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc minimum \rm & int \\  & \PFAc maximum \rm & int \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of float \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Fanout {\PFAp x} to an array of booleans, all {\PFAc false} except the matching value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Categorical datum  \\  & \PFAc dictionary \rm & Possible values of {\PFAp x}, which is needed if {\PFAp x} is an arbitrary string.  \\  & \PFAc minimum \rm & Inclusive minimum value of {\PFAp x}.  \\  & \PFAc maximum \rm & Excluded maximum value of {\PFAp x}.  \\  & \PFAc outOfRange \rm & If {\PFAc true}, include an extra item in the output to represent values of {\PFAp x} that are outside of the specified range.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#17090:} If not all values in {\PFAp dictionary} are unique, this function raises a ``non-distinct values in dictionary'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Fan a variable out to an array of doubles (cast.fanoutDouble)}
\hypertarget{cast.fanoutDouble}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.fanoutDouble":$\!$ [x]\} \rm or \PFAc \{"cast.fanoutDouble":$\!$ [x, dictionary, outOfRange]\} \rm or \PFAc \{"cast.fanoutDouble":$\!$ [x, minimum, maximum, outOfRange]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any enum {\PFAtp A} \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\  & \PFAc dictionary \rm & array of string \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc minimum \rm & int \\  & \PFAc maximum \rm & int \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Fanout {\PFAp x} to an array of booleans, all {\PFAc false} except the matching value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Categorical datum  \\  & \PFAc dictionary \rm & Possible values of {\PFAp x}, which is needed if {\PFAp x} is an arbitrary string.  \\  & \PFAc minimum \rm & Inclusive minimum value of {\PFAp x}.  \\  & \PFAc maximum \rm & Excluded maximum value of {\PFAp x}.  \\  & \PFAc outOfRange \rm & If {\PFAc true}, include an extra item in the output to represent values of {\PFAp x} that are outside of the specified range.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#17100:} If not all values in {\PFAp dictionary} are unique, this function raises a ``non-distinct values in dictionary'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Serializing arbitrary objects}

\subsubsection{Serialize an arbitrary object as Avro bytes (cast.avro)}
\hypertarget{cast.avro}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"cast.avro":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Encode an arbitrary object as Avro bytes. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}May be composed with {\PFAf \hyperlink{bytes.toBase64}{bytes.toBase64}} to get an efficient string representation (e.g. for map keys).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Serialize an arbitrary object as a JSON string (cast.json)}
\hypertarget{cast.json}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"cast.json":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Encode an arbitrary object as a JSON string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The form of this JSON string (spacing, order of keys in objects, etc.) is not guaranteed from one system to another. \vspace{0.1 cm} \\ Should exclude unnecessary whitespace. \vspace{0.1 cm} \\ {\bf Nondeterministic: unstable.} This function gives the same results every time it is executed, but those results may not be exactly the same on all systems.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\pagebreak

\section{Array manipulation library}

Arrays are immutable, so none of the following functions modifies an array in-place.  Some return a modified version of the original array.

\subsection{Basic access}

\subsubsection{Length (a.len)}
\hypertarget{a.len}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.len":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the length of array {\PFAp a}. \vspace{0.2 cm} \\ }

\subsubsection{Extract subsequence (a.subseq)}
\hypertarget{a.subseq}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.subseq":$\!$ [a, start, end]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the subsequence of {\PFAp a} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Extract the first item (a.head)}
\hypertarget{a.head}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.head":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the first item of the array. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15020:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Extract all but the first item (a.tail)}
\hypertarget{a.tail}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.tail":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return all but the first item of the array. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15030:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Extract the last item (a.last)}
\hypertarget{a.last}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.last":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the last item of the array. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15040:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Extract all but the last item (a.init)}
\hypertarget{a.init}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.init":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return all but the last item of the array. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15050:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Modify subsequence (a.subseqto)}
\hypertarget{a.subseqto}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.subseqto":$\!$ [a, start, end, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\  & \PFAc replacement \rm & array of {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new array by replacing {\PFAp a} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive) with {\PFAp replacement}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior. \vspace{0.1 cm} \\ Note: {\PFAp a} is not changed in-place; this is a side-effect-free function.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Search and replace}

\subsubsection{Contains (a.contains)}
\hypertarget{a.contains}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.contains":$\!$ [haystack, needle]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & array of {\PFAtp A} \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & {\PFAtp A} \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & function ({\PFAtp A}) $\to$ boolean \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp haystack} contains {\PFAp needle} or the {\PFAp needle} function evaluates to {\PFAc true}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }

\subsubsection{Count instances (a.count)}
\hypertarget{a.count}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.count":$\!$ [haystack, needle]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & array of {\PFAtp A} \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & {\PFAtp A} \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & function ({\PFAtp A}) $\to$ boolean \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Count the number of times {\PFAp needle} appears in {\PFAp haystack} or the number of times the {\PFAp needle} function evaluates to {\PFAc true}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the {\PFAp needle} is an empty array, the result is zero.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Find first index (a.index)}
\hypertarget{a.index}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.index":$\!$ [haystack, needle]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & array of {\PFAtp A} \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & {\PFAtp A} \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & function ({\PFAtp A}) $\to$ boolean \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the lowest index where {\PFAp haystack} contains {\PFAp needle} or the {\PFAp needle} function evaluates to {\PFAc true}, $-1$ if there is no such element. \vspace{0.2 cm} \\ }

\subsubsection{Find last index (a.rindex)}
\hypertarget{a.rindex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.rindex":$\!$ [haystack, needle]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & array of {\PFAtp A} \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & {\PFAtp A} \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & function ({\PFAtp A}) $\to$ boolean \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the highest index where {\PFAp haystack} contains {\PFAp needle} or the {\PFAp needle} function evaluates to {\PFAc true}, $-1$ if there is no such element. \vspace{0.2 cm} \\ }

\subsubsection{Check start (a.startswith)}
\hypertarget{a.startswith}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.startswith":$\!$ [haystack, needle]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & array of {\PFAtp A} \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & {\PFAtp A} \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if the first (leftmost) subseqence of {\PFAp haystack} is equal to {\PFAp needle}, false otherwise. \vspace{0.2 cm} \\ }

\subsubsection{Check end (a.endswith)}
\hypertarget{a.endswith}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.endswith":$\!$ [haystack, needle]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & array of {\PFAtp A} \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & {\PFAtp A} \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if the last (rightmost) subseqence of {\PFAp haystack} is equal to {\PFAp needle}, false otherwise. \vspace{0.2 cm} \\ }

\subsection{Manipulation}

\subsubsection{Concatenate two arrays (a.concat)}
\hypertarget{a.concat}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.concat":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Concatenate {\PFAp a} and {\PFAp b} to make a new array of the same type. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The length of the returned array is the sum of the lengths of {\PFAp a} and {\PFAp b}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Append (a.append)}
\hypertarget{a.append}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.append":$\!$ [a, item]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc item \rm & {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new array by adding {\PFAp item} at the end of {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp a} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ The length of the returned array is one more than {\PFAp a}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Append to a circular buffer with a maximum size (a.cycle)}
\hypertarget{a.cycle}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.cycle":$\!$ [a, item, maxLength]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc item \rm & {\PFAtp A} \\  & \PFAc maxLength \rm & int \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new array by adding {\PFAp item} at the end of {\PFAp a}, but keep the length less than or equal to {\PFAp maxLength} by removing items from the beginning. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp a} is not changed in-place; this is a side-effect-free function.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15150:} If {\PFAp maxLength} is less than 0, this function raises a ``maxLength out of range'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Insert or prepend (a.insert)}
\hypertarget{a.insert}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.insert":$\!$ [a, index, item]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc index \rm & int \\  & \PFAc item \rm & {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new array by inserting {\PFAp item} at {\PFAp index} of {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), following Python's index behavior. \vspace{0.1 cm} \\ Note: {\PFAp a} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ The length of the returned array is one more than {\PFAp a}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15160:} If {\PFAp index} is beyond the range of {\PFAp a}, an ``index out of range'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Replace item (a.replace)}
\hypertarget{a.replace}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.replace":$\!$ [a, index, item]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc index \rm & int \\  & \PFAc item \rm & {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new array by replacing {\PFAp index} of {\PFAp a} with {\PFAp item}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), following Python's index behavior. \vspace{0.1 cm} \\ Note: {\PFAp a} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ The length of the returned array is equal to that of {\PFAp a}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15170:} If {\PFAp index} is beyond the range of {\PFAp a}, an ``index out of range'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Remove item (a.remove)}
\hypertarget{a.remove}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.remove":$\!$ [a, start, end]\} \rm or \PFAc \{"a.remove":$\!$ [a, index]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\ & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc index \rm & int \\ & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new array by removing elements from {\PFAp a} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive) or just a single {\PFAp index}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior. \vspace{0.1 cm} \\ Note: {\PFAp a} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ The length of the returned array is one less than {\PFAp a}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15180:} If {\PFAp index} is beyond the range of {\PFAp a}, an ``index out of range'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Rotate an array left (a.rotate)}
\hypertarget{a.rotate}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.rotate":$\!$ [a, steps]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc steps \rm & int \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array formed by rotating {\PFAp a} left {\PFAp steps} spaces. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15190:} If {\PFAp steps} is less than zero, a ``steps out of range'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Reordering}

\subsubsection{Sort (a.sort)}
\hypertarget{a.sort}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.sort":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array with the same elements as {\PFAp a} but in ascending order (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp a} is not changed in-place; this is a side-effect-free function.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Sort with a less-than function (a.sortLT)}
\hypertarget{a.sortLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.sortLT":$\!$ [a, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array with the same elements as {\PFAp a} but in ascending order as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp a} is not changed in-place; this is a side-effect-free function.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Randomly shuffle array (a.shuffle)}
\hypertarget{a.shuffle}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.shuffle":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array with the same elements as {\PFAp a} but in a random order. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp a} is not changed in-place; this is a side-effect-free function (except for updating the random number generator). \vspace{0.1 cm} \\ {\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Reverse order (a.reverse)}
\hypertarget{a.reverse}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.reverse":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the elements of {\PFAp a} in reversed order. \vspace{0.2 cm} \\ }

\subsection{Extreme values}

The functions listed here provide the Cartesian product of the following features: (1) minimization and maximization, (2) using the natural Avro sort order or a custom less-than function, (3) returning only the most extreme value or an array of the $N$ most extreme values, (4) returning the values themselves or the indexes of the values in the array.  Each combination is provided as a separate function to avoid complicating the type signatures of the functions.

\subsubsection{Maximum of all values (a.max)}
\hypertarget{a.max}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.max":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the maximum value in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15240:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Minimum of all values (a.min)}
\hypertarget{a.min}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.min":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the minimum value in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15250:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Maximum with a less-than function (a.maxLT)}
\hypertarget{a.maxLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.maxLT":$\!$ [a, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the maximum value in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15260:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Minimum with a less-than function (a.minLT)}
\hypertarget{a.minLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.minLT":$\!$ [a, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the minimum value in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15270:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Maximum $N$ items (a.maxN)}
\hypertarget{a.maxN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.maxN":$\!$ [a, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the {\PFAp n} highest values in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15280:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#15281:} If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Minimum $N$ items (a.minN)}
\hypertarget{a.minN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.minN":$\!$ [a, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the {\PFAp n} lowest values in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15290:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#15291:} If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Maximum $N$ with a less-than function (a.maxNLT)}
\hypertarget{a.maxNLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.maxNLT":$\!$ [a, n, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the {\PFAp n} highest values in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15300:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#15301:} If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Minimum $N$ with a less-than function (a.minNLT)}
\hypertarget{a.minNLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.minNLT":$\!$ [a, n, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the {\PFAp n} lowest values in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15310:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#15311:} If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Argument maximum (a.argmax)}
\hypertarget{a.argmax}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argmax":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the index of the maximum value in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the maximum is not unique, this function returns the index of the first maximal value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15320:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Argument minimum (a.argmin)}
\hypertarget{a.argmin}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argmin":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the index of the minimum value in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the minimum is not unique, this function returns the index of the first minimal value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15330:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Argument maximum with a less-than function (a.argmaxLT)}
\hypertarget{a.argmaxLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argmaxLT":$\!$ [a, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the index of the maximum value in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the maximum is not unique, this function returns the index of the first maximal value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15340:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Argument minimum with a less-than function (a.argminLT)}
\hypertarget{a.argminLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argminLT":$\!$ [a, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the index of the minimum value in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the minimum is not unique, this function returns the index of the first minimal value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15350:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Maximum $N$ arguments (a.argmaxN)}
\hypertarget{a.argmaxN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argmaxN":$\!$ [a, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & {\it (returns)} & array of int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the indexes of the {\PFAp n} highest values in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their indexes will be returned in ascending order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15360:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#15361:} If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Minimum $N$ arguments (a.argminN)}
\hypertarget{a.argminN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argminN":$\!$ [a, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & {\it (returns)} & array of int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the indexes of the {\PFAp n} lowest values in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their indexes will be returned in ascending order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15370:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#15371:} If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Maximum $N$ arguments with a less-than function (a.argmaxNLT)}
\hypertarget{a.argmaxNLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argmaxNLT":$\!$ [a, n, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the indexes of the {\PFAp n} highest values in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their indexes will be returned in ascending order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15380:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#15381:} If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Minimum $N$ arguments with a less-than function (a.argminNLT)}
\hypertarget{a.argminNLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argminNLT":$\!$ [a, n, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the indexes of the {\PFAp n} lowest values in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their indexes will be returned in ascending order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15390:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#15391:} If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Numerical combinations}

\subsubsection{Add all array values (a.sum)}
\hypertarget{a.sum}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.sum":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} of \{int, long, float, double\} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the sum of numbers in {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Returns zero if the array is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15400:} If the array items have integer type and the final result is too large or small to be represented as an integer, an ``int overflow'' error is raised. \vspace{0.1 cm} \\ {\bf \#15401:} If the array items have long integer type and the final result is too large or small to be represented as a long integer, an ``long overflow'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Multiply all array values (a.product)}
\hypertarget{a.product}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.product":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} of \{int, long, float, double\} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the product of numbers in {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Returns one if the array is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15410:} If the array items have integer type and the final result is too large or small to be represented as an integer, an ``int overflow'' error is raised. \vspace{0.1 cm} \\ {\bf \#15411:} If the array items have long integer type and the final result is too large or small to be represented as a long integer, an ``long overflow'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Sum of logarithms (a.lnsum)}
\hypertarget{a.lnsum}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.lnsum":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the sum of the natural logarithm of numbers in {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Returns zero if the array is empty and {\PFAc NaN} if any value in the array is zero or negative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Log of the sum of exponentials without roundoff error (a.logsumexp)}
\hypertarget{a.logsumexp}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.logsumexp":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute $z = \\log(\\sum_{n = 1}^{N} e^{x_n})$ in a numerically stable way. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Returns {\PFAc NaN} if the array is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Arithmetic mean (a.mean)}
\hypertarget{a.mean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.mean":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the arithmetic mean of numbers in {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Returns {\PFAc NaN} if the array is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Geometric mean (a.geomean)}
\hypertarget{a.geomean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.geomean":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the geometric mean of numbers in {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Returns {\PFAc NaN} if the array is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Median (a.median)}
\hypertarget{a.median}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.median":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the value that is in the center of a sorted version of {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} has an odd number of elements, the median is the exact center of the sorted array.  If {\PFAp a} has an even number of elements and is a {\PFAc float} or {\PFAc double}, the median is the average of the two elements closest to the center of the sorted array.  For any other type, the median is the left (first) of the two elements closest to the center of the sorted array.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15450:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Percentile in unit interval (a.ntile)}
\hypertarget{a.ntile}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.ntile":$\!$ [a, p]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc p \rm & double \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the value that is at the ``n-tile'' of {\PFAp a} (like a percentile). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc a \rm & Array of objects to be take the percentile of.  \\  & \PFAc p \rm & A double between 0 and 1.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} has an even number of elements and is a {\PFAc float} or {\PFAc double}, this function will take the average of the two elements closest to the center of the sorted array.  For any other type, it returns the left (first) of the two elements closest to the center of the sorted array.  If {\PFAp p} is exactly one (or greater), the max of the array is returned.  If {\PFAp p} is zero (or less), the min of the array is returned.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15460:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#15461:} If {\PFAp p} is NaN, this function raises a ``p not a number'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Mode, or most common value (a.mode)}
\hypertarget{a.mode}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.mode":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the mode (most common) value of {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If several different values are equally common, the median of these is returned.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15470:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\hypertarget{hsec:set-like}{}
\subsection{Set or set-like functions}
\label{sec:set-like}

PFA does not have a set datatype, but arrays can be interpreted as sets with the following functions, which provide access and update times that scale with the length of the array.  To represent sets using constant-time hashtables, see the corresponding functions in \hyperlink{hsec:set-like-map}{Sec.~\ref{sec:set-like-map}}.

\subsubsection{Distinct items (a.distinct)}
\hypertarget{a.distinct}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.distinct":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array with the same contents as {\PFAp a} but with duplicates removed. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order of the original array is preserved.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Set equality (a.seteq)}
\hypertarget{a.seteq}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.seteq":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp a} and {\PFAp b} are equivalent, ignoring order and duplicates, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }

\subsubsection{Union (a.union)}
\hypertarget{a.union}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.union":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array that represents the union of {\PFAp a} and {\PFAp b}, treated as sets (ignoring order and duplicates). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order of the original arrays is preserved.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Intersection (a.intersection)}
\hypertarget{a.intersection}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.intersection":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array that represents the intersection of {\PFAp a} and {\PFAp b}, treated as sets (ignoring order and duplicates). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order of the original arrays is preserved.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Set difference (a.diff)}
\hypertarget{a.diff}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.diff":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array that represents the difference of {\PFAp a} and {\PFAp b}, treated as sets (ignoring order and duplicates). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order of the original arrays is preserved.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Symmetric set difference (a.symdiff)}
\hypertarget{a.symdiff}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.symdiff":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array that represents the symmetric difference of {\PFAp a} and {\PFAp b}, treated as sets (ignoring order and duplicates). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The symmetric difference is ({\PFAp a} diff {\PFAp b}) union ({\PFAp b} diff {\PFAp a}). \vspace{0.1 cm} \\ The order of the original arrays is preserved.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Subset check (a.subset)}
\hypertarget{a.subset}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.subset":$\!$ [little, big]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc little \rm & array of any {\PFAtp A} \\  & \PFAc big \rm & array of {\PFAtp A} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp little} is a subset of {\PFAp big}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }

\subsubsection{Disjointness check (a.disjoint)}
\hypertarget{a.disjoint}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.disjoint":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp a} and {\PFAp b} are disjoint, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }

\subsection{Functional programming}

These are the standard functors found in most functional programming contexts.

\subsubsection{Transform array items with function (a.map)}
\hypertarget{a.map}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.map":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ any {\PFAtp B} \\  & {\it (returns)} & array of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and return an array of the results. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Transform array items, providing access to the index (a.mapWithIndex)}
\hypertarget{a.mapWithIndex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.mapWithIndex":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function (int, {\PFAtp A}) $\to$ any {\PFAtp B} \\  & {\it (returns)} & array of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to index, element pairs from {\PFAp a} and return an array of the results. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Filter array items with a function (a.filter)}
\hypertarget{a.filter}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.filter":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and return an array of the elements for which {\PFAp fcn} returns {\PFAc true}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Filter array items, providing access to the index (a.filterWithIndex)}
\hypertarget{a.filterWithIndex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.filterWithIndex":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function (int, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each index, element pair of {\PFAp a} and return an array of the elements for which {\PFAp fcn} returns {\PFAc true}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Filter and map (a.filterMap)}
\hypertarget{a.filterMap}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.filterMap":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ union of \{any {\PFAtp B}, null\} \\  & {\it (returns)} & array of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and return an array of the results that are not {\PFAc null}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Filter and map, providing access to the index (a.filterMapWithIndex)}
\hypertarget{a.filterMapWithIndex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.filterMapWithIndex":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function (int, {\PFAtp A}) $\to$ union of \{any {\PFAtp B}, null\} \\  & {\it (returns)} & array of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each index, element pair of {\PFAp a} and return an array of the results that are not {\PFAc null}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Map and flatten (a.flatMap)}
\hypertarget{a.flatMap}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.flatMap":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ array of any {\PFAtp B} \\  & {\it (returns)} & array of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and flatten the resulting arrays into a single array. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Map and flatten, providing access to the index (a.flatMapWithIndex)}
\hypertarget{a.flatMapWithIndex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.flatMapWithIndex":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function (int, {\PFAtp A}) $\to$ array of any {\PFAtp B} \\  & {\it (returns)} & array of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each index, element pair of {\PFAp a} and flatten the resulting arrays into a single array. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Zip and map (a.zipmap)}
\hypertarget{a.zipmap}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.zipmap":$\!$ [a, b, fcn]\} \rm or \PFAc \{"a.zipmap":$\!$ [a, b, c, fcn]\} \rm or \PFAc \{"a.zipmap":$\!$ [a, b, c, d, fcn]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of any {\PFAtp B} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp B}) $\to$ any {\PFAtp Z} \\ & {\it (returns)} & array of {\PFAtp Z} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of any {\PFAtp B} \\  & \PFAc c \rm & array of any {\PFAtp C} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp B}, {\PFAtp C}) $\to$ any {\PFAtp Z} \\ & {\it (returns)} & array of {\PFAtp Z} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of any {\PFAtp B} \\  & \PFAc c \rm & array of any {\PFAtp C} \\  & \PFAc d \rm & array of any {\PFAtp D} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp B}, {\PFAtp C}, {\PFAtp D}) $\to$ any {\PFAtp Z} \\ & {\it (returns)} & array of {\PFAtp Z} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to the elements of {\PFAp a}, {\PFAp b}, {\PFAp c}, {\PFAp d} in lock-step and return a result for row. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15650:} Raises a ``misaligned arrays'' error if {\PFAp a}, {\PFAp b}, {\PFAp c}, {\PFAp d} do not all have the same length.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Zip and map, providing access to the index (a.zipmapWithIndex)}
\hypertarget{a.zipmapWithIndex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.zipmapWithIndex":$\!$ [a, b, fcn]\} \rm or \PFAc \{"a.zipmapWithIndex":$\!$ [a, b, c, fcn]\} \rm or \PFAc \{"a.zipmapWithIndex":$\!$ [a, b, c, d, fcn]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of any {\PFAtp B} \\  & \PFAc fcn \rm & function (int, {\PFAtp A}, {\PFAtp B}) $\to$ any {\PFAtp Z} \\ & {\it (returns)} & array of {\PFAtp Z} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of any {\PFAtp B} \\  & \PFAc c \rm & array of any {\PFAtp C} \\  & \PFAc fcn \rm & function (int, {\PFAtp A}, {\PFAtp B}, {\PFAtp C}) $\to$ any {\PFAtp Z} \\ & {\it (returns)} & array of {\PFAtp Z} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of any {\PFAtp B} \\  & \PFAc c \rm & array of any {\PFAtp C} \\  & \PFAc d \rm & array of any {\PFAtp D} \\  & \PFAc fcn \rm & function (int, {\PFAtp A}, {\PFAtp B}, {\PFAtp C}, {\PFAtp D}) $\to$ any {\PFAtp Z} \\ & {\it (returns)} & array of {\PFAtp Z} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to the indexes and elements of {\PFAp a}, {\PFAp b}, {\PFAp c}, {\PFAp d} in lock-step and return a result for row. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15660:} Raises a ``misaligned arrays'' error if {\PFAp a}, {\PFAp b}, {\PFAp c}, {\PFAp d} do not all have the same length.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Reduce array items to a single value (a.reduce)}
\hypertarget{a.reduce}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.reduce":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and accumulate a tally. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The first parameter of {\PFAp fcn} is the running tally and the second parameter is an element from {\PFAp a}. \vspace{0.1 cm} \\ The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it accumulates from left (beginning) to right (end), called exactly once for each element.  For predictable results, {\PFAp fcn} should be associative.  It need not be commutative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15670:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Right-to-left reduce (a.reduceRight)}
\hypertarget{a.reduceRight}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.reduceRight":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and accumulate a tally. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The first parameter of {\PFAp fcn} is an element from {\PFAp a} and the second parameter is the running tally. \vspace{0.1 cm} \\ The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it accumulates from right (end) to left (beginning), called exactly once for each element.  For predictable results, {\PFAp fcn} should be associative.  It need not be commutative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15680:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Fold array items to another type (a.fold)}
\hypertarget{a.fold}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.fold":$\!$ [a, zero, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc zero \rm & any {\PFAtp B} \\  & \PFAc fcn \rm & function ({\PFAtp B}, {\PFAtp A}) $\to$ {\PFAtp B} \\  & {\it (returns)} & {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and accumulate a tally, starting with {\PFAp zero}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The first parameter of {\PFAp fcn} is the running tally and the second parameter is an element from {\PFAp a}. \vspace{0.1 cm} \\ The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it accumulates from left (beginning) to right (end), called exactly once for each element.  For predictable results, {\PFAp fcn} should be associative with {\PFAp zero} as its identity; that is, {\PFAc fcn(zero, zero) = zero}.  It need not be commutative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Right-to-left fold (a.foldRight)}
\hypertarget{a.foldRight}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.foldRight":$\!$ [a, zero, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc zero \rm & any {\PFAtp B} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp B}) $\to$ {\PFAtp B} \\  & {\it (returns)} & {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and accumulate a tally, starting with {\PFAp zero}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The first parameter of {\PFAp fcn} is an element from {\PFAp a} and the second parameter is the running tally. \vspace{0.1 cm} \\ The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it accumulates from right (end) to left (beginning), called exactly once for each element.  For predictable results, {\PFAp fcn} should be associative with {\PFAp zero} as its identity; that is, {\PFAc fcn(zero, zero) = zero}.  It need not be commutative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Take items until predicate is false (a.takeWhile)}
\hypertarget{a.takeWhile}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.takeWhile":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to elements of {\PFAp a} and create an array of the longest prefix that returns {\PFAc true}, stopping with the first {\PFAc false}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Beyond the prefix, the number of {\PFAp fcn} calls is not guaranteed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Drop items until predicate is true (a.dropWhile)}
\hypertarget{a.dropWhile}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.dropWhile":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to elements of {\PFAp a} and create an array of all elements after the longest prefix that returns {\PFAc true}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Beyond the prefix, the number of {\PFAp fcn} calls is not guaranteed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Functional tests}

\subsubsection{Existential check, $\exists$ (a.any)}
\hypertarget{a.any}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.any":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp fcn} is {\PFAc true} for any element in {\PFAp a} (logical or). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The number of {\PFAp fcn} calls is not guaranteed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Univeral check, $\forall$ (a.all)}
\hypertarget{a.all}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.all":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp fcn} is {\PFAc true} for all elements in {\PFAp a} (logical and). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The number of {\PFAp fcn} calls is not guaranteed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Pairwise check of two arrays (a.corresponds)}
\hypertarget{a.corresponds}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.corresponds":$\!$ [a, b, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of any {\PFAtp B} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp B}) $\to$ boolean \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp fcn} is {\PFAc true} when applied to all pairs of elements, one from {\PFAp a} and the other from {\PFAp b} (logical relation). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The number of {\PFAp fcn} calls is not guaranteed. \vspace{0.1 cm} \\ If the lengths of {\PFAp a} and {\PFAp b} are not equal, this function returns {\PFAc false}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Pairwise check, providing access to the index (a.correspondsWithIndex)}
\hypertarget{a.correspondsWithIndex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.correspondsWithIndex":$\!$ [a, b, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of any {\PFAtp B} \\  & \PFAc fcn \rm & function (int, {\PFAtp A}, {\PFAtp B}) $\to$ boolean \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp fcn} is {\PFAc true} when applied to all triples of index, element from {\PFAp a}, element from {\PFAp b} (logical relation). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The number of {\PFAp fcn} calls is not guaranteed. \vspace{0.1 cm} \\ If the lengths of {\PFAp a} and {\PFAp b} are not equal, this function returns {\PFAc false}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Restructuring}

\subsubsection{Sliding window (a.slidingWindow)}
\hypertarget{a.slidingWindow}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.slidingWindow":$\!$ [a, size, step]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc size \rm & int \\  & \PFAc step \rm & int \\  & {\it (returns)} & array of array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array of subsequences of {\PFAp a} with length {\PFAp size} that slide through {\PFAp a} in steps of length {\PFAp step} from left to right. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15770:} If {\PFAp size} is non-positive, a ``size < 1'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#15771:} If {\PFAp step} is non-positive, a ``step < 1'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Unique combinations of a fixed size (a.combinations)}
\hypertarget{a.combinations}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.combinations":$\!$ [a, size]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc size \rm & int \\  & {\it (returns)} & array of array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return all combinations of elements of {\PFAp a} with length {\PFAp size}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15780:} If {\PFAp size} is non-positive, a ``size < 1'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Permutations (a.permutations)}
\hypertarget{a.permutations}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.permutations":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return all permutations of elements of {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This function scales rapidly with the length of the array.  For reasonably large arrays, it will result in timeout exceptions.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Flatten array (a.flatten)}
\hypertarget{a.flatten}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.flatten":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Concatenate the arrays in {\PFAp a}. \vspace{0.2 cm} \\ }

\subsubsection{Group items by category (a.groupby)}
\hypertarget{a.groupby}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.groupby":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ string \\  & {\it (returns)} & map of array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Groups elements of {\PFAp a} by the string that {\PFAp fcn} maps them to. \vspace{0.2 cm} \\ }

\pagebreak

\section{Map manipulation library}

Maps are immutable, so none of the following functions modifies a map in-place.  Some return a modified version of the original map.

\subsection{Basic access}

\subsubsection{Length (map.len)}
\hypertarget{map.len}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.len":$\!$ [m]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the length of a map. \vspace{0.2 cm} \\ }

\subsubsection{Extract the keys (map.keys)}
\hypertarget{map.keys}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.keys":$\!$ [m]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & {\it (returns)} & array of string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the keys of a map (in no particular order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: unordered.} This function gives the same set of values every time it is executed on all systems, but the values may have a different order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Extract the values (map.values)}
\hypertarget{map.values}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.values":$\!$ [m]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the values of a map (in no particular order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: unordered.} This function gives the same set of values every time it is executed on all systems, but the values may have a different order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Search and replace}

\subsubsection{Contains key (map.containsKey)}
\hypertarget{map.containsKey}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"map.containsKey":$\!$ [m, key]\} \rm or \PFAc \{"map.containsKey":$\!$ [m, fcn]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc key \rm & string \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function (string) $\to$ boolean \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if the keys of {\PFAp m} contains {\PFAp key} or {\PFAp fcn} evaluates to {\PFAc true} for some key of {\PFAp m}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }

\subsubsection{Contains value (map.containsValue)}
\hypertarget{map.containsValue}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"map.containsValue":$\!$ [m, value]\} \rm or \PFAc \{"map.containsValue":$\!$ [m, fcn]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc value \rm & {\PFAtp A} \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if the values of {\PFAp m} contains {\PFAp value} or {\PFAp fcn} evaluates to {\PFAc true} for some key of {\PFAp m}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }

\subsection{Manipulation}

\subsubsection{Insert a key-value pair (map.add)}
\hypertarget{map.add}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"map.add":$\!$ [m, key, value]\} \rm or \PFAc \{"map.add":$\!$ [m, item]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc key \rm & string \\  & \PFAc value \rm & {\PFAtp A} \\ & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc item \rm & {\PFAtp A} \\ & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new map by adding the {\PFAp key} {\PFAp value} pair to {\PFAp m} or a new set by adding the {\PFAp item} to set {\PFAp m}, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp m} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ If {\PFAp key} is in {\PFAp m}, its value will be replaced. \vspace{0.1 cm} \\ The serialization format for keys of sets is base64-encoded Avro.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Remove a key (map.remove)}
\hypertarget{map.remove}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.remove":$\!$ [m, key]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc key \rm & string \\  & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new map by removing {\PFAp key} from {\PFAp m}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp m} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ If {\PFAp key} is not in {\PFAp m}, the return value is simply {\PFAp m}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Keep only certain keys (map.only)}
\hypertarget{map.only}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.only":$\!$ [m, keys]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc keys \rm & array of string \\  & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new map, keeping only {\PFAp keys} from {\PFAp m}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp m} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ If some {\PFAp keys} are not in {\PFAp m}, they are ignored and do not appear in the return value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Keep all except certain keys (map.except)}
\hypertarget{map.except}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.except":$\!$ [m, keys]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc keys \rm & array of string \\  & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new map, keeping all but {\PFAp keys} from {\PFAp m}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp m} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ If some {\PFAp keys} are not in {\PFAp m}, they are ignored and do not appear in the return value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Add or replace keys with an overlay map (map.update)}
\hypertarget{map.update}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.update":$\!$ [base, overlay]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc base \rm & map of any {\PFAtp A} \\  & \PFAc overlay \rm & map of {\PFAtp A} \\  & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new map with key-value pairs from {\PFAp overlay} in place of or in addition to key-value pairs from {\PFAp base}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp m} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ Keys of {\PFAp overlay} that are not in {\PFAp base} are added to those in {\PFAp base} and keys of {\PFAp overlay} that are in {\PFAp base} supersede those in {\PFAp base}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Split map into an array of single-key maps (map.split)}
\hypertarget{map.split}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.split":$\!$ [m]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & {\it (returns)} & array of map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Split the map into an array of maps, each containing only one key-value pair (in no particular order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: unordered.} This function gives the same set of values every time it is executed on all systems, but the values may have a different order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Join an array of maps into one map (map.join)}
\hypertarget{map.join}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.join":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of map of any {\PFAtp A} \\  & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Join an array of maps into one map, overlaying from left to right. \vspace{0.2 cm} \\ }

\subsection{Extreme values by key}

To get the maximum or minimum value of a map, simply call {\PFAf map.values} and then use one of the array max/min functions. If, however, you need to know the {\it key} of the maximum or minimum value, use one of the below.

\subsubsection{Argument maximum (map.argmax)}
\hypertarget{map.argmax}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.argmax":$\!$ [m]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the key of the highest value in {\PFAp m} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their keys will be returned in lexicographic order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#26120:} If {\PFAp m} is empty, an ``empty map'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Argument minimum (map.argmin)}
\hypertarget{map.argmin}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.argmin":$\!$ [m]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the key of the lowest value in {\PFAp m} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their keys will be returned in lexicographic order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#26130:} If {\PFAp m} is empty, an ``empty map'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Argument maximum with a less-than function (map.argmaxLT)}
\hypertarget{map.argmaxLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.argmaxLT":$\!$ [m, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the key of the highest value in {\PFAp m} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their keys will be returned in lexicographic order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#26140:} If {\PFAp m} is empty, an ``empty map'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Argument minimum with a less-than function (map.argminLT)}
\hypertarget{map.argminLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.argminLT":$\!$ [m, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the key of the lowest value in {\PFAp m} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their keys will be returned in lexicographic order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#26150:} If {\PFAp m} is empty, an ``empty map'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Maximum $N$ arguments (map.argmaxN)}
\hypertarget{map.argmaxN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.argmaxN":$\!$ [m, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & {\it (returns)} & array of string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the keys of the {\PFAp n} highest values in {\PFAp m} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their keys will be returned in lexicographic order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#26160:} If {\PFAp m} is empty, an ``empty map'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#26161:} If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Minimum $N$ arguments (map.argminN)}
\hypertarget{map.argminN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.argminN":$\!$ [m, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & {\it (returns)} & array of string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the keys of the {\PFAp n} lowest values in {\PFAp m} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their keys will be returned in lexicographic order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#26170:} If {\PFAp m} is empty, an ``empty map'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#26171:} If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Maximum $N$ arguments with a less-than function (map.argmaxNLT)}
\hypertarget{map.argmaxNLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.argmaxNLT":$\!$ [m, n, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the keys of the {\PFAp n} highest values in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their keys will be returned in lexicographic order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#26180:} If {\PFAp m} is empty, an ``empty map'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#26181:} If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Minimum $N$ arguments with a less-than function (map.argminNLT)}
\hypertarget{map.argminNLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.argminNLT":$\!$ [m, n, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the keys of the {\PFAp n} highest values in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their keys will be returned in lexicographic order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#26190:} If {\PFAp m} is empty, an ``empty map'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#26191:} If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\hypertarget{hsec:set-like-map}{}
\subsection{Set or set-like functions}
\label{sec:set-like-map}

PFA does not have a set datatype, but maps can be interpreted as sets with the following functions, which provide some constant-time access times.  For a simpler implementation, see the corresponding sections in \hyperlink{hsec:set-like}{Sec.~\ref{sec:set-like}}.

\subsubsection{Convert an array to a map-set (map.toset)}
\hypertarget{map.toset}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.toset":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Convert an array of objects into a set of objects, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Convert a map to an array-set (map.fromset)}
\hypertarget{map.fromset}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.fromset":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & map of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Convert a set of objects into an array of objects (in no particular order), where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro. \vspace{0.1 cm} \\ This function does not verify that the serialized objects (keys) and objects (values) match: it considers only values, not keys. \vspace{0.1 cm} \\ {\bf Nondeterministic: unordered.} This function gives the same set of values every time it is executed on all systems, but the values may have a different order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Determine if an object is in the set (map.in)}
\hypertarget{map.in}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.in":$\!$ [s, x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & map of any {\PFAtp A} \\  & \PFAc x \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is contained in set {\PFAp s}, {\PFAc false} otherwise, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro. \vspace{0.1 cm} \\ This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Union (map.union)}
\hypertarget{map.union}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.union":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of {\PFAtp A} \\  & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the union of sets {\PFAp a} and {\PFAp b}, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro. \vspace{0.1 cm} \\ This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Intersection (map.intersection)}
\hypertarget{map.intersection}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.intersection":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of {\PFAtp A} \\  & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the intersection of sets {\PFAp a} and {\PFAp b}, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro. \vspace{0.1 cm} \\ This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Set difference (map.diff)}
\hypertarget{map.diff}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.diff":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of {\PFAtp A} \\  & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the difference of sets {\PFAp a} and {\PFAp b}, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro. \vspace{0.1 cm} \\ This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Symmetric set difference (map.symdiff)}
\hypertarget{map.symdiff}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.symdiff":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of {\PFAtp A} \\  & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the difference of sets {\PFAp a} and {\PFAp b}, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro. \vspace{0.1 cm} \\ This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Subset check (map.subset)}
\hypertarget{map.subset}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.subset":$\!$ [little, big]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc little \rm & map of any {\PFAtp A} \\  & \PFAc big \rm & map of {\PFAtp A} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if set {\PFAp little} is a subset of set {\PFAp big}, {\PFAc false} otherwise, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro. \vspace{0.1 cm} \\ This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Disjointness check (map.disjoint)}
\hypertarget{map.disjoint}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.disjoint":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of {\PFAtp A} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if set {\PFAp a} and set {\PFAp b} are disjoint, {\PFAc false} otherwise, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro. \vspace{0.1 cm} \\ This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Functional programming}

\subsubsection{Transform map items with a function (map.map)}
\hypertarget{map.map}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.map":$\!$ [m, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ any {\PFAtp B} \\  & {\it (returns)} & map of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each value of {\PFAp m} and return a map of transformed values (keys are unchanged). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on items in {\PFAp m} is not guaranteed, though it will be called exactly once for each value. \vspace{0.1 cm} \\ To transform both keys and values, consider applying {\PFAf \hyperlink{map.split}{map.split}}, {\PFAf \hyperlink{a.map}{a.map}}, then {\PFAf \hyperlink{map.join}{map.join}}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Transform map items, providing access to the key (map.mapWithKey)}
\hypertarget{map.mapWithKey}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.mapWithKey":$\!$ [m, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function (string, {\PFAtp A}) $\to$ any {\PFAtp B} \\  & {\it (returns)} & map of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each key, value pair of {\PFAp m} and return a map of transformed values (keys are unchanged). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on items in {\PFAp m} is not guaranteed, though it will be called exactly once for each value. \vspace{0.1 cm} \\ To transform both keys and values, consider applying {\PFAf \hyperlink{map.split}{map.split}}, {\PFAf \hyperlink{a.map}{a.map}}, then {\PFAf \hyperlink{map.join}{map.join}}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Filter map items with a function (map.filter)}
\hypertarget{map.filter}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.filter":$\!$ [m, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each value of {\PFAp m} and return a map of the values for which {\PFAp fcn} returns {\PFAc true} (keys are unchanged). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on items in {\PFAp m} is not guaranteed, though it will be called exactly once for each value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Filter map items, providing access to the key (map.filterWithKey)}
\hypertarget{map.filterWithKey}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.filterWithKey":$\!$ [m, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function (string, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each value of {\PFAp m} and return a map of the values for which {\PFAp fcn} returns {\PFAc true} (keys are unchanged). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on items in {\PFAp m} is not guaranteed, though it will be called exactly once for each value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Filter and map (map.filterMap)}
\hypertarget{map.filterMap}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.filterMap":$\!$ [m, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ union of \{any {\PFAtp B}, null\} \\  & {\it (returns)} & map of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each value of {\PFAp m} and return a map of the results that are not {\PFAc null}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on items in {\PFAp m} is not guaranteed, though it will be called exactly once for each value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Filter and map, providing access to the keys (map.filterMapWithKey)}
\hypertarget{map.filterMapWithKey}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.filterMapWithKey":$\!$ [m, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function (string, {\PFAtp A}) $\to$ union of \{any {\PFAtp B}, null\} \\  & {\it (returns)} & map of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each key-value pair of {\PFAp m} and return a map of the results that are not {\PFAc null}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on items in {\PFAp m} is not guaranteed, though it will be called exactly once for each value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Map and flatten (map.flatMap)}
\hypertarget{map.flatMap}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.flatMap":$\!$ [m, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ map of any {\PFAtp B} \\  & {\it (returns)} & map of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each value of {\PFAp m} and return a map of overlaid results. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on items in {\PFAp m} is not guaranteed, though it will be called exactly once for each value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Map and flatten, providing access to the keys (map.flatMapWithKey)}
\hypertarget{map.flatMapWithKey}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.flatMapWithKey":$\!$ [m, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function (string, {\PFAtp A}) $\to$ map of any {\PFAtp B} \\  & {\it (returns)} & map of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each key-value pair of {\PFAp m} and return a map of overlaid results. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on items in {\PFAp m} is not guaranteed, though it will be called exactly once for each value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Zip and map (map.zipmap)}
\hypertarget{map.zipmap}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"map.zipmap":$\!$ [a, b, fcn]\} \rm or \PFAc \{"map.zipmap":$\!$ [a, b, c, fcn]\} \rm or \PFAc \{"map.zipmap":$\!$ [a, b, c, d, fcn]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of any {\PFAtp B} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp B}) $\to$ any {\PFAtp Z} \\ & {\it (returns)} & map of {\PFAtp Z} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of any {\PFAtp B} \\  & \PFAc c \rm & map of any {\PFAtp C} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp B}, {\PFAtp C}) $\to$ any {\PFAtp Z} \\ & {\it (returns)} & map of {\PFAtp Z} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of any {\PFAtp B} \\  & \PFAc c \rm & map of any {\PFAtp C} \\  & \PFAc d \rm & map of any {\PFAtp D} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp B}, {\PFAtp C}, {\PFAtp D}) $\to$ any {\PFAtp Z} \\ & {\it (returns)} & map of {\PFAtp Z} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to the elements of {\PFAp a}, {\PFAp b}, {\PFAp c}, {\PFAp d} in lock-step and return a result for row. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#26370:} Raises a ``misaligned maps'' error if {\PFAp a}, {\PFAp b}, {\PFAp c}, {\PFAp d} do not all have the same keys.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Zip and map, providing access to the keys (map.zipmapWithKey)}
\hypertarget{map.zipmapWithKey}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"map.zipmapWithKey":$\!$ [a, b, fcn]\} \rm or \PFAc \{"map.zipmapWithKey":$\!$ [a, b, c, fcn]\} \rm or \PFAc \{"map.zipmapWithKey":$\!$ [a, b, c, d, fcn]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of any {\PFAtp B} \\  & \PFAc fcn \rm & function (string, {\PFAtp A}, {\PFAtp B}) $\to$ any {\PFAtp Z} \\ & {\it (returns)} & map of {\PFAtp Z} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of any {\PFAtp B} \\  & \PFAc c \rm & map of any {\PFAtp C} \\  & \PFAc fcn \rm & function (string, {\PFAtp A}, {\PFAtp B}, {\PFAtp C}) $\to$ any {\PFAtp Z} \\ & {\it (returns)} & map of {\PFAtp Z} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of any {\PFAtp B} \\  & \PFAc c \rm & map of any {\PFAtp C} \\  & \PFAc d \rm & map of any {\PFAtp D} \\  & \PFAc fcn \rm & function (string, {\PFAtp A}, {\PFAtp B}, {\PFAtp C}, {\PFAtp D}) $\to$ any {\PFAtp Z} \\ & {\it (returns)} & map of {\PFAtp Z} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to the keys and elements of {\PFAp a}, {\PFAp b}, {\PFAp c}, {\PFAp d} in lock-step and return a result for row. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#26380:} Raises a ``misaligned maps'' error if {\PFAp a}, {\PFAp b}, {\PFAp c}, {\PFAp d} do not all have the same keys.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Functional tests}

\subsubsection{Pairwise check of two maps (map.corresponds)}
\hypertarget{map.corresponds}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.corresponds":$\!$ [a, b, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of any {\PFAtp B} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp B}) $\to$ boolean \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp fcn} is {\PFAc true} when applied to all pairs of values, one from {\PFAp a} and the other from {\PFAp b} (logical relation). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The number of {\PFAp fcn} calls is not guaranteed. \vspace{0.1 cm} \\ If the key sets of {\PFAp a} and {\PFAp b} are not equal, this function returns {\PFAc false}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Pairwise check, providing access to the keys (map.correspondsWithKey)}
\hypertarget{map.correspondsWithKey}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.correspondsWithKey":$\!$ [a, b, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of any {\PFAtp B} \\  & \PFAc fcn \rm & function (string, {\PFAtp A}, {\PFAtp B}) $\to$ boolean \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp fcn} is {\PFAc true} when applied to all triples of key, value from {\PFAp a}, value from {\PFAp b} (logical relation). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The number of {\PFAp fcn} calls is not guaranteed. \vspace{0.1 cm} \\ If the key sets of {\PFAp a} and {\PFAp b} are not equal, this function returns {\PFAc false}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\pagebreak
\section{Bytes manipulation library}

\subsection{Basic access}

\subsubsection{Length (bytes.len)}
\hypertarget{bytes.len}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.len":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the length of byte array {\PFAp x}. \vspace{0.2 cm} \\ }

\subsubsection{Extract subsequence (bytes.subseq)}
\hypertarget{bytes.subseq}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.subseq":$\!$ [x, start, end]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\  & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the subsequence of {\PFAp x} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Modify subsequence (bytes.subseqto)}
\hypertarget{bytes.subseqto}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.subseqto":$\!$ [x, start, end, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\  & \PFAc replacement \rm & bytes \\  & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace {\PFAp x} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive) with {\PFAp replacement}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Test validity}

\subsubsection{Verify ASCII format (bytes.isAscii)}
\hypertarget{bytes.isAscii}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"bytes.isAscii":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Returns {\PFAc true} if {\PFAp x} is valid ASCII; {\PFAc false} otherwise. \vspace{0.2 cm} \\ }

\subsubsection{Verify LATIN-1 format (bytes.isLatin1)}
\hypertarget{bytes.isLatin1}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"bytes.isLatin1":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Returns {\PFAc true} if {\PFAp x} is valid latin-1 (ISO-8859-1); {\PFAc false} otherwise. \vspace{0.2 cm} \\ }

\subsubsection{Verify UTF-8 format (bytes.isUtf8)}
\hypertarget{bytes.isUtf8}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"bytes.isUtf8":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Returns {\PFAc true} if {\PFAp x} is valid utf-8; {\PFAc false} otherwise. \vspace{0.2 cm} \\ }

\subsubsection{Verify UTF-16 format (bytes.isUtf16)}
\hypertarget{bytes.isUtf16}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"bytes.isUtf16":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Returns {\PFAc true} if {\PFAp x} is valid utf-16 (byte order identified by optional byte-order mark); {\PFAc false} otherwise. \vspace{0.2 cm} \\ }

\subsubsection{Verify UTF-16 big endian format (bytes.isUtf16be)}
\hypertarget{bytes.isUtf16be}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"bytes.isUtf16be":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Returns {\PFAc true} if {\PFAp x} is valid big endian utf-16; {\PFAc false} otherwise. \vspace{0.2 cm} \\ }

\subsubsection{Verify UTF-16 little endian format (bytes.isUtf16le)}
\hypertarget{bytes.isUtf16le}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"bytes.isUtf16le":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Returns {\PFAc true} if {\PFAp x} is valid little endian utf-16; {\PFAc false} otherwise. \vspace{0.2 cm} \\ }

\subsection{Decode bytes to strings}

\subsubsection{Decode from ASCII format (bytes.decodeAscii)}
\hypertarget{bytes.decodeAscii}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.decodeAscii":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Decode a bytes object as an ASCII string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16090:} Raises an ``invalid bytes'' error if the bytes cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Decode from LATIN-1 format (bytes.decodeLatin1)}
\hypertarget{bytes.decodeLatin1}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.decodeLatin1":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Decode a bytes object as a latin-1 (ISO-8859-1) string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16100:} Raises an ``invalid bytes'' error if the bytes cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Decode from UTF-8 format (bytes.decodeUtf8)}
\hypertarget{bytes.decodeUtf8}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.decodeUtf8":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Decode a bytes object as a utf-8 string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16110:} Raises an ``invalid bytes'' error if the bytes cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Decode from UTF-16 format (bytes.decodeUtf16)}
\hypertarget{bytes.decodeUtf16}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.decodeUtf16":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Decode a bytes object as a utf-16 (byte order identified by optional byte-order mark) string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16120:} Raises an ``invalid bytes'' error if the bytes cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Decode from UTF-16 big endian format (bytes.decodeUtf16be)}
\hypertarget{bytes.decodeUtf16be}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.decodeUtf16be":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Decode a bytes object as a big endian utf-16 string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16130:} Raises an ``invalid bytes'' error if the bytes cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Decode from UTF-16 little endian format (bytes.decodeUtf16le)}
\hypertarget{bytes.decodeUtf16le}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.decodeUtf16le":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Decode a bytes object as a little endian utf-16 string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16140:} Raises an ``invalid bytes'' error if the bytes cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Encode strings to bytes}

\subsubsection{Encode to ASCII format (bytes.encodeAscii)}
\hypertarget{bytes.encodeAscii}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.encodeAscii":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Encode a string as ASCII bytes. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16150:} Raises an ``invalid string'' error if the string cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Encode to LATIN-1 format (bytes.encodeLatin1)}
\hypertarget{bytes.encodeLatin1}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.encodeLatin1":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Encode a string as latin-1 (ISO-8859-1) bytes. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16160:} Raises an ``invalid string'' error if the string cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Encode to UTF-8 format (bytes.encodeUtf8)}
\hypertarget{bytes.encodeUtf8}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.encodeUtf8":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Encode a string as utf-8 bytes. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16170:} Raises an ``invalid string'' error if the string cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Encode to UTF-16 format (bytes.encodeUtf16)}
\hypertarget{bytes.encodeUtf16}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.encodeUtf16":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Encode a string as utf-16 (byte order identified by optional byte-order mark) bytes. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: unstable.} This function gives the same results every time it is executed, but those results may not be exactly the same on all systems.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16180:} Raises an ``invalid string'' error if the string cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Encode to UTF-16 big endian format (bytes.encodeUtf16be)}
\hypertarget{bytes.encodeUtf16be}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.encodeUtf16be":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Encode a string as big endian utf-16 bytes. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16190:} Raises an ``invalid string'' error if the string cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Encode to UTF-16 little endian format (bytes.encodeUtf16le)}
\hypertarget{bytes.encodeUtf16le}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.encodeUtf16le":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Encode a string as little endian utf-16 bytes. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16200:} Raises an ``invalid string'' error if the string cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Base64 encoding}

\subsubsection{Encode bytes as a base64 string (bytes.toBase64)}
\hypertarget{bytes.toBase64}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.toBase64":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Convert an arbitrary bytes object to a base64-encoded string. \vspace{0.2 cm} \\ }

\subsubsection{Decode base64 string to bytes (bytes.fromBase64)}
\hypertarget{bytes.fromBase64}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.fromBase64":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Convert a base64-encoded string to a bytes object. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16220:} Raises an ``invalid base64'' error if the string is not valid base64.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\pagebreak
\section{Manipulation of other data structures}

\subsection{Fixed}

\subsubsection{Convert to bytes (fixed.toBytes)}
\hypertarget{fixed.toBytes}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"fixed.toBytes":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any fixed {\PFAtp A} \\  & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Convert fixed-length, named bytes into arbitrary-length, anonymous bytes. \vspace{0.2 cm} \\ }

\subsubsection{Convert from bytes (fixed.fromBytes)}
\hypertarget{fixed.fromBytes}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"fixed.fromBytes":$\!$ [original, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc original \rm & any fixed {\PFAtp A} \\  & \PFAc replacement \rm & bytes \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Overlay {\PFAp replacement} on top of {\PFAp original}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp replacement} is shorter than {\PFAp original}, the bytes beyond {\PFAp replacement}'s length are taken from {\PFAp original}. \vspace{0.1 cm} \\ If {\PFAp replacement} is longer than {\PFAp original}, the excess bytes are truncated.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Enum}

\subsubsection{String representation (enum.toString)}
\hypertarget{enum.toString}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"enum.toString":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any enum {\PFAtp A} \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the string representation of an enum. \vspace{0.2 cm} \\ }

\subsubsection{Integer representation (enum.toInt)}
\hypertarget{enum.toInt}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"enum.toInt":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any enum {\PFAtp A} \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the integer representation of an enum. \vspace{0.2 cm} \\ }

\subsubsection{Number of symbols (enum.numSymbols)}
\hypertarget{enum.numSymbols}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"enum.numSymbols":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any enum {\PFAtp A} \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the number of symbols associated with this enum (a constant). \vspace{0.2 cm} \\ }

\pagebreak
\section{Date/time handling}

PFA does not have a special data type for time (because there is no such type in Avro), so times are represented as the floating-point number of seconds since the beginning of 1970 in UTC.  For whole-numbered seconds, this corresponds to the UNIX timestamp.  Double precision (IEEE 64-bit representation), provides microsecond resolution until May 30, 2514.

\subsection{Extracting conventional time units from timestamp}

Time units within a second (e.g.\ millisecond past the second or microsecond past the second) can be obtained using the modulo function: {\PFAc \{"*", [\{"\%":$\!$ ["timestamp",$\!$ 1.0]\}, 1000]\}} for milliseconds.

\subsubsection{Year from timestamp (time.year)}
\hypertarget{time.year}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.year":$\!$ [ts, zone]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Get the four-digit year that the timestamp falls within. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40000:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40001:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Month of year from timestamp (time.monthOfYear)}
\hypertarget{time.monthOfYear}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.monthOfYear":$\!$ [ts, zone]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Get the month that the timestamp falls within, with 1 being January and 12 being December. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40010:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40011:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Day of year from timestamp (time.dayOfYear)}
\hypertarget{time.dayOfYear}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.dayOfYear":$\!$ [ts, zone]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Get the day of the year that the timestamp falls within, from 1 to 365 or 366 inclusive, depending on leap year. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40020:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40021:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Day of month from timestamp (time.dayOfMonth)}
\hypertarget{time.dayOfMonth}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.dayOfMonth":$\!$ [ts, zone]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Get the day of the month that the timestamp falls within, a number from 1 to 28, 29, 30, or 31, inclusive, depending on month. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40030:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40031:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Day of week from timestamp (time.dayOfWeek)}
\hypertarget{time.dayOfWeek}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.dayOfWeek":$\!$ [ts, zone]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Get the day of the week that the timestamp falls within, with 0 being Monday and 6 being Sunday. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40040:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40041:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Hour of day from timestamp (time.hourOfDay)}
\hypertarget{time.hourOfDay}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.hourOfDay":$\!$ [ts, zone]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Get the hour of the day that the timestamp falls within, from 0 to 23 inclusive. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40050:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40051:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Minutes past the hour from timestamp (time.minuteOfHour)}
\hypertarget{time.minuteOfHour}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.minuteOfHour":$\!$ [ts, zone]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Get the minute of the hour that the timestamp falls within, from 0 to 59 inclusive. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40060:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40061:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Seconds past the minute from timestamp (time.secondOfMinute)}
\hypertarget{time.secondOfMinute}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.secondOfMinute":$\!$ [ts, zone]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Get the second of the minute that the timestamp falls within, from 0 to 59 inclusive. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40070:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40071:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Constructing timestamp from conventional units}

\subsubsection{Make timestamp (time.makeTimestamp)}
\hypertarget{time.makeTimestamp}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.makeTimestamp":$\!$ [year, month, day, hour, minute, second, millisecond, zone]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc year \rm & int \\  & \PFAc month \rm & int \\  & \PFAc day \rm & int \\  & \PFAc hour \rm & int \\  & \PFAc minute \rm & int \\  & \PFAc second \rm & int \\  & \PFAc millisecond \rm & int \\  & \PFAc zone \rm & string \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Given the date and time that this time occurs in, return the timestamp. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc year \rm & The four-digit year, from 1 to 9999 inclusive.  \\  & \PFAc month \rm & The month of the year, from 1 to 12 inclusive.  \\  & \PFAc day \rm & The day of the month, from 1 to 28, 29, 30, or 31 inclusive, depending on month.  \\  & \PFAc hour \rm & The hour of the day, from 0 to 23 inclusive.  \\  & \PFAc minute \rm & The minute of the hour, from 0 to 59 inclusive.  \\  & \PFAc second \rm & The second of the minute, from 0 to 59 inclusive.  \\  & \PFAc millisecond \rm & The millisecond of the second, from 0 to 999 inclusive.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\  & {\it (return value)} \rm & The number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40080:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40081:} Raises ``timestamp undefined for given parameters'' if any one (or more) of the inputs have impossible values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Querying time intervals}

Since the timestamp is a simple number on a continuous range, one can use greater than or less than to determine if it falls within an absolute interval (e.g.\ between 3 and 5 PM on July 2, 2015).  Often, one wants to know if a timestamp falls within a repeating interval, such as between 3 and 5 PM of {\it any day.}  The following functions provide this kind of access.  (Note: if the interval is non-sensical, such as the 70th minute of an hour, the function returns false, rather than raising an exception.)

\subsubsection{Seconds of minute range (time.isSecondOfMinute)}
\hypertarget{time.isSecondOfMinute}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isSecondOfMinute":$\!$ [ts, zone, low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & \PFAc low \rm & double \\  & \PFAc high \rm & double \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Determines if a timestamp falls within a specified number of seconds in any minute. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\  & \PFAc low \rm & Minimum number of seconds (inclusive).  \\  & \PFAc high \rm & Maximum number of seconds (exclusive).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40090:} Raises ``bad time range'' if low $\mathrm{low} \geq \mathrm{high}$. \vspace{0.1 cm} \\ {\bf \#40091:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40092:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Minutes of hour range (time.isMinuteOfHour)}
\hypertarget{time.isMinuteOfHour}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isMinuteOfHour":$\!$ [ts, zone, low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & \PFAc low \rm & double \\  & \PFAc high \rm & double \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Determines if a timestamp falls within a specified number of minutes in any hour. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\  & \PFAc low \rm & Minimum number of minutes (inclusive)  \\  & \PFAc high \rm & Maximum number of minutes (exclusive).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40100:} Raises ``bad time range'' if low $\mathrm{low} \geq \mathrm{high}$. \vspace{0.1 cm} \\ {\bf \#40101:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40102:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Hour of day range (time.isHourOfDay)}
\hypertarget{time.isHourOfDay}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isHourOfDay":$\!$ [ts, zone, low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & \PFAc low \rm & double \\  & \PFAc high \rm & double \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Determines if a timestamp falls within a specified number of hours in any day. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\  & \PFAc low \rm & Minimum number of hours (inclusive).  \\  & \PFAc high \rm & Maximum number of hours (exclusive).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40110:} Raises ``bad time range'' if low $\mathrm{low} \geq \mathrm{high}$. \vspace{0.1 cm} \\ {\bf \#40111:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40112:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Day of week range (time.isDayOfWeek)}
\hypertarget{time.isDayOfWeek}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isDayOfWeek":$\!$ [ts, zone, low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & \PFAc low \rm & double \\  & \PFAc high \rm & double \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Determines if a timestamp falls within a specified day of week range, with 0 being Monday and 6 being Sunday. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\  & \PFAc low \rm & Minimum day of the week (inclusive).  \\  & \PFAc high \rm & Maximum day of the week (exclusive).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40120:} Raises ``bad time range'' if low $\mathrm{low} \geq \mathrm{high}$. \vspace{0.1 cm} \\ {\bf \#40121:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40122:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Day of month range (time.isDayOfMonth)}
\hypertarget{time.isDayOfMonth}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isDayOfMonth":$\!$ [ts, zone, low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & \PFAc low \rm & double \\  & \PFAc high \rm & double \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Determines if a timestamp falls within a specified day of month range, with 1 being the first of the month.. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\  & \PFAc low \rm & Minimum day of the month (inclusive).  \\  & \PFAc high \rm & Maximum day of the month (exclusive).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40130:} Raises ``bad time range'' if low $\mathrm{low} \geq \mathrm{high}$. \vspace{0.1 cm} \\ {\bf \#40131:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40132:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Month of year range (time.isMonthOfYear)}
\hypertarget{time.isMonthOfYear}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isMonthOfYear":$\!$ [ts, zone, low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & \PFAc low \rm & double \\  & \PFAc high \rm & double \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Determines if a timestamp falls within a specified month of year range, with 1 being January and 12 being December. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\  & \PFAc low \rm & Minimum month of the year (inclusive).  \\  & \PFAc high \rm & Maximum month of the year (exclusive).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40140:} Raises ``bad time range'' if low $\mathrm{low} \geq \mathrm{high}$. \vspace{0.1 cm} \\ {\bf \#40141:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40142:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Day of year range (time.isDayOfYear)}
\hypertarget{time.isDayOfYear}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isDayOfYear":$\!$ [ts, zone, low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & \PFAc low \rm & double \\  & \PFAc high \rm & double \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Determines if a timestamp falls within a specified day of year range, with 1 being the first of the year. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\  & \PFAc low \rm & Minimum day of year (inclusive).  \\  & \PFAc high \rm & Maximum day of year (exclusive).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40150:} Raises ``bad time range'' if low $\mathrm{low} \geq \mathrm{high}$. \vspace{0.1 cm} \\ {\bf \#40151:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40152:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Weekend range (time.isWeekend)}
\hypertarget{time.isWeekend}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isWeekend":$\!$ [ts, zone]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Returns {\PFAc true} if the timestamp falls on a Saturday or Sunday, {\PFAc false} otherwise. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40160:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40161:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Working hours range (time.isWorkHours)}
\hypertarget{time.isWorkHours}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isWorkHours":$\!$ [ts, zone]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Returns {\PFAc true} if the timestamp falls between 9 am (inclusive) and 5 pm (exclusive) on Monday through Friday, otherwise {\PFAc false}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40170:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40171:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\pagebreak

\hypertarget{hsec:impute}{}
\section{Impute library (missing data handling)}
\label{sec:impute}

Some methods for dealing with missing data are inseparable from the statistical model in question, such as adjustment factors for clustering or surrogate predicates for decision trees.  Those that can be separated have been collected here.

``To impute'' means to \href{http://en.wikipedia.org/wiki/Imputation_(statistics)}{replace missing data with substituted values}.

\subsection{Missing values as null}

\subsubsection{Skip record or halt processing (impute.errorOnNull)}
\hypertarget{impute.errorOnNull}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"impute.errorOnNull":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & union of \{any {\PFAtp A}, null\} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Skip an action by raising a runtime error when {\PFAp x} is {\PFAc null}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#21000:} Raises an ``encountered null'' error if {\PFAp x} is {\PFAc null}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Replace with default (impute.defaultOnNull)}
\hypertarget{impute.defaultOnNull}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"impute.defaultOnNull":$\!$ [x, default]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & union of \{any {\PFAtp A}, null\} \\  & \PFAc default \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace {\PFAc null} values in {\PFAp x} with {\PFAp default}. \vspace{0.2 cm} \\ }

\subsection{Floating point missing values}

\subsubsection{Check for not-a-number (impute.isnan)}
\hypertarget{impute.isnan}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"impute.isnan":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is {\PFAc nan}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }

\subsubsection{Check for infinity (impute.isinf)}
\hypertarget{impute.isinf}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"impute.isinf":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is positive or negative infinity, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }

\subsubsection{Ensure a finite number (impute.isnum)}
\hypertarget{impute.isnum}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"impute.isnum":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is neither {\PFAc nan} nor infinite, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }

\subsubsection{Skip record or halt processing (impute.errorOnNonNum)}
\hypertarget{impute.errorOnNonNum}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"impute.errorOnNonNum":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & float \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Pass through {\PFAp x} if it is neither {\PFAc nan} nor infinite, but raise an error otherwise. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#21050:} Raises an ``encountered nan'' if {\PFAp x} is {\PFAc nan}. \vspace{0.1 cm} \\ {\bf \#21051:} Raises an ``encountered +inf'' if {\PFAp x} is positive infinity. \vspace{0.1 cm} \\ {\bf \#21052:} Raises an ``encountered -inf'' if {\PFAp x} is negative infinity.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Replace with default (impute.defaultOnNonNum)}
\hypertarget{impute.defaultOnNonNum}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"impute.defaultOnNonNum":$\!$ [x, default]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\  & \PFAc default \rm & float \\ & {\it (returns)} & float \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc default \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Pass through {\PFAp x} if it is neither {\PFAc nan} nor infinite, and return {\PFAp default} otherwise. \vspace{0.2 cm} \\ }

\pagebreak

\section{Interpolation library}

\subsection{Histogram-like binning (interp.bin)}
\hypertarget{interp.bin}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"interp.bin":$\!$ [x, numbins, low, high]\} \rm or \PFAc \{"interp.bin":$\!$ [x, origin, width]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc numbins \rm & int \\  & \PFAc low \rm & double \\  & \PFAc high \rm & double \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc origin \rm & double \\  & \PFAc width \rm & double \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Finds the bin that contains {\PFAp x}, declared either as {\PFAp numbins} between two endpoints or a bin {\PFAp width} starting at some {\PFAp origin}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Bins are inclusive on the low end and exclusive on the high end, so if {\PFAp x} equal {\PFAp low} or {\PFAp origin}, the resulting bin is {\PFAc 0}, but if {\PFAp x} is equal to {\PFAp high}, it is out of range. \vspace{0.1 cm} \\ If the first signature is used, the resulting bin must be between {\PFAc 0} (inclusive) and {\PFAp numbins} (exclusive). If the second signature is used, the resulting bin may be any integer, including negative numbers.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#22000:} If {\PFAp low} is greater or equal to {\PFAp high} or {\PFAp origin} is not finite, raises ``bad histogram range'' \vspace{0.1 cm} \\ {\bf \#22001:} If {\PFAp numbins} is less than {\PFAc 1} or {\PFAp width} is less or equal to {\PFAc 0}, raises ``bad histogram scale'' \vspace{0.1 cm} \\ {\bf \#22002:} Raises ``x out of range'' if {\PFAp x} is less than {\PFAp low} or greater or equal to {\PFAp high}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Nearest point, vector, or abstract type (interp.nearest)}
\hypertarget{interp.nearest}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"interp.nearest":$\!$ [x, table]\} \rm or \PFAc \{"interp.nearest":$\!$ [x, table, metric]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ double, {\PFApf to:}$\!$ any {\PFAtp T}\} \\ & {\it (returns)} & {\PFAtp T} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ array of double, {\PFApf to:}$\!$ any {\PFAtp T}\} \\ & {\it (returns)} & {\PFAtp T} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp X1} \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ any {\PFAtp X2}, {\PFApf to:}$\!$ any {\PFAtp T}\} \\  & \PFAc metric \rm & function ({\PFAtp X1}, {\PFAtp X2}) $\to$ double \\ & {\it (returns)} & {\PFAtp T} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Finds the closest {\PFApf x} value in the {\PFAp table} to the input {\PFAp x} and returns the corresponding {\PFApf to} value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Any ties in distance are resolved in favor of the first instance in the {\PFAp table}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#22010:} Raises a ``table must have at least one entry'' error if {\PFAp table} has fewer than one entry. \vspace{0.1 cm} \\ {\bf \#22011:} Raises an ``inconsistent dimensionality'' error if any input {\PFAp x} and record {\PFApf x} have different numbers of dimensions.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Linear interpolation between two nearest 1-dim points (interp.linear)}
\hypertarget{interp.linear}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"interp.linear":$\!$ [x, table]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ double, {\PFApf to:}$\!$ double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ double, {\PFApf to:}$\!$ array of double\} \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Finds the closest {\PFApf x} values in the {\PFAp table} that are below and above the input {\PFAp x} and linearly projects their {\PFApf to} values to the input {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Any ties in distance are resolved in favor of the first instance in the {\PFAp table}. \vspace{0.1 cm} \\ If the {\PFApf to} values are arrays, each component will be interpolated.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#22020:} Raises a ``table must have at least two distinct x values'' error if fewer than two of the {\PFAp table} {\PFApf x} entries are unique. \vspace{0.1 cm} \\ {\bf \#22021:} Raises an ``inconsistent dimensionality'' error if the {\PFApf to} values of the two closest entries have different numbers of dimensions.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Linear interpolation with flat endpoints (interp.linearFlat)}
\hypertarget{interp.linearFlat}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"interp.linearFlat":$\!$ [x, table]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ double, {\PFApf to:}$\!$ double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ double, {\PFApf to:}$\!$ array of double\} \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Like {\PFAf \hyperlink{interp.linear}{interp.linear}}, but returns the closest entry's {\PFApf to} if the input {\PFAp x} is beyond the {\PFAp table}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Any ties in distance are resolved in favor of the first instance in the {\PFAp table}. \vspace{0.1 cm} \\ If the {\PFApf to} values are arrays, each component will be interpolated.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#22030:} Raises a ``table must have at least two distinct x values'' error if {\PFAp table} has fewer than two entries. \vspace{0.1 cm} \\ {\bf \#22031:} Raises an ``inconsistent dimensionality'' error if the {\PFApf to} values of the two closest entries have different numbers of dimensions.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Linear interpolation with missing values after endpoints (interp.linearMissing)}
\hypertarget{interp.linearMissing}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"interp.linearMissing":$\!$ [x, table]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ double, {\PFApf to:}$\!$ double\} \\ & {\it (returns)} & union of \{null, double\} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ double, {\PFApf to:}$\!$ array of double\} \\ & {\it (returns)} & union of \{null, array of double\} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Like {\PFAf \hyperlink{interp.linear}{interp.linear}}, but returns a missing value ({\PFAc null}) if the input {\PFAp x} is beyond the {\PFAp table}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Any ties in distance are resolved in favor of the first instance in the {\PFAp table}. \vspace{0.1 cm} \\ If the {\PFApf to} values are arrays, each component will be interpolated.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#22040:} Raises a ``table must have at least two distinct x values'' error if {\PFAp table} has fewer than two entries. \vspace{0.1 cm} \\ {\bf \#22041:} Raises an ``inconsistent dimensionality'' error if the {\PFApf to} values of the two closest entries have different numbers of dimensions.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\pagebreak

\section{Probability libraries}

This library contains methods for calculating properties of probability distributions, many of which are used by descriptive statistics and data mining models.

\subsection{Uniform distribution}
\subsubsection{Probability density function (prob.dist.uniformPDF)}
\hypertarget{prob.dist.uniformPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.uniformPDF":$\!$ [x, min, max]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc min \rm & double \\  & \PFAc max \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the uniform distribution parameterized by {\PFAp min} and {\PFAp max}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc min \rm & Lower bound.  \\  & \PFAc max \rm & Upper bound.  \\  & {\it (return value)} \rm & With $min$, $max$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{1}{\mathrm{max} - \mathrm{min}}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13330:} Raises ``invalid parameterization'' if $min \geq max$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13331:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Cumulative distribution function (prob.dist.uniformCDF)}
\hypertarget{prob.dist.uniformCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.uniformCDF":$\!$ [x, min, max]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc min \rm & double \\  & \PFAc max \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the uniform distribution parameterized by {\PFAp min} and {\PFAp max}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc min \rm & Lower bound.  \\  & \PFAc max \rm & Upper bound.  \\  & {\it (return value)} \rm & With $min$, $max$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13340:} Raises ``invalid parameterization'' if $min \geq max$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13341:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Quantile function (prob.dist.uniformQF)}
\hypertarget{prob.dist.uniformQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.uniformQF":$\!$ [p, min, max]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc min \rm & double \\  & \PFAc max \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the uniform distribution parameterized by {\PFAp min} and {\PFAp max}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc min \rm & Lower bound.  \\  & \PFAc max \rm & Upper bound.  \\  & {\it (return value)} \rm & With $min$, $max$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X~\leq~x)~=~p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13350:} Raises ``invalid parameterization'' if $min \geq max$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13351:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Exponential distribution}
\subsubsection{Probability density function (prob.dist.exponentialPDF)}
\hypertarget{prob.dist.exponentialPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.exponentialPDF":$\!$ [x, lambda]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc lambda \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the exponential distribution parameterized by {\PFAp lambda}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc lambda \rm & Rate parameter.  \\  & {\it (return value)} \rm & With $lambda$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\lambda \mathrm{e}^{- \lambda x}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13030:} Raises ``invalid parameterization'' if $lambda < 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13031:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Cumulative distribution function (prob.dist.exponentialCDF)}
\hypertarget{prob.dist.exponentialCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.exponentialCDF":$\!$ [x, lambda]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc lambda \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the exponential distribution parameterized by {\PFAp lambda}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc lambda \rm & Rate parameter.  \\  & {\it (return value)} \rm & With $lambda$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13040:} Raises ``invalid parameterization'' if $lambda < 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13041:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Quantile function (prob.dist.exponentialQF)}
\hypertarget{prob.dist.exponentialQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.exponentialQF":$\!$ [p, lambda]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc lambda \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the exponential distribution parameterized by {\PFAp lambda}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc lambda \rm & Rate parameter.  \\  & {\it (return value)} \rm & With $lambda$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X~\leq~x)~=~p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13050:} Raises ``invalid parameterization'' if $lambda < 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13051:} Raises an ``invalid input'' error if {\PFAp p} is less than zero or greater than one.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Gaussian (normal) distribution}
\subsubsection{Probability density function (prob.dist.gaussianLL)}
\hypertarget{prob.dist.gaussianLL}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"prob.dist.gaussianLL":$\!$ [x, mu, sigma]\} \rm or \PFAc \{"prob.dist.gaussianLL":$\!$ [x, params]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc mu \rm & double \\  & \PFAc sigma \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc params \rm & any record {\PFAtp A} with \{{\PFApf mean:}$\!$ double, {\PFApf variance:}$\!$ double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the log-likelihood of a Gaussian (normal) distribution parameterized by {\PFAp mu} and {\PFAp sigma} or a record {\PFAp params}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the log-likelihood.  \\  & \PFAc mu \rm & Centroid of the distribution (same as {\PFApf mean}).  \\  & \PFAc sigma \rm & Width of the distribution (same as the square root of {\PFApf variance}).  \\  & \PFAc params \rm & Alternate way of specifying the parameters of the distribution; this record could be created by {\PFAf \hyperlink{stat.sample.update}{stat.sample.update}}.  \\  & {\it (return value)} \rm & With $\mu$ = {\PFAp mu} or {\PFApf mean} and $\sigma$ = {\PFAp sigma} or the square root of {\PFApf variance}, this function returns $-(x - \mu)^2/(2 \sigma^2) - \log(\sigma \sqrt{2\pi})$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13000:} Raises an ``invalid parameterization'' error if {\PFAp sigma} or {\PFApf variance} is negative or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13001:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Cumulative distribution function (prob.dist.gaussianCDF)}
\hypertarget{prob.dist.gaussianCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"prob.dist.gaussianCDF":$\!$ [x, mu, sigma]\} \rm or \PFAc \{"prob.dist.gaussianCDF":$\!$ [x, params]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc mu \rm & double \\  & \PFAc sigma \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc params \rm & any record {\PFAtp A} with \{{\PFApf mean:}$\!$ double, {\PFApf variance:}$\!$ double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the cumultive distribution function (CDF) for the normal distribution, parameterized by {\PFAp mu} and {\PFAp sigma} or a record {\PFAp params}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc mu \rm & Centroid of the distribution (same as {\PFApf mean}).  \\  & \PFAc sigma \rm & Width of the distribution (same as the square root of {\PFApf variance}).  \\  & \PFAc params \rm & Alternate way of specifying the parameters of the distribution; this record could be created by {\PFAf \hyperlink{stat.sample.update}{stat.sample.update}}.  \\  & {\it (return value)} \rm & With $\mu$ = {\PFAp mu} or {\PFApf mean} and $\sigma$ = {\PFAp sigma} or the square root of {\PFApf variance}, this function returns $0.5 * ( 1.0 + \mathrm{Erf}(\frac{x - \mu}{\sigma \sqrt{2}}))$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13010:} Raises an ``invalid parameterization'' error if {\PFAp sigma} or {\PFApf variance} is negative or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13011:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Quantile function (prob.dist.gaussianQF)}
\hypertarget{prob.dist.gaussianQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"prob.dist.gaussianQF":$\!$ [p, mu, sigma]\} \rm or \PFAc \{"prob.dist.gaussianQF":$\!$ [p, params]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc mu \rm & double \\  & \PFAc sigma \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc params \rm & any record {\PFAtp A} with \{{\PFApf mean:}$\!$ double, {\PFApf variance:}$\!$ double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the normal quantile (QF, the inverse of the CDF) parameterized by {\PFAp mu} and {\PFAp sigma} or a record {\PFAp params}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Probability at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc mu \rm & Centroid of the distribution (same as {\PFApf mean}).  \\  & \PFAc sigma \rm & Width of the distribution (same as the square root of {\PFApf variance}).  \\  & \PFAc params \rm & Alternate way of specifying the parameters of the distribution; this record could be created by {\PFAf \hyperlink{stat.sample.update}{stat.sample.update}}.  \\  & {\it (return value)} \rm & With $\mu$ = {\PFAp mu} or {\PFApf mean} and $\sigma$ = {\PFAp sigma} or the square root of {\PFApf variance}, this function returns $\mu + \sigma \sqrt{2} \mathrm{Erf}^{-1} (2p - 1)$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13020:} Raises an ``invalid parameterization'' error if {\PFAp sigma} or {\PFApf variance} is negative or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13021:} Raises an ``invalid input'' error if {\PFAp p} is less than zero or greater than one.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Lognormal distribution}
\subsubsection{Probability density function (prob.dist.lognormalPDF)}
\hypertarget{prob.dist.lognormalPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.lognormalPDF":$\!$ [x, meanlog, sdlog]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc meanlog \rm & double \\  & \PFAc sdlog \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the lognormal distribution parameterized by {\PFAp meanlog} and {\PFAp sdlog}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc meanlog \rm & Mean of the distribution on the log scale ($\mu$).  \\  & \PFAc sdlog \rm & Standard deviation of the distribution on the log scale ($\sigma$).  \\  & {\it (return value)} \rm & With $meanlog$, $sdlog$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{1}{\sqrt{2 \pi} \sigma x} \mathrm{e}^{-\frac{\mathrm{log}(x) - \mu}{2 \sigma^{2}}}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13240:} Raises ``invalid parameterization'' if $sdlog \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13241:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Cumulative distribution function (prob.dist.lognormalCDF)}
\hypertarget{prob.dist.lognormalCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.lognormalCDF":$\!$ [x, meanlog, sdlog]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc meanlog \rm & double \\  & \PFAc sdlog \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the lognormal distribution parameterized by {\PFAp meanlog} and {\PFAp sdlog}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc meanlog \rm & Mean of the distribution on the log scale.  \\  & \PFAc sdlog \rm & Standard deviation of the distribution on the log scale.  \\  & {\it (return value)} \rm & With $meanlog$, $sdlog$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13250:} Raises ``invalid parameterization'' if $sdlog \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13251:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Quantile function (prob.dist.lognormalQF)}
\hypertarget{prob.dist.lognormalQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.lognormalQF":$\!$ [p, meanlog, sdlog]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc meanlog \rm & double \\  & \PFAc sdlog \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the lognormal distribution parameterized by {\PFAp meanlog} and {\PFAp sdlog}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc meanlog \rm & Mean of the distribution on the log scale.  \\  & \PFAc sdlog \rm & Standard deviation of the distribution on the log scale.  \\  & {\it (return value)} \rm & With $meanlog$, $sdlog$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X \leq x) = p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13260:} Raises ``invalid parameterization'' if $sdlog \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13261:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Cauchy distribution}
\subsubsection{Probability density function (prob.dist.cauchyPDF)}
\hypertarget{prob.dist.cauchyPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.cauchyPDF":$\!$ [x, location, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc location \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the cauchy distribution parameterized by {\PFAp location} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc location \rm & Location parameter (l).  \\  & \PFAc scale \rm & Scale parameter (s).  \\  & {\it (return value)} \rm & With $location$, $scale$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{1}{(\pi s (1 + (\frac{x - l}{s})^{2})) }$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13180:} Raises ``invalid parameterization'' if $scale \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13181:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Cumulative distribution function (prob.dist.cauchyCDF)}
\hypertarget{prob.dist.cauchyCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.cauchyCDF":$\!$ [x, location, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc location \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the cauchy distribution parameterized by {\PFAp location} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc location \rm & Location parameter.  \\  & \PFAc scale \rm & Scale parameter.  \\  & {\it (return value)} \rm & With $location$, $scale$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13190:} Raises ``invalid parameterization'' if $scale \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13191:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Quantile function (prob.dist.cauchyQF)}
\hypertarget{prob.dist.cauchyQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.cauchyQF":$\!$ [p, location, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc location \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the cauchy distribution parameterized by {\PFAp location} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc location \rm & Location parameter.  \\  & \PFAc scale \rm & Scale parameter.  \\  & {\it (return value)} \rm & With $location$, $scale$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X \leq x) = p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13200:} Raises ``invalid parameterization'' if $scale \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13201:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Binomial distribution}
\subsubsection{Probability density function (prob.dist.binomialPDF)}
\hypertarget{prob.dist.binomialPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.binomialPDF":$\!$ [x, size, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc size \rm & int \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the binomial distribution parameterized by {\PFAp size} and {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc size \rm & The number of trials (n).  \\  & \PFAc prob \rm & The probability of success in each trial (p).  \\  & {\it (return value)} \rm & With $size$, $prob$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\mathrm{choose}(n, x) p^{x} (1 - p)^{n - x}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13300:} Raises ``invalid parameterization'' if $size < 0$ OR if $prob < 0$ OR if $prob > 1$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13301:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Cumulative distribution function (prob.dist.binomialCDF)}
\hypertarget{prob.dist.binomialCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.binomialCDF":$\!$ [x, size, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc size \rm & int \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the binomial distribution parameterized by {\PFAp size} and {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc size \rm & The number of trials.  \\  & \PFAc prob \rm & The probability of success in each trial.  \\  & {\it (return value)} \rm & With $size$, $prob$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13310:} Raises ``invalid parameterization'' if $size < 0$ OR if $prob < 0$ OR if $prob > 1$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13311:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Quantile function (prob.dist.binomialQF)}
\hypertarget{prob.dist.binomialQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.binomialQF":$\!$ [p, size, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc size \rm & int \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the binomial distribution parameterized by {\PFAp size} and {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc size \rm & The number of trials.  \\  & \PFAc prob \rm & The probability of success in each trial.  \\  & {\it (return value)} \rm & With $size$, $prob$ and $p$, this function returns the value $x$ such that $F_{X}(x)~:= P(X~\leq~x)~=~p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13320:} Raises ``invalid parameterization'' if $size < 0$ OR if $prob < 0$ OR if $prob > 1$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13321:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Negative Binomial}
\subsubsection{Probability density function (prob.dist.negativebinomialPDF)}
\hypertarget{prob.dist.negativeBinomialPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.negativeBinomialPDF":$\!$ [x, size, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc size \rm & int \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the negative binomial distribution parameterized by {\PFAp size} and {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF (integer) .  \\  & \PFAc size \rm & Size parameter (integer).  Target number of successful trials (n).  \\  & \PFAc prob \rm & Probability of success in each trial (p).  \\  & {\it (return value)} \rm & With $size$, $prob$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{\Gamma(x+n)}{\Gamma(n) x!} p^{n} (1-p)^{x}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13450:} Raises ``invalid parameterization'' if $\mathrm{prob} < 0$, if $\mathrm{prob} > 1$ or if $size < 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13451:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Cumulative distribution function (prob.dist.negativebinomialCDF)}
\hypertarget{prob.dist.negativeBinomialCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.negativeBinomialCDF":$\!$ [x, size, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc size \rm & int \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the negative binomial distribution parameterized by {\PFAp size} and {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc size \rm & Size parameter (integer).  Target number of successful trials.  \\  & \PFAc prob \rm & Probability of success in each trial.  \\  & {\it (return value)} \rm & With $size$, $prob$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13460:} Raises ``invalid parameterization'' if $\mathrm{prob} < 0$, if $\mathrm{prob} > 1$, or if $size < 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13461:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Quantile function (prob.dist.negativebinomialQF)}
\hypertarget{prob.dist.negativeBinomialQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.negativeBinomialQF":$\!$ [p, size, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc size \rm & int \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the negative binomial distribution parameterized by {\PFAp size} and {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc size \rm & Size parameter (integer).  Target number of successful trials.  \\  & \PFAc prob \rm & Probability of success in each trial.  \\  & {\it (return value)} \rm & With $size$, $prob$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X \leq x) = p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13470:} Raises ``invalid parameterization'' if $\mathrm{prob} < 0$, if $\mathrm{prob} > 1$, or if $size \leq 0$, or if $size$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13471:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Poisson distribution}
\subsubsection{Probability density function (prob.dist.poissonPDF)}
\hypertarget{prob.dist.poissonPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.poissonPDF":$\!$ [x, lambda]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc lambda \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the poisson distribution parameterized by {\PFAp lambda}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc lambda \rm & Mean and variance parameter.  \\  & {\it (return value)} \rm & With $lambda$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{\lambda^{x}}{x!} \mathrm{e}^{-\lambda}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13090:} Raises ``invalid parameterization'' if $lambda < 0$ or any argument is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Cumulative distribution function (prob.dist.poissonCDF)}
\hypertarget{prob.dist.poissonCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.poissonCDF":$\!$ [x, lambda]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc lambda \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the poisson distribution parameterized by {\PFAp lambda}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc lambda \rm & Mean and variance parameter.  \\  & {\it (return value)} \rm & With $lambda$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13100:} Raises ``invalid parameterization'' if $lambda < 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13101:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Quantile function (prob.dist.poissonQF)}
\hypertarget{prob.dist.poissonQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.poissonQF":$\!$ [p, lambda]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc lambda \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the poisson distribution parameterized by {\PFAp lambda}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc lambda \rm & Mean and variance parameter.  \\  & {\it (return value)} \rm & With $lambda$, $lambda$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X \leq x) = p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13110:} Raises ``invalid parameterization'' if $lambda < 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13111:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Student's t distribution}
\subsubsection{Probability density function (prob.dist.tPDF)}
\hypertarget{prob.dist.tPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.tPDF":$\!$ [x, dof]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc dof \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the student's t distribution parameterized by {\PFAp dof} and {\PFAp x2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc dof \rm & Degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $dof$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{\Gamma(\frac{\mathrm{df}+1}{2})}{\sqrt{\mathrm{df}\pi} \Gamma{\frac{\mathrm{df}}{2}}}(1 + x^{\frac{2}{n}})^{-\frac{\mathrm{df} + 1}{2}}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13270:} Raises ``invalid parameterization'' if $df \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13271:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Cumulative distribution function (prob.dist.tCDF)}
\hypertarget{prob.dist.tCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.tCDF":$\!$ [x, dof]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc dof \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the student's t distribution parameterized by {\PFAp dof} and {\PFAp x2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc dof \rm & Degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $dof$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13280:} Raises ``invalid parameterization'' if $df \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13281:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Quantile function (prob.dist.tQF)}
\hypertarget{prob.dist.tQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.tQF":$\!$ [p, dof]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc dof \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the student's t distribution parameterized by {\PFAp dof} and {\PFAp x2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc dof \rm & Degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $dof$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X \leq x) = p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13290:} Raises ``invalid parameterization'' if $df \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13291:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{F distribution}
\subsubsection{Probability density function (prob.dist.fPDF)}
\hypertarget{prob.dist.fPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.fPDF":$\!$ [x, d1, d2]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc d1 \rm & int \\  & \PFAc d2 \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the F distribution parameterized by {\PFAp d1} and {\PFAp d2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc d1 \rm & Numerator degrees of freedom parameter.  \\  & \PFAc d2 \rm & Denominator degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $d1$, $d2$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{\Gamma(\frac{d1 + d2}{2})}{\Gamma(\frac{d1}{2})\Gamma(\frac{d2}{2})} \frac{d1}{d2}^{\frac{d1}{2}-1}(1 + \frac{d1}{d2} x)^{-\frac{d1 + d2}{2}}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13210:} Raises ``invalid parameterization'' if the $d1 \leq 0$ OR if $d2 \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13211:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Cumulative distribution function (prob.dist.fCDF)}
\hypertarget{prob.dist.fCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.fCDF":$\!$ [x, d1, d2]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc d1 \rm & int \\  & \PFAc d2 \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the F distribution parameterized by {\PFAp d1} and {\PFAp d2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc d1 \rm & Numerator degrees of freedom parameter.  \\  & \PFAc d2 \rm & Denominator degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $d1$, $d2$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13220:} Raises ``invalid parameterization'' if the $d1 \leq 0$ OR if $d2 \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13221:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Quantile function (prob.dist.fQF)}
\hypertarget{prob.dist.fQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.fQF":$\!$ [p, d1, d2]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc d1 \rm & int \\  & \PFAc d2 \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the F distribution parameterized by {\PFAp d1} and {\PFAp d2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc d1 \rm & Numerator degrees of freedom parameter.  \\  & \PFAc d2 \rm & Denominator degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $d1$, $d2$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X~\leq~x)~=~p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13230:} Raises ``invalid parameterization'' if the $d1 \leq 0$ OR if $d2 \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13231:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Chi-square distribution}
\subsubsection{Probability density function (prob.dist.chi2PDF)}
\hypertarget{prob.dist.chi2PDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.chi2PDF":$\!$ [x, dof]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc dof \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the Chi-squared distribution parameterized by its degrees of freedom {\PFAp dof}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc dof \rm & Degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $dof$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{1}{2^{\frac{\mathrm{df}}{2}} \Gamma(\frac{\mathrm{df}}{2})} x^{\frac{\mathrm{df}}{2}-1}\mathrm{e}^{-\frac{x}{2}}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13060:} Raises ``invalid parameterization'' if {\PFAp dof} < 0 or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13061:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Cumulative distribution function (prob.dist.chi2CDF)}
\hypertarget{prob.dist.chi2CDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.chi2CDF":$\!$ [x, dof]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc dof \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the Chi-squared distribution parameterized by its degrees of freedom {\PFAp dof}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc dof \rm & Degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $x1$, $x1$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13070:} Raises ``invalid parameterization'' if {\PFAp dof} < 0 or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13071:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Quantile function (prob.dist.chi2QF)}
\hypertarget{prob.dist.chi2QF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.chi2QF":$\!$ [p, dof]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc dof \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the Chi-squared distribution parameterized by its degrees of freedom {\PFAp dof}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc dof \rm & Degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $x1$, $x1$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X \leq x) = p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13080:} Raises ``invalid parameterization'' if {\PFAp dof} < 0 or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13081:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Beta distribution}
\subsubsection{Probability density function (prob.dist.betaPDF)}
\hypertarget{prob.dist.betaPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.betaPDF":$\!$ [x, a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc a \rm & double \\  & \PFAc b \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the beta distribution parameterized by {\PFAp shape1} and {\PFAp shape2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF, defined between zero and one.  \\  & \PFAc a \rm & First shape parameter.  \\  & \PFAc b \rm & Second shape parameter.  \\  & {\it (return value)} \rm & With $a$, $b$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{\Gamma(a + n)}{\Gamma(a)\Gamma(b)} x^{a-1}(1-x)^{b-1}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13150:} Raises ``invalid parameterization'' if $a \leq 0$ OR if $b \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13151:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Cumulative distribution function (prob.dist.betaCDF)}
\hypertarget{prob.dist.betaCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.betaCDF":$\!$ [x, a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc a \rm & double \\  & \PFAc b \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the beta distribution parameterized by {\PFAp shape1} and {\PFAp shape2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc a \rm & First shape parameter.  \\  & \PFAc b \rm & Second shape parameter.  \\  & {\it (return value)} \rm & With $a$, $b$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13160:} Raises ``invalid parameterization'' if $a \leq 0$ OR if $b \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13161:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Quantile function (prob.dist.betaQF)}
\hypertarget{prob.dist.betaQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.betaQF":$\!$ [p, a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc a \rm & double \\  & \PFAc b \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the beta distribution parameterized by {\PFAp shape1} and {\PFAp shape2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc a \rm & First shape parameter.  \\  & \PFAc b \rm & Second shape parameter.  \\  & {\it (return value)} \rm & With $a$, $b$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X \leq x) = p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13170:} Raises ``invalid parameterization'' if the $a \leq 0$ OR if $b \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13171:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Gamma distribution}
\subsubsection{Probability density function (prob.dist.gammaPDF)}
\hypertarget{prob.dist.gammaPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.gammaPDF":$\!$ [x, shape, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc shape \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the gamma distribution parameterized by {\PFAp shape} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc shape \rm & Shape parameter (a).  \\  & \PFAc scale \rm & Scale parameter (s).  \\  & {\it (return value)} \rm & With $shape$, $scale$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{1}{s^{a} \Gamma(a)} x^{a - 1} \mathrm{e}^{-\frac{x}{s}}  $. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13120:} Raises ``invalid parameterization'' if the $shape < 0$ OR if $scale < 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13121:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Cumulative distribution function (prob.dist.gammaCDF)}
\hypertarget{prob.dist.gammaCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.gammaCDF":$\!$ [x, shape, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc shape \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the gamma distribution parameterized by {\PFAp shape} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc shape \rm & Shape parameter.  \\  & \PFAc scale \rm & Scale parameter.  \\  & {\it (return value)} \rm & With $shape$, $scale$ and $x$, this function returns the value $p$ where $p = F_{X}(x)~= P(X~\leq~x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13130:} Raises ``invalid parameterization'' if the $shape < 0$ OR if $scale < 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13131:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Quantile function (prob.dist.gammaQF)}
\hypertarget{prob.dist.gammaQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.gammaQF":$\!$ [p, shape, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc shape \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the gamma distribution parameterized by {\PFAp shape} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc shape \rm & Shape parameter.  \\  & \PFAc scale \rm & Scale parameter.  \\  & {\it (return value)} \rm & With $shape$, $scale$ and $p$, this function returns the value $x$ such that $F_{X}(x)~:= P(X~\leq~x)~=~p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13140:} Raises ``invalid parameterization'' if the $shape \leq 0$ OR if $scale \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13141:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Geometric distribution}
\subsubsection{Probability density function (prob.dist.geometricPDF)}
\hypertarget{prob.dist.geometricPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.geometricPDF":$\!$ [x, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the geometric distribution parameterized by {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc prob \rm & Probability of success of each trial (p).  \\  & {\it (return value)} \rm & With $prob$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $p (1 - p)^{x}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13360:} Raises ``invalid parameterization'' if $\mathrm{prob} \leq 0$ OR if $\mathrm{prob} > 1$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13361:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Cumulative distribution function (prob.dist.geometricCDF)}
\hypertarget{prob.dist.geometricCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.geometricCDF":$\!$ [x, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the geometric distribution parameterized by {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc prob \rm & Probability of success of each trial.  \\  & {\it (return value)} \rm & With $prob$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13370:} Raises ``invalid parameterization'' if $\mathrm{prob} \leq 0$ OR if $\mathrm{prob} > 1$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13371:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Quantile function (prob.dist.geometricQF)}
\hypertarget{prob.dist.geometricQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.geometricQF":$\!$ [p, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the geometric distribution parameterized by {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc prob \rm & Probability of success of each trial.  \\  & {\it (return value)} \rm & With $prob$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X \leq x) = p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13380:} Raises ``invalid parameterization'' if $\mathrm{prob} \leq 0$ OR if $\mathrm{prob} > 1$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13381:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Hypergeometric distribution}
\subsubsection{Probability density function (prob.dist.hypergeometricPDF)}
\hypertarget{prob.dist.hypergeometricPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.hypergeometricPDF":$\!$ [x, m, n, k]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc m \rm & int \\  & \PFAc n \rm & int \\  & \PFAc k \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the hypergeometric distribution parameterized by {\PFAp m}, {\PFAp n} and {\PFAp k}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & The number of white balls drawn without replacement from the urn.  \\  & \PFAc m \rm & The number of white balls in the urn.  \\  & \PFAc n \rm & The number of black balls in the urn.  \\  & \PFAc k \rm & The number of balls drawn from the urn.  \\  & {\it (return value)} \rm & With $m$, $n$ and $k$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{\mathrm{choose}(m, x) \mathrm{choose}(n, k-x)}{\mathrm{choose}(m+n, k)} $.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13390:} Raises ``invalid parameterization'' if $\mathrm{m} + \mathrm{n} < \mathrm{k}$, $m < 0$, $n < 0$, $m + n = 0$, or $k < 0$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Cumulative distribution function (prob.dist.hypergeometricCDF)}
\hypertarget{prob.dist.hypergeometricCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.hypergeometricCDF":$\!$ [x, m, n, k]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc m \rm & int \\  & \PFAc n \rm & int \\  & \PFAc k \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the hypergeometric distribution parameterized by {\PFAp m}, {\PFAp n} and {\PFAp k}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & The number of white balls drawn without replacement.  \\  & \PFAc m \rm & The number of white balls in the urn.  \\  & \PFAc n \rm & The number of black balls in the urn.  \\  & \PFAc k \rm & The number of balls drawn from the urn.  \\  & {\it (return value)} \rm & With $m$, $n$ and $k$ at $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13400:} Raises ``invalid parameterization'' if $\mathrm{m} + \mathrm{n} < \mathrm{k}$, $m < 0$, $n < 0$, $m + n = 0$, or $k < 0$. \vspace{0.1 cm} \\ {\bf \#13401:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Quantile function (prob.dist.hypergeometricQF)}
\hypertarget{prob.dist.hypergeometricQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.hypergeometricQF":$\!$ [p, m, n, k]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc m \rm & int \\  & \PFAc n \rm & int \\  & \PFAc k \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the hypergeometric distribution parameterized by {\PFAp m}, {\PFAp n} and {\PFAp k}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc m \rm & The number of white balls in the urn.  \\  & \PFAc n \rm & The number of black balls in the urn.  \\  & \PFAc k \rm & The number of balls drawn from the urn.  \\  & {\it (return value)} \rm & With $m$, $n$ and $k$ at $p$, this function returns the value $x$ such that $F_{X}(x)~:= P(X~\leq~x)~=~p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13410:} Raises ``invalid parameterization'' if $\mathrm{m} + \mathrm{n} < \mathrm{k}$, $m < 0$, $n < 0$, $m + n = 0$, or $k < 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13411:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Weibull distribution}
\subsubsection{Probability density function (prob.dist.weibullPDF)}
\hypertarget{prob.dist.weibullPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.weibullPDF":$\!$ [x, shape, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc shape \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the weibull distribution parameterized by {\PFAp shape} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc shape \rm & Shape parameter (a).  \\  & \PFAc scale \rm & Scale parameter (b).  \\  & {\it (return value)} \rm & With $shape$, $scale$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{a}{b}(\frac{x}{b})^{a - 1}\mathrm{e}^{-(\frac{x}{b})^{a}}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13420:} Raises ``invalid parameterization'' if the $shape \leq 0$ OR if $scale \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13421:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Cumulative distribution function (prob.dist.weibullCDF)}
\hypertarget{prob.dist.weibullCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.weibullCDF":$\!$ [x, shape, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc shape \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the weibull distribution parameterized by {\PFAp shape} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc shape \rm & Shape parameter.  \\  & \PFAc scale \rm & Scale parameter.  \\  & {\it (return value)} \rm & With $shape$, $scale$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X~\leq~x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13430:} Raises ``invalid parameterization'' if the $shape \leq 0$ OR if $scale \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13431:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }
\subsubsection{Quantile function (prob.dist.weibullQF)}
\hypertarget{prob.dist.weibullQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.weibullQF":$\!$ [p, shape, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc shape \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the weibull distribution parameterized by {\PFAp shape} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc shape \rm & Shape parameter.  \\  & \PFAc scale \rm & Scale parameter.  \\  & {\it (return value)} \rm & With $shape$, $scale$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X~\leq~x)~=~p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13440:} Raises ``invalid parameterization'' if the $shape \leq 0$ OR if $scale \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13441:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\pagebreak

\section{Descriptive statistics libraries}

This library contains methods for characterizing a dataset empirically.  These are generally more lightweight than data mining models.

\subsection{Statistical tests}

\subsubsection{Kolmogorov-Smirnov test of two distributions (stat.test.kolmogorov)}
\hypertarget{stat.test.kolmogorov}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.test.kolmogorov":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc y \rm & array of double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compare two datasets using the Kolmogorov-Smirnov test to determine if they might have been drawn from the same parent distribution. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & A bag of data.  \\  & \PFAc y \rm & Another bag of data.  \\  & {\it (return value)} \rm & Returns a value between 0.0 and 1.0 representing the cumulative probability that {\PFAp x} and {\PFAp y} were drawn from the same distribution: 1.0 indicates a perfect match. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If both datasets (ignoring NaN values) are empty, this function returns 1.0\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Compute residual of a fit (stat.test.residual)}
\hypertarget{stat.test.residual}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"stat.test.residual":$\!$ [observation, prediciton]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & double \\  & \PFAc prediciton \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & array of double \\  & \PFAc prediciton \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & map of double \\  & \PFAc prediciton \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compare an observation with its prediction by element-wise subtraction. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc observation \rm & Scalar or vector of observations.  \\  & \PFAc prediction \rm & Scalar or vector of predictions.  \\  & {\it (return value)} \rm & Scalar or vector of {\PFAp observation} minus {\PFAp prediction}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#38010:} Raises a ``misaligned prediction'' error if {\PFAp prediction} does not have the same indexes or keys as {\PFAp observation}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Compute the pull of a fit (stat.test.pull)}
\hypertarget{stat.test.pull}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"stat.test.pull":$\!$ [observation, prediciton, uncertainty]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & double \\  & \PFAc prediciton \rm & double \\  & \PFAc uncertainty \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & array of double \\  & \PFAc prediciton \rm & array of double \\  & \PFAc uncertainty \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & map of double \\  & \PFAc prediciton \rm & map of double \\  & \PFAc uncertainty \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compare an observation with its prediction by element-wise subtraction, weighted by element-wise uncertainties. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc observation \rm & Scalar or vector of observations.  \\  & \PFAc prediction \rm & Scalar or vector of predictions.  \\  & \PFAc uncertainty \rm & Scalar or vector of predictions.  \\  & {\it (return value)} \rm & Scalar or vector of {\PFAp observation} minus {\PFAp prediction} divided by {\PFAp uncertainty}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#38020:} Raises a ``misaligned prediction'' error if {\PFAp prediction} does not have the same indexes or keys as {\PFAp observation}. \vspace{0.1 cm} \\ {\bf \#38021:} Raises a ``misaligned uncertainty'' error if {\PFAp prediction} does not have the same indexes or keys as {\PFAp uncertainty}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Compute the Mahalanobis of a fit (stat.test.mahalanobis)}
\hypertarget{stat.test.mahalanobis}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"stat.test.mahalanobis":$\!$ [observation, prediction, covariance]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & array of double \\  & \PFAc prediction \rm & array of double \\  & \PFAc covariance \rm & array of array of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & map of double \\  & \PFAc prediction \rm & map of double \\  & \PFAc covariance \rm & map of map of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compare an observation with its prediction by computing the Mahalanobis distance for a given covariance matrix. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc observation \rm & Vector of observations $\vec{o}$.  \\  & \PFAc prediction \rm & Vector of predictions $\vec{p}$.  \\  & \PFAc covariance \rm & Matrix of covariance $C$.  \\  & {\it (return value)} \rm & Scalar result of a similarity transformation: $\sqrt{(\vec{o} - \vec{p})^T C^{-1} (\vec{o} - \vec{p})}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#38030:} Raises a ``too few rows/cols'' error if {\PFAp observation} has fewer than one element. \vspace{0.1 cm} \\ {\bf \#38031:} Raises a ``misaligned prediction'' error if {\PFAp prediction} does not have the same indexes or keys as {\PFAp observation}. \vspace{0.1 cm} \\ {\bf \#38032:} Raises a ``misaligned covariance'' error if {\PFAp covariance} does not have the same indexes or keys as {\PFAp observation}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Update a cumulative $\chi^2$ calculation (stat.test.updateChi2)}
\hypertarget{stat.test.updateChi2}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"stat.test.updateChi2":$\!$ [pull, state]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pull \rm & double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf chi2:}$\!$ double, {\PFApf dof:}$\!$ int\} \\ & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pull \rm & array of double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf chi2:}$\!$ double, {\PFApf dof:}$\!$ int\} \\ & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pull \rm & map of double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf chi2:}$\!$ double, {\PFApf dof:}$\!$ int\} \\ & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update the state of a chi-square calculation. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc pull \rm & Observation minus prediction divided by uncertainty.  If this is a scalar, it will be squared and added to the chi-square.  If a vector, each component will be squared and added to the chi-square.  \\  & \PFAc state \rm & Record of the previous {\PFApf chi2} and {\PFApf dof}.  \\ \end{tabular} \vspace{0.2 cm} \\ }

\subsubsection{Compute the reduced $\chi^2$ (stat.test.reducedChi2)}
\hypertarget{stat.test.reducedChi2}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.test.reducedChi2":$\!$ [state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf chi2:}$\!$ double, {\PFApf dof:}$\!$ int\} \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the reduced chi-square, which is {\PFApf chi2}/{\PFApf dof}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc state \rm & Record of the {\PFApf chi2} and {\PFApf dof}.  \\ \end{tabular} \vspace{0.2 cm} \\ }

\subsubsection{Compute the $\chi^2$ probability (stat.test.chi2Prob)}
\hypertarget{stat.test.chi2Prob}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.test.chi2Prob":$\!$ [state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf chi2:}$\!$ double, {\PFApf dof:}$\!$ int\} \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the chi-square probability, which is the CDF of the chi-square function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc state \rm & Record of the {\PFApf chi2} and {\PFApf dof}.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#38060:} Raises ``invalid parameterization'' if {\PFApf dof} is less than zero.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Sample statistics}

\subsubsection{Incremental count, mean, and/or variance (stat.sample.update)}
\hypertarget{stat.sample.update}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.update":$\!$ [x, w, state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc w \rm & double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf count:}$\!$ double\} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update the state of a counter, a counter and a mean, or a counter, mean, and variance. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample value.  \\  & \PFAc w \rm & Sample weight; set to 1 for no weights.  \\  & \PFAc state \rm & Record of the previous {\PFApf count}, {\PFApf mean}, and/or {\PFApf variance}.                                           \begin{description*}\item[\PFAc count:] The sum of weights {\PFAp w}. \item[\PFAc mean:] The mean of {\PFAp x}, weighted by {\PFAp w}.  This field is optional, but if provided, it must be a {\PFAc double}. \item[\PFAc variance:] The variance of $x - \mbox{mean}$, weighted by {\PFAp w}.  This field is optional, but if it is provided, it must be a {\PFAc double}, and there must be a {\PFApf mean} as well.  No attempt is made to unbias the estimator, so multiply this by $\mbox{count}/(\mbox{count} - 1)$ to correct for the bias due to centering on the mean. \end{description*} \\  & {\it (return value)} \rm & Returns an updated version of {\PFAp state} with {\PFApf count} incremented by {\PFAp w}, {\PFApf mean} updated to the current mean of all {\PFAp x}, and {\PFApf variance} updated to the current variance of all {\PFAp x}.  If the {\PFAp state} has fields other than {\PFApf count}, {\PFApf mean}, and {\PFApf variance}, they are copied unaltered to the output state. \\ \end{tabular} \vspace{0.2 cm} \\ }

\subsubsection{Incremental covariance matrix (stat.sample.updateCovariance)}
\hypertarget{stat.sample.updateCovariance}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"stat.sample.updateCovariance":$\!$ [x, w, state]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc w \rm & double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf count:}$\!$ double, {\PFApf mean:}$\!$ array of double, {\PFApf covariance:}$\!$ array of array of double\} \\ & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\  & \PFAc w \rm & double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf count:}$\!$ map of map of double, {\PFApf mean:}$\!$ map of double, {\PFApf covariance:}$\!$ map of map of double\} \\ & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update the state of a covariance calculation. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample vector, expressed as an array or map; must have at least two components.  \\  & \PFAc w \rm & Sample weight; set to 1 for no weights.  \\  & \PFAc state \rm & Record of the previous {\PFApf count}, {\PFApf mean}, and {\PFApf covariance}.                                           \begin{description*}\item[\PFAc count:] The sum of weights {\PFAp w}.  If {\PFAp x} is an array, then {\PFApf count} is a single value representing the sum of weights for all records seen so far.  If {\PFAp x} is a map, then {\PFApf count} is a matrix in which entry $i$, $j$ is the sum of weights for records in which key $i$ and key $j$ both appear in {\PFAp x}. \item[\PFAc mean:] The componentwise mean of {\PFAp x}, weighted by {\PFAp w}. \item[\PFAc covariance:] The covariance matrix of all pairs of components of {\PFAp x}, weighted by {\PFAp w}.  If {\PFAp x} is an array, this matrix is represented by a list of lists.  If {\PFAp x} is a map, this matrix is represented by a map of maps. \end{description*} \\  & {\it (return value)} \rm & Returns an updated version of {\PFAp state} with {\PFApf count} incremented by {\PFAp w}, {\PFApf mean} updated to the current componentwise mean of all {\PFAp x}, and {\PFApf covariance} updated to the current covariance matrix of all {\PFAp x}.  If the {\PFAp state} has fields other than {\PFApf count}, {\PFApf mean}, and {\PFApf covariance}, they are copied unaltered to the output state. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Like most functions that deal with matrices, this function has an array signature and a map signature.  In the array signature, indexes of {\PFAp x} correspond to the same indexes of {\PFApf mean} and rows and columns of {\PFApf covariance}, where a row is an index of {\PFApf covariance} and a column is an index of an element of {\PFApf covariance}.  In the map signature, keys of {\PFAp x} correspond to the same keys of {\PFApf mean}, as well as rows and columns of {\PFApf count} and {\PFApf covariance}, where a row is a key of the object and a column is a key of a value of the object.  In the array signature, all arrays must have equal length (including the nested arrays within {\PFApf covariance}) and all components are updated with each call.  In the map signature, a previously unseen key in {\PFAp x} creates a new key in {\PFApf mean} with value {\PFAp x}, a new row and column in {\PFApf count} with value {\PFAp w} for all key pairs existing in {\PFAp x} and zero for key pairs not in {\PFAp x}, as well as a new row and column in {\PFApf covariance} filled with zeros. \vspace{0.1 cm} \\ In the map signature, missing keys in {\PFAp x} are equivalent to contributions with zero weight.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#14011:} If {\PFAp x} has fewer than 2 components, a ``too few components'' error is raised. \vspace{0.1 cm} \\ {\bf \#14012:} If {\PFAp x}, {\PFApf mean}, and {\PFApf covariance} are arrays with unequal lengths, an ``unequal length arrays'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Incremental count, mean, and/or variance in a window (stat.sample.updateWindow)}
\hypertarget{stat.sample.updateWindow}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.updateWindow":$\!$ [x, w, state, windowSize]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc w \rm & double \\  & \PFAc state \rm & array of any record {\PFAtp A} with \{{\PFApf x:}$\!$ double, {\PFApf w:}$\!$ double, {\PFApf count:}$\!$ double\} \\  & \PFAc windowSize \rm & int \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update the state of a counter, a counter and a mean, or a counter, mean, and variance, within a window of {\PFAp windowSize} recent samples. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample value.  \\  & \PFAc w \rm & Sample weight; set to 1 for no weights.  \\  & \PFAc state \rm & Array of previous {\PFApf count}, {\PFApf mean}, and/or {\PFApf variance} and samples in the window.                                                                 \begin{description*}\item[\PFAc x:] Sample value, saved so that it can be removed from the running mean and variance when it goes out of scope. \item[\PFAc w:] Sample weight, saved for the same reason. \item[\PFAc count:] The sum of weights {\PFAp w} within the window. \item[\PFAc mean:] The mean of {\PFAp x} within the window, weighted by {\PFAp w}.  This field is optional, but if provided, it must be a {\PFAc double}. \item[\PFAc variance:] The variance of $x - \mbox{mean}$ within the window, weighted by {\PFAp w}.  This field is optional, but if it is provided, it must be a {\PFAc double}, and there must be a {\PFApf mean} as well.  No attempt is made to unbias the estimator, so multiply this by $\mbox{count}/(\mbox{count} - 1)$ to correct for the bias due to centering on the mean. \end{description*} \\  & \PFAc windowSize \rm & Size of the window.  When the length of {\PFAp state} is less than {\PFAp windowSize}, this function is equivalent to {\PFAf \hyperlink{stat.sample.update}{stat.sample.update}}.  \\  & {\it (return value)} \rm & If the length of {\PFAp state} is zero, this function returns a singleton array with {\PFApf count} = {\PFAp w}, {\PFApf mean} = {\PFAp x}, and/or {\PFApf variance} = 0.  If the length of {\PFAp state} is less than {\PFAp windowSize}, then it returns a copy of {\PFAp state} with the next record added.  Otherwise, it is trunctated to {\PFAp windowSize}, removing the old values from the running count/mean/variance.  In all cases, the {\PFAf \hyperlink{a.last}{a.last}} item is the latest result. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#14020:} If {\PFAp windowSize} is less than 2, a ``windowSize must be at least 2'' error is raised. \vspace{0.1 cm} \\ {\bf \#14021:} If {\PFAp state} is empty and the record type has fields other than {\PFApf x}, {\PFApf w}, {\PFApf count}, {\PFApf mean}, and {\PFApf variance}, then a ``cannot initialize unrecognized fields'' error is raised.  Unrecognized fields are only allowed if an initial record is provided.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Exponentially weighted moving average (EWMA) (stat.sample.updateEWMA)}
\hypertarget{stat.sample.updateEWMA}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.updateEWMA":$\!$ [x, alpha, state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc alpha \rm & double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf mean:}$\!$ double\} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update the state of an exponentially weighted moving average (EWMA). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample value.  \\  & \PFAc alpha \rm & Weighting factor (usually a constant) between 0 and 1, inclusive.  If {\PFAp alpha} is close to 1, recent data are heavily weighted at the expense of old data; if {\PFAp alpha} is close to 0, the EWMA approaches a simple mean.  \\  & \PFAc state \rm & Record of the previous {\PFApf mean} and {\PFApf variance}.                                \begin{description*}\item[\PFAc mean:] The exponentially weighted mean of {\PFAp x}, weighted by {\PFAp alpha}. \item[\PFAc variance:] The exponentially weighted variance of {\PFAp x}, weighted by {\PFAp alpha}.  This field is optional, but if provided, it must be a {\PFAc double}. \end{description*} \\  & {\it (return value)} \rm & Returns a new record with updated {\PFApf mean} and {\PFApf variance}.  If the input {\PFAp state} has fields other than {\PFApf mean} and {\PFApf variance}, they are copied unaltered to the output state. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#14030:} If {\PFAp alpha} is less than 0 or greater than 1, an ``alpha out of range'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Doubly exponential average with trend (stat.sample.updateHoltWinters)}
\hypertarget{stat.sample.updateHoltWinters}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.updateHoltWinters":$\!$ [x, alpha, beta, state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc alpha \rm & double \\  & \PFAc beta \rm & double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf level:}$\!$ double, {\PFApf trend:}$\!$ double\} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update the state of a time series analysis with an exponentially weighted linear fit. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample value.  \\  & \PFAc alpha \rm & Weighting factor (usually a constant) between 0 and 1, inclusive, that governs the responsiveness of the {\PFApf level}.  If {\PFAp alpha} is close to 1, recent data are heavily weighted at the expense of old data.  \\  & \PFAc beta \rm & Weighting factor (usually a constant) between 0 and 1, inclusive, that governs the responsiveness of the {\PFApf trend}.  If {\PFAp beta} is close to 1, recent data are heavily weighted at the expense of old data.  \\  & \PFAc state \rm & Record of the previous {\PFApf level} and {\PFApf trend}.                                \begin{description*}\item[\PFAc level:] The constant term in an exponentially weighted linear fit of recent data, weighted by {\PFAp alpha}. \item[\PFAc trend:] The linear term in an exponentially weighted linear fit of recent data, weighted by {\PFAp beta}. \end{description*} \\  & {\it (return value)} \rm & Returns an updated version of the {\PFAp state}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Use {\PFAf \hyperlink{stat.sample.forecast1HoltWinters}{stat.sample.forecast1HoltWinters}} or {\PFAf \hyperlink{stat.sample.forecastHoltWinters}{stat.sample.forecastHoltWinters}} to make predictions from the state record. \vspace{0.1 cm} \\ For $a_t$ = the {\PFApf level} at a time $t$ and $b_t$ = the {\PFApf trend} at a time $t$, $a_t = \alpha x + (1 - \alpha)(a_{t-1} + b_{t-1})$ and $b_t = \beta (a_t - a_{t-1}) + (1 - \beta) b_{t-1}$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#14040:} If {\PFAp alpha} is less than 0 or greater than 1, an ``alpha out of range'' error is raised. \vspace{0.1 cm} \\ {\bf \#14041:} If {\PFAp beta} is less than 0 or greater than 1, an ``beta out of range'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Triply exponential average: trend and period (stat.sample.updateHoltWintersPeriodic)}
\hypertarget{stat.sample.updateHoltWintersPeriodic}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.updateHoltWintersPeriodic":$\!$ [x, alpha, beta, gamma, state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc alpha \rm & double \\  & \PFAc beta \rm & double \\  & \PFAc gamma \rm & double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf level:}$\!$ double, {\PFApf trend:}$\!$ double, {\PFApf cycle:}$\!$ array of double, {\PFApf multiplicative:}$\!$ boolean\} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update the state of a time series analysis with an exponentially weighted periodic-plus-linear fit. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample value.  \\  & \PFAc alpha \rm & Weighting factor (usually a constant) between 0 and 1, inclusive, that governs the responsiveness of the {\PFApf level}.  If {\PFAp alpha} is close to 1, recent data are heavily weighted at the expense of old data.  \\  & \PFAc beta \rm & Weighting factor (usually a constant) between 0 and 1, inclusive, that governs the responsiveness of the {\PFApf trend}.  If {\PFAp beta} is close to 1, recent data are heavily weighted at the expense of old data.  \\  & \PFAc gamma \rm & Weighting factor (usually a constant) between 0 and 1, inclusive, that governs the responsiveness of the {\PFApf cycle}.  If {\PFAp gamma} is close to 1, recent data are heavily weighted at the expense of old data.  \\  & \PFAc state \rm & Record of the previous {\PFApf level}, {\PFApf trend}, and {\PFApf cycle}.                                                      \begin{description*}\item[\PFAc level:] The constant term in an exponentially weighted linear fit of recent data, weighted by {\PFAp alpha}. \item[\PFAc trend:] The linear term in an exponentially weighted linear fit of recent data, weighted by {\PFAp beta}. \item[\PFAc cycle:] The history of the previous cycle, weighted by {\PFAp gamma}.  If the length of this array is $L$, then the built-in period is $L$ time steps long. \item[\PFAc multiplicative:] If {\PFAc true}, interpret {\PFApf cycle} as multiplicative; if {\PFAc false}, interpret it as additive. \end{description*} \\  & {\it (return value)} \rm & Returns an updated version of the {\PFAp state}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Use {\PFAf \hyperlink{stat.sample.forecast1HoltWinters}{stat.sample.forecast1HoltWinters}} or {\PFAf \hyperlink{stat.sample.forecastHoltWinters}{stat.sample.forecastHoltWinters}} to make predictions from the state record. \vspace{0.1 cm} \\ For $a_t$ = the {\PFApf level} at a time $t$, $b_t$ = the {\PFApf trend} at a time $t$, and $c_t$ = the {\PFApf cycle} at a time $t$ with period $L$, $a_t = \alpha x_t / c_{t-L} + (1 - \alpha)(a_{t-1} + b_{t-1})$, $b_t = \beta (a_t - a_{t-1}) + (1 - \beta) b_{t-1}$, and $c_t = \gamma x_t / a_t + (1 - \gamma) c_{t-L}$ for the multiplicative case and $a_t = \alpha (x_t - c_{t-L}) + (1 - \alpha)(a_{t-1} + b_{t-1})$, $b_t = \beta (a_t - a_{t-1}) + (1 - \beta) b_{t-1}$, and $c_t = \gamma (x_t - a_t) + (1 - \gamma) c_{t-L}$ for the additive case. \vspace{0.1 cm} \\ In each call to this function, {\PFApf cycle} is rotated left, such that the first item is $c_t$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#14050:} If {\PFAp alpha} is less than 0 or greater than 1, an ``alpha out of range'' error is raised. \vspace{0.1 cm} \\ {\bf \#14051:} If {\PFAp beta} is less than 0 or greater than 1, an ``beta out of range'' error is raised. \vspace{0.1 cm} \\ {\bf \#14052:} If {\PFAp gamma} is less than 0 or greater than 1, an ``gamma out of range'' error is raised. \vspace{0.1 cm} \\ {\bf \#14053:} If {\PFApf cycle} is empty, an ``empty cycle'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Make one forecast from a Holt-Winters state (stat.sample.forecast1HoltWinters)}
\hypertarget{stat.sample.forecast1HoltWinters}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.forecast1HoltWinters":$\!$ [state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf level:}$\!$ double, {\PFApf trend:}$\!$ double\} \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Forecast one time-step from a state record prepared by {\PFAf \hyperlink{stat.state.updateHoltWinters}{stat.state.updateHoltWinters}} or {\PFAf \hyperlink{stat.state.updateHoltWintersPeriodic}{stat.state.updateHoltWintersPeriodic}}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc state \rm & Record of {\PFApf level}, {\PFApf trend}, and possibly {\PFApf cycle} and {\PFApf multiplicative}.                                                      \begin{description*}\item[\PFAc level:] The constant term in an exponentially weighted linear fit of recent data. \item[\PFAc trend:] The linear term in an exponentially weighted linear fit of recent data. \item[\PFAc cycle:] The history of the previous cycle.  This field is optional, but if provided, it must be an array of {\PFAc double} and must be accompanied by {\PFApf multiplicative}. \item[\PFAc multiplicative:] If {\PFAc true}, interpret {\PFApf cycle} as multiplicative; if {\PFAc false}, interpret it as additive.  This field is optional, but if provided, it must be a {\PFAc boolean} and must be accompanied by {\PFApf cycle}. \end{description*} \\  & {\it (return value)} \rm & Returns a prediction of the next time-step. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}For $a_t$ = the {\PFApf level} at a time $t$, $b_t$ = the {\PFApf trend} at a time $t$, and $c_t$ = the {\PFApf cycle} at a time $t$ with period $L$, this function returns $a_t + b_t$ (non-periodic), $(a_t + b_t) c_{t+1}$ (multiplicative), or $a_t + b_t + c_{t+1}$ (additive) for each $i$ from $0$ to $n - 1$\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#14060:} If {\PFApf cycle} is empty, an ``empty cycle'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Make many forecasts from a Holt-Winters state (stat.sample.forecastHoltWinters)}
\hypertarget{stat.sample.forecastHoltWinters}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.forecastHoltWinters":$\!$ [n, state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc n \rm & int \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf level:}$\!$ double, {\PFApf trend:}$\!$ double\} \\  & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Forecast {\PFAp n} time-steps from a state record prepared by {\PFAf \hyperlink{stat.state.updateHoltWinters}{stat.state.updateHoltWinters}} or {\PFAf \hyperlink{stat.state.updateHoltWintersPeriodic}{stat.state.updateHoltWintersPeriodic}}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc state \rm & Record of {\PFApf level}, {\PFApf trend}, and possibly {\PFApf cycle} and {\PFApf multiplicative}.                                                      \begin{description*}\item[\PFAc level:] The constant term in an exponentially weighted linear fit of recent data. \item[\PFAc trend:] The linear term in an exponentially weighted linear fit of recent data. \item[\PFAc cycle:] The history of the previous cycle.  This field is optional, but if provided, it must be a {\PFAc double} and must be accompanied by {\PFApf multiplicative}. \item[\PFAc multiplicative:] If {\PFAc true}, interpret {\PFApf cycle} as multiplicative; if {\PFAc false}, interpret it as additive.  This field is optional, but if provided, it must be a {\PFAc boolean} and must be accompanied by {\PFApf cycle}. \end{description*} \\  & {\it (return value)} \rm & Returns a series of predictions for the next {\PFAp n} time-steps. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}For $a_t$ = the {\PFApf level} at a time $t$, $b_t$ = the {\PFApf trend} at a time $t$, and $c_t$ = the {\PFApf cycle} at a time $t$ with period $L$, this function returns $a_t + i b_t$ (non-periodic), $(a_t + i b_t) c_{(t + i) \mbox{mod} n}$ (multiplicative), or $a_t + i b_t + c_{(t + i) \mbox{mod} n}$ (additive) for each $i$ from $1$ to $n$\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#14070:} If {\PFApf cycle} is empty, an ``empty cycle'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Fill a histogram (stat.sample.fillHistogram)}
\hypertarget{stat.sample.fillHistogram}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"stat.sample.fillHistogram":$\!$ [x, w, histogram]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc w \rm & double \\  & \PFAc histogram \rm & any record {\PFAtp A} with \{{\PFApf numbins:}$\!$ int, {\PFApf low:}$\!$ double, {\PFApf high:}$\!$ double, {\PFApf values:}$\!$ array of double\} \\ & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc w \rm & double \\  & \PFAc histogram \rm & any record {\PFAtp A} with \{{\PFApf low:}$\!$ double, {\PFApf binsize:}$\!$ double, {\PFApf values:}$\!$ array of double\} \\ & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc w \rm & double \\  & \PFAc histogram \rm & any record {\PFAtp A} with \{{\PFApf ranges:}$\!$ array of array of double, {\PFApf values:}$\!$ array of double\} \\ & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update a histogram by filling it with one value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample value.  \\  & \PFAc w \rm & Sample weight; set to 1 for no weights.  \\  & \PFAc histogram \rm & The histogram prior to filling.  It must have {\PFApf numbins}, {\PFApf low}, {\PFApf high}, and {\PFApf values} (fixed bins) xor it must have {\PFApf low}, {\PFApf binsize}, and {\PFApf values} (number of equal-sized bins grows), xor it must have {\PFApf ranges} and {\PFApf values} (arbitrary interval bins).  Only one set of required fields is allowed (semantic error otherwise), and the rest of the fields are optional.                                                                                                                        \begin{description*}\item[\PFAc numbins:] The fixed number of bins in the histogram. \item[\PFAc low:] The low edge of the histogram range (inclusive). \item[\PFAc high:] The high edge of the histogram range (exclusive). \item[\PFAc binsize:] The size of a bin for a histogram whose number of bins and right edge grows with the data. \item[\PFAc ranges:] Pairs of values describing arbitrary interval bins.  The first number of each pair is the inclusive left edge and the second number is the exclusive right edge. \item[\PFAc values:] Histogram contents, which are updated by this function. \item[\PFAc underflow:] If present, this double-valued field counts {\PFAp x} values that are less than {\PFApf low} or not contained in any {\PFApf ranges}. \item[\PFAc overflow:] If present, this double-valued field counts {\PFAp x} values that are greater than {\PFApf high}. \item[\PFAc nanflow:] If present, this double-valued field counts {\PFAp x} values that are {\PFAc nan}.  {\PFAc nan} values would never enter {\PFApf values}, {\PFApf underflow}, or {\PFApf overflow}. \item[\PFAc :] If present, this double-valued field counts {\PFAp x} values that are infinite.  Infinite values would only enter {\PFApf underflow} or {\PFApf overflow} if {\PFApf infflow} is not present, so that they are not double-counted. \end{description*} \\  & {\it (return value)} \rm & Returns an updated version of {\PFAp histogram}: all fields are unchanged except for {\PFApf values}, {\PFApf underflow}, {\PFApf overflow}, {\PFApf nanflow}, and {\PFApf infflow}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the histogram is growable (described by {\PFApf low} and {\PFApf binsize}) and {\PFAp x} minus {\PFApf low} is greater than or equal to {\PFApf binsize} times the length of {\PFApf values}, the {\PFApf values} will be padded with zeros to reach it. \vspace{0.1 cm} \\ If the histogram is growable (described by {\PFApf low} and {\PFApf binsize}), only finite values can extend the size of the histogram: infinite values are entered into {\PFApf overflow} or {\PFApf infflow}, depending on whether {\PFApf infflow} is present. \vspace{0.1 cm} \\ If the histogram is described by {\PFApf ranges} and an element of {\PFApf ranges} contains two equal values, then {\PFAp x} is considered in the interval if it is exactly equal to the value. \vspace{0.1 cm} \\ If the histogram is described by {\PFApf ranges} and {\PFAp x} falls within multiple, overlapping intervals, then all matching counters are updated (values can be double-counted).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#14080:} If the length of {\PFApf values} is not equal to {\PFApf numbins} or the length of {\PFApf ranges}, then a ``wrong histogram size'' error is raised. \vspace{0.1 cm} \\ {\bf \#14081:} If {\PFApf low} is greater than or equal to {\PFApf high}, then a ``bad histogram range'' error is raised. \vspace{0.1 cm} \\ {\bf \#14082:} If {\PFApf numbins} is less than 1 or {\PFApf binsize} is less than or equal to 0, then a ``bad histogram scale'' error is raised. \vspace{0.1 cm} \\ {\bf \#14083:} If {\PFApf ranges} contains an array of doubles with length not equal to 2 or if the first element is greater than the second element, then a ``bad histogram ranges'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Fill a two-dimensional histogram (stat.sample.fillHistogram2d)}
\hypertarget{stat.sample.fillHistogram2d}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.fillHistogram2d":$\!$ [x, y, w, histogram]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc y \rm & double \\  & \PFAc w \rm & double \\  & \PFAc histogram \rm & any record {\PFAtp A} with \{{\PFApf xnumbins:}$\!$ int, {\PFApf xlow:}$\!$ double, {\PFApf xhigh:}$\!$ double, {\PFApf ynumbins:}$\!$ int, {\PFApf ylow:}$\!$ double, {\PFApf yhigh:}$\!$ double, {\PFApf values:}$\!$ array of array of double\} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update a two-dimensional histogram by filling it with one value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample x value.  \\  & \PFAc y \rm & Sample y value.  \\  & \PFAc w \rm & Sample weight; set to 1 for no weights.  \\  & \PFAc histogram \rm & The histogram prior to filling.                                                                                                                                                                                                     \begin{description*}\item[\PFAc xnumbins:] The number of bins in the x dimension. \item[\PFAc xlow:] The low edge of the histogram range in the x dimension (inclusive). \item[\PFAc xhigh:] The high edge of the histogram range in the x dimension (exclusive). \item[\PFAc ynumbins:] The number of bins in the y dimension. \item[\PFAc ylow:] The low edge of the histogram range in the y dimension (inclusive). \item[\PFAc yhigh:] The high edge of the histogram range in the y dimension (exclusive). \item[\PFAc values:] Histogram contents, which are updated by this function.  The outer array iterates over {\PFAp x} and the inner array iterates over {\PFAp y}. \item[\PFAc underunderflow:] If present, this double-valued field counts instances in which {\PFAp x} is less than {\PFApf xlow} and {\PFAp y} is less than {\PFApf ylow}. \item[\PFAc undermidflow:] If present, this double-valued field counts instances in which {\PFAp x} is less than {\PFApf xlow} and {\PFAp y} between {\PFApf ylow} (inclusive) and {\PFApf yhigh} (exclusive). \item[\PFAc underoverflow:] If present, this double-valued field counts instances in which {\PFAp x} is less than {\PFApf xlow} and {\PFAp y} is greater than or equal to {\PFApf yhigh}. \item[\PFAc midunderflow:] If present, this double-valued field counts instances in which {\PFAp x} is between {\PFApf xlow} (inclusive) and {\PFApf xhigh} (exclusive) and {\PFAp y} is less than {\PFApf ylow}. \item[\PFAc midoverflow:] If present, this double-valued field counts instances in which {\PFAp x} is between {\PFApf xlow} (inclusive) and {\PFApf xhigh} (exclusive) and {\PFAp y} is greater than or equal to {\PFApf yhigh}. \item[\PFAc overunderflow:] If present, this double-valued field counts instances in which {\PFAp x} is greater than or equal to {\PFApf xhigh} and {\PFAp y} is less than {\PFApf ylow}. \item[\PFAc overmidflow:] If present, this double-valued field counts instances in which {\PFAp x} is greater than or equal to {\PFApf xhigh} and {\PFAp y} between {\PFApf ylow} (inclusive) and {\PFApf yhigh} (exclusive). \item[\PFAc overoverflow:] If present, this double-valued field counts instances in which {\PFAp x} is greater than or equal to {\PFApf xhigh} and {\PFAp y} is greater than or equal to {\PFApf yhigh}. \item[\PFAc nanflow:] If present, this double-valued field counts instances in which {\PFAp x} or {\PFAp y} is {\PFAc nan}.  {\PFAc nan} values would never enter any other counter. \item[\PFAc infflow:] If present, this double-valued field counts instances in which {\PFAp x} or {\PFAp y} is infinite.  Infinite values would only enter the other under/mid/overflow counters if {\PFApf infflow} were not present, so that they are not double-counted. \end{description*} \\  & {\it (return value)} \rm & Returns an updated version of {\PFAp histogram}: all fields are unchanged except for {\PFApf values} and the under/mid/over/nan/infflow counters. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp x} is infinite and {\PFAp y} is {\PFAc nan} or {\PFAp x} is {\PFAc nan} and {\PFAp y} is infinite, the entry is counted as {\PFAc nan}, rather than infinite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#14090:} If the length of {\PFApf values} is not equal to {\PFApf xnumbins} or the length of any element of {\PFApf values} is not equal to {\PFApf ynumbins}, then a ``wrong histogram size'' error is raised. \vspace{0.1 cm} \\ {\bf \#14091:} If {\PFApf xlow} is greater than or equal to {\PFApf xhigh} or if {\PFApf ylow} is greater than or equal to {\PFApf yhigh}, then a ``bad histogram range'' error is raised. \vspace{0.1 cm} \\ {\bf \#14092:} If {\PFApf xnumbins} is less than 1 or {\PFApf ynumbins} is less than 1, then a ``bad histogram scale'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Fill a counter/categorical histogram (stat.sample.fillCounter)}
\hypertarget{stat.sample.fillCounter}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.fillCounter":$\!$ [x, w, counter]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\  & \PFAc w \rm & double \\  & \PFAc counter \rm & any record {\PFAtp A} with \{{\PFApf values:}$\!$ map of double\} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update a counter (sparse histogram) by filling it with one value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample category.  \\  & \PFAc w \rm & Sample weight; set to 1 for no weights.  \\  & \PFAc histogram \rm & The counter prior to filling.                     \begin{description*}\item[\PFAc values:] Number of instances seen of each category. \end{description*} \\  & {\it (return value)} \rm & Returns the updated counter. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If a category is not present in the initial {\PFApf values}, it is added with initial value zero prior to filling.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Maintain a top-N list (stat.sample.topN)}
\hypertarget{stat.sample.topN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.topN":$\!$ [x, top, n, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc top \rm & array of {\PFAtp A} \\  & \PFAc n \rm & int \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update an array of the top {\PFAp n} sorted items by potentially adding {\PFAp x} to that array, using {\PFAp lessThan} as a comparison function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample value.  \\  & \PFAc top \rm & Array of items to which {\PFAp x} might be added.  This array is assumed to be sorted according to {\PFAp lessThan}.  \\  & \PFAc n \rm & Maximum number of items to keep.  \\  & \PFAc lessThan \rm & Comparison function; should return {\PFAc true} if its first argument is less than its second argument, {\PFAc false} otherwise.  \\  & {\it (return value)} \rm & Returns an updated version of {\PFAp top}.  If {\PFAp x} is among the top {\PFAp n} values seen, then it is included in the output.  Otherwise, the output is {\PFAp top}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The {\PFAp x} value is inserted after the first element of {\PFAp top} that it is greater than or equal to ({\PFAp lessThan} applied to that array element and {\PFAp x} returns {\PFAc true}) and the result is truncated to size {\PFAp n}.  Thus, the result only represents a top-n list if {\PFAp top} is already sorted and equal elements already in the array get precedence. \vspace{0.1 cm} \\ The {\PFAp top} array is unchanged by this function because all values in PFA are immutable.  The updated array is the return value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Change detection}

\subsubsection{Historical record of triggered events (stat.change.updateTrigger)}
\hypertarget{stat.change.updateTrigger}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.change.updateTrigger":$\!$ [predicate, history]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc predicate \rm & boolean \\  & \PFAc history \rm & any record {\PFAtp A} with \{{\PFApf numEvents:}$\!$ int, {\PFApf numRuns:}$\!$ int, {\PFApf currentRun:}$\!$ int, {\PFApf longestRun:}$\!$ int\} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update the state of a trigger that counts the number of times {\PFAp predicate} is satisfied ({\PFAc true}), as well as the number and lengths of runs of {\PFAc true}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc predicate \rm & Expression that evaluates to {\PFAc true} or {\PFAc false}.  \\  & \PFAc history \rm & Summary of previous results of the {\PFAp predicate}.                                                      \begin{description*}\item[\PFAc numEvents:] The number of times {\PFAp predicate} evaluated to {\PFAc true}. \item[\PFAc numRuns:] The number of contiguous intervals in which {\PFAp predicate} was {\PFAc true}, including the current one. \item[\PFAc currentRun:] If {\PFAp predicate} is {\PFAc false}, {\PFApf currentRun} is 0.  Otherwise, {\PFApf currentRun} is incremented (greater than or equal to 1 if {\PFAp predicate} evaluated to {\PFAc true}). \item[\PFAc longestRun:] The longest run observed so far; may be equal to {\PFApf currentRun}. \end{description*} \\  & {\it (return value)} \rm & Returns a new record with updated fields: {\PFApf numEvents} is always incremented; {\PFApf numRuns} is incremented if {\PFAp predicate} is {\PFAc true} and {\PFApf currentRun} is zero; {\PFApf currentRun} is incremented if {\PFAp predicate} is {\PFAc true} and set to zero if {\PFAp predicate} is {\PFAc false}; {\PFApf longestRun} is set to {\PFApf currentRun} if {\PFAp predicate} is {\PFAc true} and {\PFApf currentRun} is longer than {\PFApf longestRun}.  If the input {\PFAp history} has fields other than {\PFApf numEvents}, {\PFApf numRuns}, {\PFApf currentRun}, or {\PFApf longestRun}, they are copied unaltered to the output. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#37000:} If any of {\PFApf numEvents}, {\PFApf numRuns}, {\PFApf currentRun}, and {\PFApf longestRun} are less than 0, a ``counter out of range'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Simple difference over uncertainty (stat.change.zValue)}
\hypertarget{stat.change.zValue}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"stat.change.zValue":$\!$ [x, meanVariance]\} \rm or \PFAc \{"stat.change.zValue":$\!$ [x, meanVariance, unbiased]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc meanVariance \rm & any record {\PFAtp A} with \{{\PFApf mean:}$\!$ double, {\PFApf variance:}$\!$ double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc meanVariance \rm & any record {\PFAtp A} with \{{\PFApf count:}$\!$ double, {\PFApf mean:}$\!$ double, {\PFApf variance:}$\!$ double\} \\  & \PFAc unbiased \rm & boolean \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Calculate the z-value between {\PFAp x} and a normal distribution with a given mean and variance. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value to test.  \\  & \PFAc meanVariance \rm & A record with {\PFApf mean}, {\PFApf variance}, and possibly {\PFApf count}, such as the output of {\PFAf \hyperlink{stat.sample.Update}{stat.sample.Update}}.  \\  & \PFAc unbiased \rm & If {\PFAc true}, use {\PFApf count} to correct for the bias due to the fact that a variance centered on the mean has one fewer degrees of freedom than the dataset that it was sampled from (Bessel's correction).  \\  & {\it (return value)} \rm & If {\PFAp unbiased} is {\PFAc false}, $(x - mean)/\sqrt{variance}$; otherwise $(x - mean)(1/\sqrt{variance})\sqrt{count/(count - 1)}$. \\ \end{tabular} \vspace{0.2 cm} \\ }

\subsubsection{Cumulative sum (stat.change.updateCUSUM)}
\hypertarget{stat.change.updateCUSUM}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.change.updateCUSUM":$\!$ [logLikelihoodRatio, last, reset]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc logLikelihoodRatio \rm & double \\  & \PFAc last \rm & double \\  & \PFAc reset \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update a cumulative sum (CUSUM) to detect the transition of a dataset from one distribution to another. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc logLikelihoodRatio \rm & The logarithm of the ratio of the likelihood of a value for the alterate and baseline distributions: $\ln(\mbox{alt}_{L}/\mbox{base}_{L})$, which is $\mbox{alt}_{LL} - \mbox{base}_{LL}$ where $L$ is likelihood and $LL$ is log-likelihood.  Consider using something like {\PFAc {``-'': [{``prob.dist.gaussianLL'': [...]}, {``prob.dist.gaussianLL'': [...]}]}}.  \\  & \PFAc last \rm & The previous return value from this function.  \\  & \PFAc reset \rm & A low value (usually consistent with the baseline hypothesis, such as 0) at which the cumulative sum resets, rather than accumulate very low values and become insensitive to future changes.  \\  & {\it (return value)} \rm & An incremented cumulative sum.  The output is $\max\{logLikelihoodRatio + last, reset\}$. \\ \end{tabular} \vspace{0.2 cm} \\ }

\pagebreak

\section{Data mining libraries}

This library contains methods of analyzing data using trained models.  Many of these are usually the outputs of machine learning algorithms.

\subsection{Regression}

\subsubsection{Apply the result of a linear regression (model.reg.linear)}
\hypertarget{model.reg.linear}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.reg.linear":$\!$ [datum, model]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc model \rm & any record {\PFAtp M} with \{{\PFApf coeff:}$\!$ array of double, {\PFApf const:}$\!$ double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc model \rm & any record {\PFAtp M} with \{{\PFApf coeff:}$\!$ array of array of double, {\PFApf const:}$\!$ array of double\} \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & map of double \\  & \PFAc model \rm & any record {\PFAtp M} with \{{\PFApf coeff:}$\!$ map of double, {\PFApf const:}$\!$ double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & map of double \\  & \PFAc model \rm & any record {\PFAtp M} with \{{\PFApf coeff:}$\!$ map of map of double, {\PFApf const:}$\!$ map of double\} \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply matrix {\PFAp model} to independent variables {\PFAp datum} to predict the dependent, predicted variables. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Vector of independent variables with $d$ dimensions.  \\  & \PFAc model \rm & Parameters of the linear model.                                \begin{description*}\item[\PFAc coeff:] Vector or matrix of coefficients that multiply the input variables, which has $p$ rows and $d$ columns. \item[\PFAc const:] Scalar or vector of constant offsets, which has $p$ dimensions. \end{description*} \\  & {\it (return value)} \rm & Returns a $p$ dimensional vector of dependent, predicted variables. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The vectors and matrix may be expressed as arrays (indexed by integers) or maps (indexed by strings). In the array signature, the number of rows and/or columns in {\PFAp x} must be equal to the number of rows and/or columns of {\PFAp y}, respectively (dense matrix). In the map signature, missing row-column combinations are assumed to be zero (sparse matrix). \vspace{0.1 cm} \\ The simpler signature is may be used in the $p = 1$case.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#31000:} The array signature raises a ``misaligned coeff'' error if any row of {\PFApf coeff} does not have the same indexes as {\PFAp datum}. \vspace{0.1 cm} \\ {\bf \#31001:} The array signature raises a ``misaligned const'' error if {\PFApf const} does not have the same indexes as {\PFAp coeff}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Propagate uncertainties through a linear regression (model.reg.linearVariance)}
\hypertarget{model.reg.linearVariance}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.reg.linearVariance":$\!$ [datum, model]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc model \rm & any record {\PFAtp M} with \{{\PFApf covar:}$\!$ array of array of double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc model \rm & any record {\PFAtp M} with \{{\PFApf covar:}$\!$ array of array of array of double\} \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & map of double \\  & \PFAc model \rm & any record {\PFAtp M} with \{{\PFApf covar:}$\!$ map of map of double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & map of double \\  & \PFAc model \rm & any record {\PFAtp M} with \{{\PFApf covar:}$\!$ map of map of map of double\} \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Propagate variances from {\PFAp model} {\PFApf covar} (covariance matrix) to the dependent, predicted variable(s). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Vector of independent variables $\vec{o}$ with $d$ dimensions.  \\  & \PFAc model \rm & Parameters of the linear model.                     \begin{description*}\item[\PFAc covar:] Covariance matrix $C$ or array/map of covariance matrices, one for each dependent, predicted variable.  Each matrix has $d + 1$ rows and $d + 1$ columns: the last (array) or empty string (map) row and column corresponds to the model's constant term.  If there are $p$ dependent, predicted variables, the outermost array/map has $p$ items. \end{description*} \\  & {\it (return value)} \rm & Propagated variance(s) $\vec{o}^T C \vec{o}$ for each dependent, predicted variable. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The ``error'' or ``uncertainty'' in the predicted variable(s) is the square root of this value/these values. \vspace{0.1 cm} \\ The vectors and matrix may be expressed as arrays (indexed by integers) or maps (indexed by strings). In the array signature, the number of rows and/or columns in {\PFAp x} must be equal to the number of rows and/or columns of {\PFAp y}, respectively (dense matrix). In the map signature, missing row-column combinations are assumed to be zero (sparse matrix).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#31010:} The array signature raises a ``misaligned covariance'' error if any covariance matrix does not have the same indexes as {\PFAp datum} plus the implicit index for a constant (last in array signature).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Fit and predict a Gaussian Process (model.reg.gaussianProcess)}
\hypertarget{model.reg.gaussianProcess}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.reg.gaussianProcess":$\!$ [x, table, krigingWeight, kernel]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ double, {\PFApf to:}$\!$ double\} \\  & \PFAc krigingWeight \rm & union of \{null, double\} \\  & \PFAc kernel \rm & function (array of double, array of double) $\to$ double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ double, {\PFApf to:}$\!$ array of double\} \\  & \PFAc krigingWeight \rm & union of \{null, double\} \\  & \PFAc kernel \rm & function (array of double, array of double) $\to$ double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ array of double, {\PFApf to:}$\!$ double\} \\  & \PFAc krigingWeight \rm & union of \{null, double\} \\  & \PFAc kernel \rm & function (array of double, array of double) $\to$ double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ array of double, {\PFApf to:}$\!$ array of double\} \\  & \PFAc krigingWeight \rm & union of \{null, double\} \\  & \PFAc kernel \rm & function (array of double, array of double) $\to$ double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Fit the training data in {\PFAp table} with a Gaussian Process model and predict the value of model at {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Position (scalar or vector) at which to predict the value of the model.  \\  & \PFAc table \rm & Training data for the Gaussian Process.                                           \begin{description*}\item[\PFAc x:] Independent variable (scalar or vector, but same as {\PFAp x}) of a training datum. \item[\PFAc to:] Dependent variable (scalar or vector) of a training datum. \item[\PFAc sigma:] Optional uncertainty for the datum. If present, it must have the same type as {\PFApf to} and is used in the Gaussian Process fit as a nugget. \end{description*} \\  & \PFAc krigingWeight \rm & If a number, the Gaussian Process is performed with the specified Kriging weight. If {\PFAc null}, universal Kriging is performed.  \\  & \PFAc kernel \rm & A function to use as a kernel. For instance, {\PFAf \hyperlink{m.kernel.rbf}{m.kernel.rbf}} (radial basis function) with partially applied {\PFAc gamma} is a squared exponential kernel.  \\  & {\it (return value)} \rm & Returns a scalar or vector prediction with the same type as {\PFApf to}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: unstable.} This function gives the same results every time it is executed, but those results may not be exactly the same on all systems.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#31080:} If {\PFAp table} is empty, a ``table must have at least 1 entry'' error is raised. \vspace{0.1 cm} \\ {\bf \#31081:} If {\PFAp x} is an empty array, an ``x must have at least 1 feature'' error is raised. \vspace{0.1 cm} \\ {\bf \#31082:} If any {\PFApf x} in the {\PFAp table} has a different length than the input parameter {\PFAp x}, a ``table must have the same number of features as x'' error is raised. \vspace{0.1 cm} \\ {\bf \#31083:} If any {\PFApf to} in the {\PFAp table} is an empty array, a ``table outputs must have at least 1 dimension'' error is raised. \vspace{0.1 cm} \\ {\bf \#31084:} If the {\PFApf to} fields in {\PFAp table} do not all have the same dimensions, a ``table outputs must all have the same number of dimensions'' error is raised. \vspace{0.1 cm} \\ {\bf \#31085:} If {\PFAp x} or a component of {\PFAp x} is not finite, an ``x is not finite'' error is raised. \vspace{0.1 cm} \\ {\bf \#31086:} If any value in the {\PFAp table} is not finite, a ``table value is not finite'' error is raised. \vspace{0.1 cm} \\ {\bf \#31087:} If {\PFAp krigingWeight} is a number but is not finite, a ``krigingWeight is not finite'' error is raised. \vspace{0.1 cm} \\ {\bf \#31088:} If evaluating {\PFAp kernel} on all combinations of {\PFAp table} {\PFApf x} (with $1 + (\mbox{sigma}/\mbox{to})^2$ on the diagonal) yields a non-positive definite matrix, a ``matrix of kernel results is not positive definite'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Decision and regression Trees}

This library is organized into test functions (for deciding which branch to take from a given node) and walk functions (for repeatedly applying a test function until reaching a leaf). Different combinations of test functions and walk functions generate a large space of tree-scoring algorithms.

For convenience, the simplest case (simpleTree = simpleTest + simpleWalk) is provided as a single function.

\subsubsection{All-in-one function for simplest case (model.tree.simpleTree)}
\hypertarget{model.tree.simpleTree}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.tree.simpleTree":$\!$ [datum, treeNode]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & any record {\PFAtp D} \\  & \PFAc treeNode \rm & any record {\PFAtp T} with \{{\PFApf field:}$\!$ enum F of fields of D, {\PFApf operator:}$\!$ string, {\PFApf value:}$\!$ any {\PFAtp V}, {\PFApf pass:}$\!$ union of \{{\PFAtp T}, any {\PFAtp S}\}, {\PFApf fail:}$\!$ union of \{{\PFAtp T}, {\PFAtp S}\}\} \\  & {\it (returns)} & {\PFAtp S} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Descend through a tree, testing {\PFAp datum} with {\PFApf field}, {\PFApf operator}, {\PFApf value}, following {\PFApf pass} or {\PFApf fail} until reaching a leaf node of type {\PFAtp S} (score). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Sample value to test.  \\  & \PFAc treeNode \rm & Record that describes a tree node (predicate test with branches).                                                                 \begin{description*}\item[\PFAc field:] Field name from {\PFAp datum}: the enumeration type must include all fields of {\PFAtp D} in their declaration order. \item[\PFAc operator:] One of the following: ``=='' (equal), ``!='' (not equal), ``<'' (less than), ``<='' (less or equal), ``>'' (greater than), ``>='' (greater or equal), ``in'' (member of a set), ``notIn'' (not a member of a set), ``alwaysTrue'' (ignore {\PFApf value}, return {\PFAc true}), ``alwaysFalse'' (ignore {\PFApf value}, return {\PFAc false}), ``isMissing'' (ignore {\PFApf value}, return {\PFAc true} iff the field of {\PFAp datum} is {\PFAc null}), and ``notMissing'' (ignore {\PFApf value}, return {\PFAc false} iff the field of {\PFAp datum} is {\PFAc null}). \item[\PFAc value:] Value to which the field of {\PFAp datum} is compared. \item[\PFAc pass:] Branch to follow if the comparison is successful. \item[\PFAc fail:] Branch to follow if the comparison fails. \end{description*} \\  & {\it (return value)} \rm & Leaf node of type {\PFAtp S}, which must be different from the tree nodes.  For a classification tree, {\PFAtp S} could be a string or an enumeration set.  For a regression tree, {\PFAtp S} would be a numerical type.  For a multivariate regression tree, {\PFAtp S} would be an array of numbers, etc. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This is a convenience function, a combination of {\PFAf \hyperlink{model.tree.simpleWalk}{model.tree.simpleWalk}} with {\PFAf \hyperlink{model.tree.simpleTest}{model.tree.simpleTest}}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#32060:} Raises an ``invalid comparison operator'' if {\PFApf operator} is not one of ``=='', ``!='', ``<'', ``<='', ``>'', ``>='', ``in'', ``notIn'', ``alwaysTrue'', ``alwaysFalse'', ``isMissing'', ``notMissing''. \vspace{0.1 cm} \\ {\bf \#32061:} Raises a ``bad value type'' if the {\PFApf field} of {\PFAp datum} and {\PFAtp V} are not both numbers and the {\PFApf field} cannot be upcast to {\PFAtp V}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Simple test function for a tree node (model.tree.simpleTest)}
\hypertarget{model.tree.simpleTest}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.tree.simpleTest":$\!$ [datum, comparison]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & any record {\PFAtp D} \\  & \PFAc comparison \rm & any record {\PFAtp T} with \{{\PFApf field:}$\!$ enum F of fields of D, {\PFApf operator:}$\!$ string, {\PFApf value:}$\!$ any {\PFAtp V}\} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Determine if {\PFAp datum} passes a test defined by {\PFAp comparison}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Sample value to test.  \\  & \PFAc comparison \rm & Record that describes a test.                                           \begin{description*}\item[\PFAc field:] Field name from {\PFAp datum}: the enumeration type must include all fields of {\PFAtp D} in their declaration order. \item[\PFAc operator:] One of the following: ``=='' (equal), ``!='' (not equal), ``<'' (less than), ``<='' (less or equal), ``>'' (greater than), ``>='' (greater or equal), ``in'' (member of a set), ``notIn'' (not a member of a set), ``alwaysTrue'' (ignore {\PFApf value}, return {\PFAc true}), ``alwaysFalse'' (ignore {\PFApf value}, return {\PFAc false}), ``isMissing'' (ignore {\PFApf value}, return {\PFAc true} iff the field of {\PFAp datum} is {\PFAc null}), and ``notMissing'' (ignore {\PFApf value}, return {\PFAc false} iff the field of {\PFAp datum} is {\PFAc null}). \item[\PFAc value:] Value to which the field of {\PFAp datum} is compared. \end{description*} \\  & {\it (return value)} \rm & Returns {\PFAc true} if the field of {\PFAp datum} <op> {\PFApf value} is {\PFAc true}, {\PFAc false} otherwise, where <op> is the {\PFApf operator}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#32000:} Raises an ``invalid comparison operator'' if {\PFApf operator} is not one of ``=='', ``!='', ``<'', ``<='', ``>'', ``>='', ``in'', ``notIn'', ``alwaysTrue'', ``alwaysFalse'', ``isMissing'', ``notMissing''. \vspace{0.1 cm} \\ {\bf \#32001:} Raises a ``bad value type'' if the {\PFApf field} of {\PFAp datum} and {\PFAtp V} are not both numbers and the {\PFApf field} cannot be upcast to {\PFAtp V}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Test function for a tree node with logical operators (model.tree.compoundTest)}
\hypertarget{model.tree.compoundTest}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.tree.compoundTest":$\!$ [datum, operator, comparisons, test]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & any record {\PFAtp D} \\  & \PFAc operator \rm & string \\  & \PFAc comparisons \rm & array of any record {\PFAtp T} \\  & \PFAc test \rm & function ({\PFAtp D}, {\PFAtp T}) $\to$ boolean \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp test} to an array of {\PFAp comparisons}, returning their logical and, or, or xor, depending on {\PFAp operator}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Simple value to test.  \\  & \PFAc operator \rm & If ``and'', return {\PFAc true} if no {\PFAc false} is encountered, if ``or'', return {\PFAc true} if any {\PFAc true} is encountered, and if ``xor'', return {\PFAc true} if an odd number of {\PFAc true} is encountered among the {\PFAp comparisons}.  \\  & \PFAc comparisons \rm & Array of records that describe the tests.  \\  & \PFAc test \rm & Test function applied to each item of {\PFAp comparisons} until the result is certain.  \\  & {\it (return value)} \rm & Logical combination of {\PFAp comparisons}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp operator} is ``and'', the {\PFAp test} will only be applied until the first {\PFAc false} is encountered. If {\PFAp operator} is ``or'', the {\PFAp test} will only be applied until the first {\PFAc true} is encountered. If {\PFAp operator} is ``xor'', the {\PFAp test} will be applied to all items of {\PFAp comparisons}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#32020:} If {\PFAp operator} is not ``and'', ``or'', or ``xor'', an ``unrecognized logical operator'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Test function with missing value handling (model.tree.missingTest)}
\hypertarget{model.tree.missingTest}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.tree.missingTest":$\!$ [datum, comparison]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & any record {\PFAtp D} \\  & \PFAc comparison \rm & any record {\PFAtp T} with \{{\PFApf field:}$\!$ enum F of fields of D, {\PFApf operator:}$\!$ string, {\PFApf value:}$\!$ any {\PFAtp V}\} \\  & {\it (returns)} & union of \{null, boolean\} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Determine if {\PFAp datum} passes a test defined by {\PFAp comparison}, allowing for missing values. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Sample value to test.  \\  & \PFAc comparison \rm & Record that describes a test.                                           \begin{description*}\item[\PFAc field:] Field name from {\PFAp datum}: the enumeration type must include all fields of {\PFAtp D} in their declaration order. \item[\PFAc operator:] One of the following: ``=='' (equal), ``!='' (not equal), ``<'' (less than), ``<='' (less or equal), ``>'' (greater than), ``>='' (greater or equal), ``in'' (member of a set), ``notIn'' (not a member of a set), ``alwaysTrue'' (ignore {\PFApf value}, return {\PFAc true}), ``alwaysFalse'' (ignore {\PFApf value}, return {\PFAc false}). \item[\PFAc value:] Value to which the field of {\PFAp datum} is compared. \end{description*} \\  & {\it (return value)} \rm & If the field of {\PFAp datum} is {\PFAc null}, this function returns {\PFAc null} (unknown test result).  Otherwise, it returns {\PFAp datum} field <op> {\PFApf value}, where <op> is the {\PFApf operator} \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#32010:} Raises an ``invalid comparison operator'' if {\PFApf operator} is not one of ``=='', ``!='', ``<'', ``<='', ``>'', ``>='', ``in'', ``notIn'', ``alwaysTrue'', ``alwaysFalse''. \vspace{0.1 cm} \\ {\bf \#32011:} Raises a ``bad value type'' if the {\PFApf field} of {\PFAp datum} and {\PFAtp V} are not both numbers and the {\PFApf field} cannot be upcast to {\PFAtp V}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Chain of surrogate tests (model.tree.surrogateTest)}
\hypertarget{model.tree.surrogateTest}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.tree.surrogateTest":$\!$ [datum, comparisons, missingTest]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & any record {\PFAtp D} \\  & \PFAc comparisons \rm & array of any record {\PFAtp T} \\  & \PFAc missingTest \rm & function ({\PFAtp D}, {\PFAtp T}) $\to$ union of \{null, boolean\} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp missingTest} to an array of {\PFAp comparisons} until one yields a non-null result. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Sample value to test.  \\  & \PFAc comparisons \rm & Array of records that describe the tests.  \\  & \PFAc missingTest \rm & Test function applied to each item of {\PFAp comparisons} until one returns a non-null result.  \\  & {\it (return value)} \rm & Returns the value of the first test that returns {\PFAc true} or {\PFAc false}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#32030:} If all tests return {\PFAc null}, this function raises a ``no successful surrogate'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Tree walk without explicit missing value handling (model.tree.simpleWalk)}
\hypertarget{model.tree.simpleWalk}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.tree.simpleWalk":$\!$ [datum, treeNode, test]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & any record {\PFAtp D} \\  & \PFAc treeNode \rm & any record {\PFAtp T} with \{{\PFApf pass:}$\!$ union of \{{\PFAtp T}, any {\PFAtp S}\}, {\PFApf fail:}$\!$ union of \{{\PFAtp T}, {\PFAtp S}\}\} \\  & \PFAc test \rm & function ({\PFAtp D}, {\PFAtp T}) $\to$ boolean \\  & {\it (returns)} & {\PFAtp S} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Descend through a tree, testing the fields of {\PFAp datum} with the {\PFAp test} function using {\PFAp treeNode} to define the comparison, continuing to {\PFApf pass} or {\PFApf fail} until reaching a leaf node of type {\PFAtp S} (score). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Sample value to test.  \\  & \PFAc treeNode \rm & Node of the tree, which contains a predicate to be interpreted by {\PFAp test}.                                \begin{description*}\item[\PFAc pass:] Branch to follow if {\PFAp test} returns {\PFAc true}. \item[\PFAc fail:] Branch to follow if {\PFAp test} returns {\PFAc false}. \end{description*} \\  & \PFAc test \rm & Test function that converts {\PFAp datum} and {\PFAp treeNode} into {\PFAc true} or {\PFAc false}.  \\  & {\it (return value)} \rm & Leaf node of type {\PFAtp S}, which must be different from the tree nodes.  For a classification tree, {\PFAtp S} could be a string or an enumeration set.  For a regression tree, {\PFAtp S} would be a numerical type.  For a multivariate regression tree, {\PFAtp S} would be an array of numbers, etc. \\ \end{tabular} \vspace{0.2 cm} \\ }

\subsubsection{Tree walk with three branches: pass, fail, and missing (model.tree.missingWalk)}
\hypertarget{model.tree.missingWalk}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.tree.missingWalk":$\!$ [datum, treeNode, test]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & any record {\PFAtp D} \\  & \PFAc treeNode \rm & any record {\PFAtp T} with \{{\PFApf pass:}$\!$ union of \{{\PFAtp T}, any {\PFAtp S}\}, {\PFApf fail:}$\!$ union of \{{\PFAtp T}, {\PFAtp S}\}, {\PFApf missing:}$\!$ union of \{{\PFAtp T}, {\PFAtp S}\}\} \\  & \PFAc test \rm & function ({\PFAtp D}, {\PFAtp T}) $\to$ union of \{null, boolean\} \\  & {\it (returns)} & {\PFAtp S} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Descend through a tree, testing the fields of {\PFAp datum} with the {\PFAp test} function using {\PFAp treeNode} to define the comparison, continuing to {\PFApf pass}, {\PFApf fail}, or {\PFApf missing} until reaching a leaf node of type {\PFAtp S} (score). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Sample value to test.  \\  & \PFAc treeNode \rm & Node of the tree, which contains a predicate to be interpreted by {\PFAp test}.                                           \begin{description*}\item[\PFAc pass:] Branch to follow if {\PFAp test} returns {\PFAc true}. \item[\PFAc fail:] Branch to follow if {\PFAp test} returns {\PFAc false}. \item[\PFAc missing:] Branch to follow if {\PFAp test} returns {\PFAc null}. \end{description*} \\  & \PFAc test \rm & Test function that converts {\PFAp datum} and {\PFAp treeNode} into {\PFAc true}, {\PFAc false}, or {\PFAc null}.  \\  & {\it (return value)} \rm & Leaf node of type {\PFAtp S}, which must be different from the tree nodes.  For a classification tree, {\PFAtp S} could be a string or an enumeration set.  For a regression tree, {\PFAtp S} would be a numerical type.  For a multivariate regression tree, {\PFAtp S} would be an array of numbers, etc. \\ \end{tabular} \vspace{0.2 cm} \\ }

\subsection{Cluster models}

\subsubsection{Closest cluster (model.cluster.closest)}
\hypertarget{model.cluster.closest}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.cluster.closest":$\!$ [datum, clusters]\} \rm or \PFAc \{"model.cluster.closest":$\!$ [datum, clusters, metric]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc clusters \rm & array of any record {\PFAtp C} with \{{\PFApf center:}$\!$ array of double\} \\ & {\it (returns)} & {\PFAtp C} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & any {\PFAtp A} \\  & \PFAc clusters \rm & array of any record {\PFAtp C} with \{{\PFApf center:}$\!$ any {\PFAtp B}\} \\  & \PFAc metric \rm & function ({\PFAtp A}, {\PFAtp B}) $\to$ double \\ & {\it (returns)} & {\PFAtp C} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Find the cluster {\PFAtp C} whose {\PFApf center} is closest to the {\PFAp datum}, according to the {\PFAp metric}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Sample datum.  \\  & \PFAc clusters \rm & Set of clusters; the record type {\PFAtp C} may contain additional identifying information for post-processing.  \\  & \PFAc metric \rm & Function used to compare each {\PFAp datum} with the {\PFApf center} of the {\PFAp clusters}.  (See, for example, {\PFAf \hyperlink{metric.euclidean}{metric.euclidean}}.)  \\  & {\it (return value)} \rm & Returns the closest cluster record. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp metric} is not provided, a Euclidean metric over floating point numbers is assumed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#29000:} Raises a ``no clusters'' error if {\PFAp clusters} is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Closest N clusters or N-nearest neighbrs (model.cluster.closestN)}
\hypertarget{model.cluster.closestN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.cluster.closestN":$\!$ [n, datum, clusters]\} \rm or \PFAc \{"model.cluster.closestN":$\!$ [n, datum, clusters, metric]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc n \rm & int \\  & \PFAc datum \rm & array of double \\  & \PFAc clusters \rm & array of any record {\PFAtp C} with \{{\PFApf center:}$\!$ array of double\} \\ & {\it (returns)} & array of {\PFAtp C} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc n \rm & int \\  & \PFAc datum \rm & any {\PFAtp A} \\  & \PFAc clusters \rm & array of any record {\PFAtp C} with \{{\PFApf center:}$\!$ any {\PFAtp B}\} \\  & \PFAc metric \rm & function ({\PFAtp A}, {\PFAtp B}) $\to$ double \\ & {\it (returns)} & array of {\PFAtp C} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Find the {\PFAp n} clusters {\PFAtp C} whose {\PFApf centers} are closest to the {\PFAp datum}, according to the {\PFAp metric}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc n \rm & Number of clusters to search for.  \\  & \PFAc datum \rm & Sample datum.  \\  & \PFAc clusters \rm & Set of clusters; the record type {\PFAtp C} may contain additional identifying information for post-processing.  \\  & \PFAc metric \rm & Function used to compare each {\PFAp datum} with the {\PFApf center} of the {\PFAp clusters}.  (See, for example, {\PFAf \hyperlink{metric.euclidean}{metric.euclidean}}.)  \\  & {\it (return value)} \rm & An array of the closest cluster records in order from the closest to the farthest.  The length of the array is minimum of {\PFAp n} and the length of {\PFAp clusters}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp metric} is not provided, a Euclidean metric over floating point numbers is assumed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#29010:} If {\PFAp n} is negative, an ``n must be nonnegative'' error will be raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Random seeds for online clustering (model.cluster.randomSeeds)}
\hypertarget{model.cluster.randomSeeds}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.cluster.randomSeeds":$\!$ [data, k, newCluster]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc data \rm & array of array of any {\PFAtp A} \\  & \PFAc k \rm & int \\  & \PFAc newCluster \rm & function (int, array of {\PFAtp A}) $\to$ any record {\PFAtp C} with \{{\PFApf center:}$\!$ array of any {\PFAtp B}\} \\  & {\it (returns)} & array of {\PFAtp C} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Call {\PFAp newCluster} to create {\PFAp k} cluster records with random, unique cluster centers drawn from {\PFAp data}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc data \rm & Sample data.  \\  & \PFAc k \rm & Number of times to call {\PFAp newCluster}.  \\  & \PFAc newCluster \rm & Function that creates a cluster record, given an index (ranges from zero up to but not including {\PFAp k}) and a random vector from {\PFAp data}.  \\  & {\it (return value)} \rm & The cluster records created by {\PFAp newCluster}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#29020:} Raises a ``k must be greater than zero'' error if {\PFAp k} is less than or equal to zero. \vspace{0.1 cm} \\ {\bf \#29021:} Raises a ``not enough unique points'' error if {\PFAp data} has fewer than {\PFAp k} unique elements. \vspace{0.1 cm} \\ {\bf \#29022:} Raises a ``dimensions of vectors do not match'' error if the elements of {\PFAp data} are not all the same size.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Online clustering with k-means (model.cluster.kmeansIteration)}
\hypertarget{model.cluster.kmeansIteration}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.cluster.kmeansIteration":$\!$ [data, clusters, metric, update]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc data \rm & array of array of any {\PFAtp A} \\  & \PFAc clusters \rm & array of any record {\PFAtp C} with \{{\PFApf center:}$\!$ array of any {\PFAtp B}\} \\  & \PFAc metric \rm & function (array of {\PFAtp A}, array of {\PFAtp B}) $\to$ double \\  & \PFAc update \rm & function (array of array of {\PFAtp A}, {\PFAtp C}) $\to$ {\PFAtp C} \\  & {\it (returns)} & array of {\PFAtp C} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update a cluster set by applying one iteration of k-means (Lloyd's algorithm). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc data \rm & Sample data.  \\  & \PFAc clusters \rm & Set of clusters; the record type {\PFAtp C} may contain additional identifying information for post-processing.  \\  & \PFAc metric \rm & Function used to compare each {\PFAp datum} with the {\PFApf center} of the {\PFAp clusters}.  (See, for example, {\PFAf \hyperlink{metric.euclidean}{metric.euclidean}}.)  \\  & \PFAc update \rm & Function of matched data and old cluster records that yields new cluster records.  (See, for example, {\PFAf \hyperlink{model.cluster.updateMean}{model.cluster.updateMean}} with {\PFAp weight} = 0.)  \\  & {\it (return value)} \rm & Returns a new cluster set with each of the {\PFAtp centers} located at the average of all points that match the corresponding cluster in the old cluster set. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The {\PFAp update} function is only called if the number of matched data points is greater than zero.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#29030:} Raises a ``no data'' error if {\PFAp data} is empty. \vspace{0.1 cm} \\ {\bf \#29031:} Raises a ``no clusters'' error if {\PFAp clusters} is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Update cluster using the mean of data points (model.cluster.updateMean)}
\hypertarget{model.cluster.updateMean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.cluster.updateMean":$\!$ [data, cluster, weight]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc data \rm & array of array of double \\  & \PFAc cluster \rm & any record {\PFAtp C} with \{{\PFApf center:}$\!$ array of double\} \\  & \PFAc weight \rm & double \\  & {\it (returns)} & {\PFAtp C} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update a cluster record by computing the mean of the {\PFAp data} vectors and {\PFAp weight} times the old {\PFAp cluster} center. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp weight} is zero, the new center is equal to the mean of {\PFAp data}, ignoring the old {\PFAp center}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#29040:} Raises a ``no data'' error if {\PFAp data} is empty. \vspace{0.1 cm} \\ {\bf \#29041:} Raises a ``dimensions of vectors do not match'' error if all elements of {\PFAp data} and the {\PFAp cluster} center do not match.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Nearest neighbor models}

\subsubsection{K nearest points (model.neighbor.nearestK)}
\hypertarget{model.neighbor.nearestK}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.neighbor.nearestK":$\!$ [k, datum, codebook]\} \rm or \PFAc \{"model.neighbor.nearestK":$\!$ [k, datum, codebook, metric]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc k \rm & int \\  & \PFAc datum \rm & array of double \\  & \PFAc codebook \rm & array of array of double \\ & {\it (returns)} & array of array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc k \rm & int \\  & \PFAc datum \rm & any {\PFAtp A} \\  & \PFAc codebook \rm & array of any {\PFAtp B} \\  & \PFAc metric \rm & function ({\PFAtp A}, {\PFAtp B}) $\to$ double \\ & {\it (returns)} & array of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Find the {\PFAp k} items in the {\PFAp codebook} that are closest to the {\PFAp datum}, according to the {\PFAp metric}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc k \rm & Number of {\PFAp codebook} points to attempt to return.  \\  & \PFAc datum \rm & Sample datum.  \\  & \PFAc codebook \rm & Set of training data that is compared to the {\PFAp datum}.  \\  & \PFAc metric \rm & Function used to compare each {\PFAp datum} to each element of the {\PFAp codebook}.  (See, for example, {\PFAf \hyperlink{metric.euclidean}{metric.euclidean}}.)  \\  & {\it (return value)} \rm & An array of the closest {\PFAp codebook} elements in any order.  The length of the array is minimum of {\PFAp k} and the length of {\PFAp codebook}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#30010:} If {\PFAp k} is negative, an ``k must be nonnegative'' error will be raised. \vspace{0.1 cm} \\ {\bf \#30011:} If arrays in the {\PFAp codebook} or the {\PFAp codebook} and the {\PFAp datum} have different sizes (without a {\PFAp metric}), an ``inconsistent dimensionality'' error will be raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{All points within R (model.neighbor.ballR)}
\hypertarget{model.neighbor.ballR}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.neighbor.ballR":$\!$ [r, datum, codebook]\} \rm or \PFAc \{"model.neighbor.ballR":$\!$ [r, datum, codebook, metric]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc r \rm & double \\  & \PFAc datum \rm & array of double \\  & \PFAc codebook \rm & array of array of double \\ & {\it (returns)} & array of array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc r \rm & double \\  & \PFAc datum \rm & any {\PFAtp A} \\  & \PFAc codebook \rm & array of any {\PFAtp B} \\  & \PFAc metric \rm & function ({\PFAtp A}, {\PFAtp B}) $\to$ double \\ & {\it (returns)} & array of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Find the items in {\PFAp codebook} that are within {\PFAp r} of the {\PFAp datum}, according to the {\PFAp metric}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc r \rm & Maximum distance (exclusive) of points to return.  \\  & \PFAc datum \rm & Sample datum.  \\  & \PFAc codebook \rm & Set of training data that is compared to the {\PFAp datum}.  \\  & \PFAc metric \rm & Function used to compare each {\PFAp datum} to each element of the {\PFAp codebook}.  (See, for example, {\PFAf \hyperlink{metric.euclidean}{metric.euclidean}}.)  \\  & {\it (return value)} \rm & An array of the {\PFAp codebook} elements within a distance {\PFAp r} in any order.  The length of the array could be as low as zero or as high as the length of {\PFAp codebook}. \\ \end{tabular} \vspace{0.2 cm} \\ }

\subsubsection{Mean of a sample of points, with weights (model.neighbor.mean)}
\hypertarget{model.neighbor.mean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.neighbor.mean":$\!$ [points]\} \rm or \PFAc \{"model.neighbor.mean":$\!$ [points, weight]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc points \rm & array of array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc points \rm & array of array of double \\  & \PFAc weight \rm & function (array of double) $\to$ double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the vector-wise mean of {\PFAp points}, possibly weighted by {\PFAp weight}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc points \rm & Points from a codebook, for instance from {\PFAf \hyperlink{model.neighbor.nearestK}{model.neighbor.nearestK}}.  \\  & \PFAc weight \rm & Optional weighting function from each element of {\PFAp points} to a value.  If these values do not add up to 1.0, they will be internally normalized.  \\  & {\it (return value)} \rm & The vector-wise mean, which is by construction within the convex hull of the {\PFAp points}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#30000:} If {\PFAp points} is empty, a ``not enough points'' error will be raised. \vspace{0.1 cm} \\ {\bf \#30001:} If the {\PFAp points} have different sizes, an ``inconsistent dimensionality'' error will be raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Naive Bayes}

\subsubsection{Bernoulli two-category likelihood (model.naive.bernoulli)}
\hypertarget{model.naive.bernoulli}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.naive.bernoulli":$\!$ [datum, classModel]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of string \\  & \PFAc classModel \rm & map of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of string \\  & \PFAc classModel \rm & any record {\PFAtp C} with \{{\PFApf values:}$\!$ map of double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Score {\PFAp datum} using a Bernoulli Naive Bayes model. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Vector of independent variables with $d$ dimensions. The record form is for histograms built by {\PFAf \hyperlink{stat.sample.fillCounter}{stat.sample.fillCounter}}.  \\  & \PFAc classModel \rm & Array or map of $d$ likelihoods of the presence of each independent variable for this class.   \\  & {\it (return value)} \rm & Returns the unscaled log-likelihood of {\PFAp datum} for this class. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#10020:} Raises a ``probability in classModel must be strictly between 0 and 1'' error if a value in {\PFAp classModel} is not strictly between zero and one.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Multinomial multi-category likelihood (model.naive.multinomial)}
\hypertarget{model.naive.multinomial}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.naive.multinomial":$\!$ [datum, classModel]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc classModel \rm & array of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & map of double \\  & \PFAc classModel \rm & map of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc classModel \rm & any record {\PFAtp C} with \{{\PFApf values:}$\!$ array of double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & map of double \\  & \PFAc classModel \rm & any record {\PFAtp C} with \{{\PFApf values:}$\!$ map of double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Score {\PFAp datum} using a Multinomial Naive Bayes model. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Vector of independent variables with $d$ dimensions.   \\  & \PFAc classModel \rm & Array or map of multinomial ($d$ different) likelihoods of each independent variable for this class. The record form is for histograms built by {\PFAf \hyperlink{stat.sample.fillHistogram}{stat.sample.fillHistogram}} or {\PFAf \hyperlink{stat.sample.fillCounter}{stat.sample.fillCounter}}.  \\  & {\it (return value)} \rm & Returns the unscaled log-likelihood of {\PFAp datum} for this class. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\PFAp datum} or {\PFAp classModel} may be expressed as arrays (indexed by integers), or maps (indexed by strings).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#10010:} Raises a ``datum and classModel misaligned'' error if when using the map signature the keys of {\PFAp datum} and {\PFAp classModel} don't match one to one, of if when using the array signature they are different lengths. \vspace{0.1 cm} \\ {\bf \#10011:} Raises a ``classModel must be non-empty and strictly positive'' error if classModel is empty or any items are less than or equal to zero.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsubsection{Gaussian continuous likelihood (model.naive.gaussian)}
\hypertarget{model.naive.gaussian}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.naive.gaussian":$\!$ [datum, classModel]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc classModel \rm & array of any record {\PFAtp A} with \{{\PFApf mean:}$\!$ double, {\PFApf variance:}$\!$ double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & map of double \\  & \PFAc classModel \rm & map of any record {\PFAtp A} with \{{\PFApf mean:}$\!$ double, {\PFApf variance:}$\!$ double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Score {\PFAp datum} using a Gaussian Naive Bayes model. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm &  Vector of independent variables with $d$ dimensions.   \\  & \PFAc classModel \rm &  Array or map of $d$ records, each containing the {\PFAp mean} and {\PFAp variance} of each of independent variable, for one class.   \\  & {\it (return value)} \rm & Returns the unscaled log-likelihood that {\PFAp datum} is a member of the class specified by {\PFAp classModel}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\PFAp datum} or {\PFAp classModel} may be expressed as arrays (indexed by integers), or maps (indexed by strings).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#10000:} Raises a ``datum and classModel misaligned'' error if {\PFAp datum} and {\PFAp classModel} have different lengths, of if their keys if using the map signature don't match one to one. \vspace{0.1 cm} \\ {\bf \#10001:} Raises a ``variance less than or equal to zero'' error if a variance inside of {\PFAp classModel} is incorrectly specified.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Neural networks}

\subsubsection{Feedforward neural network organized in layers (model.neural.simpleLayers)}
\hypertarget{model.neural.simpleLayers}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.neural.simpleLayers":$\!$ [datum, model, activation]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc model \rm & array of any record {\PFAtp M} with \{{\PFApf weights:}$\!$ array of array of double, {\PFApf bias:}$\!$ array of double\} \\  & \PFAc activation \rm & function (double) $\to$ double \\  & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply a feedforward artificial neural network {\PFAp model} to an input {\PFAp datum}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Length {\PFAp d} vector of independent variables.  \\  & \PFAc model \rm & Array containing the parameters of each layer of the feedforward neural network model.  \\  & \PFAc activation \rm & Function applied at the output of each node, except the last.  Usually an ``S''-shaped sigmoid or hyperbolic tangent.  \\  & {\it (return value)} \rm & Returns an array of network outputs.  For a neural network with a single neuron in the last layer (single output), this is an array of length one. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#11000:} Raises a ``no layers'' error if the length of model is zero. \vspace{0.1 cm} \\ {\bf \#11001:} Raises a ``weights, bias, or datum misaligned'' error if there is any misalignment between inputs and outputs through the layers of the network.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\subsection{Support vector machines}

\subsubsection{Basic SVM (model.svm.score)}
\hypertarget{model.svm.score}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.svm.score":$\!$ [datum, model, kernel]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc model \rm & any record {\PFAtp L} with \{{\PFApf const:}$\!$ double, {\PFApf posClass:}$\!$ array of any record {\PFAtp M} with \{{\PFApf supVec:}$\!$ array of double, {\PFApf coeff:}$\!$ double\}, {\PFApf negClass:}$\!$ array of any record {\PFAtp N} with \{{\PFApf supVec:}$\!$ array of double, {\PFApf coeff:}$\!$ double\}\} \\  & \PFAc kernel \rm & function (array of double, array of double) $\to$ double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Score an input {\PFAp datum} with a two-class support vector machine classifier given a {\PFAp model} and a kernel function {\PFAp kernel}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Length {\PFAp d} vector of independent variables.  \\  & \PFAc model \rm & Record containing the support vectors, dual space coefficients and constant needed to score new data.  \\  & \PFAc kernel \rm & Kernel function used to map data and support vectors into the dual space.  \\  & {\it (return value)} \rm & Returns the score.  If positive, datum classified as same group as {\PFAp posClass} support vectors.  If negative, datum classified as same group as {\PFAp negClass} support vectors. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#12000:} Raises a ``no support vectors'' error if the length of {\PFAp negClass} and length of {\PFAp posClass} is zero. \vspace{0.1 cm} \\ {\bf \#12001:} Raises a ``support vectors must have same length as datum'' error if the length of the support vectors is not the same as the length of {\PFAp datum}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }

\end{document}
